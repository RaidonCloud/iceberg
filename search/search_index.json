{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pyiceberg","title":"PyIceberg","text":"<p>PyIceberg is a Python implementation for accessing Iceberg tables, without the need of a JVM.</p>"},{"location":"#install","title":"Install","text":"<p>You can install the latest release version from pypi:</p> <pre><code>pip3 install \"pyiceberg[s3fs,hive]\"\n</code></pre> <p>Install it directly for Github (not recommended), but sometimes handy:</p> <pre><code>pip install \"git+https://github.com/apache/iceberg.git#subdirectory=python&amp;egg=pyiceberg[s3fs]\"\n</code></pre> <p>Or clone the repository for local development:</p> <pre><code>git clone https://github.com/apache/iceberg.git\ncd iceberg/python\npip3 install -e \".[s3fs,hive]\"\n</code></pre> <p>You can mix and match optional dependencies depending on your needs:</p> Key Description: hive Support for the Hive metastore glue Support for AWS Glue dynamodb Support for AWS DynamoDB pyarrow PyArrow as a FileIO implementation to interact with the object store pandas Installs both PyArrow and Pandas duckdb Installs both PyArrow and DuckDB ray Installs PyArrow, Pandas, and Ray s3fs S3FS as a FileIO implementation to interact with the object store adlfs ADLFS as a FileIO implementation to interact with the object store snappy Support for snappy Avro compression <p>You either need to install <code>s3fs</code>, <code>adlfs</code> or <code>pyarrow</code> for fetching files.</p> <p>There is both a CLI and Python API available.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Configuration</li> <li>CLI</li> <li>API</li> <li>Contributing</li> <li>Feature support</li> <li>Releases<ul> <li>Verify a release</li> <li>How to release</li> </ul> </li> <li>Code Reference</li> </ul>"},{"location":"api/","title":"API","text":""},{"location":"api/#python-api","title":"Python API","text":"<p>PyIceberg is based around catalogs to load tables. First step is to instantiate a catalog that loads tables. Let's use the following configuration to define a catalog called <code>prod</code>:</p> <pre><code>catalog:\nprod:\nuri: http://rest-catalog/ws/\ncredential: t-1234:secret\n</code></pre> <p>This information must be placed inside a file called <code>.pyiceberg.yaml</code> located either in the <code>$HOME</code> or <code>%USERPROFILE%</code> directory (depending on whether the operating system is Unix-based or Windows-based, respectively) or in the <code>$PYICEBERG_HOME</code> directory (if the corresponding environment variable is set).</p> <p>For more details on possible configurations refer to the specific page.</p> <p>Then load the <code>prod</code> catalog:</p> <pre><code>from pyiceberg.catalog import load_catalog\ncatalog = load_catalog(\"prod\")\ncatalog.list_namespaces()\n</code></pre> <p>Returns two namespaces:</p> <pre><code>[(\"default\",), (\"nyc\",)]\n</code></pre> <p>Listing the tables in the <code>nyc</code> namespace:</p> <pre><code>catalog.list_tables(\"nyc\")\n</code></pre> <p>Returns as list with tuples, containing a single table <code>taxis</code>:</p> <pre><code>[(\"nyc\", \"taxis\")]\n</code></pre>"},{"location":"api/#load-a-table","title":"Load a table","text":""},{"location":"api/#from-a-catalog","title":"From a catalog","text":"<p>Loading the <code>taxis</code> table:</p> <pre><code>catalog.load_table(\"nyc.taxis\")\n# Equivalent to:\ncatalog.load_table((\"nyc\", \"taxis\"))\n# The tuple syntax can be used if the namespace or table contains a dot.\n</code></pre> <p>This returns a <code>Table</code> that represents an Iceberg table that can be queried and altered.</p>"},{"location":"api/#directly-from-a-metadata-file","title":"Directly from a metadata file","text":"<p>To load a table directly from a metadata file (i.e., without using a catalog), you can use a <code>StaticTable</code> as follows:</p> <pre><code>from pyiceberg.table import StaticTable\ntable = StaticTable.from_metadata(\n\"s3a://warehouse/wh/nyc.db/taxis/metadata/00002-6ea51ce3-62aa-4197-9cf8-43d07c3440ca.metadata.json\"\n)\n</code></pre> <p>For the rest, this table behaves similarly as a table loaded using a catalog. Note that <code>StaticTable</code> is intended to be read only.</p> <p>Any properties related to file IO can be passed accordingly:</p> <pre><code>table = StaticTable.from_metadata(\n\"s3a://warehouse/wh/nyc.db/taxis/metadata/00002-6ea51ce3-62aa-4197-9cf8-43d07c3440ca.metadata.json\",\n{PY_IO_IMPL: \"pyiceberg.some.FileIO.class\"},\n)\n</code></pre>"},{"location":"api/#create-a-table","title":"Create a table","text":"<p>To create a table from a catalog:</p> <pre><code>from pyiceberg.catalog import load_catalog\nfrom pyiceberg.schema import Schema\nfrom pyiceberg.types import TimestampType, DoubleType, StringType, NestedField\nschema = Schema(\nNestedField(\nfield_id=1, name=\"datetime\", field_type=TimestampType(), required=False\n),\nNestedField(field_id=2, name=\"bid\", field_type=DoubleType(), required=False),\nNestedField(field_id=3, name=\"ask\", field_type=DoubleType(), required=False),\nNestedField(field_id=4, name=\"symbol\", field_type=StringType(), required=False),\n)\nfrom pyiceberg.partitioning import PartitionSpec, PartitionField\nfrom pyiceberg.transforms import DayTransform\npartition_spec = PartitionSpec(\nPartitionField(\nsource_id=1, field_id=1000, transform=DayTransform(), name=\"datetime_day\"\n)\n)\nfrom pyiceberg.table.sorting import SortOrder, SortField\nfrom pyiceberg.transforms import IdentityTransform\nsort_order = SortOrder(SortField(source_id=4, transform=IdentityTransform()))\ncatalog = load_catalog(\"prod\")\ncatalog.create_table(\nidentifier=\"default.bids\",\nlocation=\"/Users/fokkodriesprong/Desktop/docker-spark-iceberg/wh/bids/\",\nschema=schema,\npartition_spec=partition_spec,\nsort_order=sort_order,\n)\n</code></pre>"},{"location":"api/#update-table-properties","title":"Update table properties","text":"<p>Set and remove properties through the <code>Transaction</code> API:</p> <pre><code>with table.transaction() as transaction:\ntransaction.set_properties(abc=\"def\")\nassert table.properties == {\"abc\": \"def\"}\nwith table.transaction() as transaction:\ntransaction.remove_properties(\"abc\")\nassert table.properties == {}\n</code></pre> <p>Or, without a context manager:</p> <pre><code>table = table.transaction().set_properties(abc=\"def\").commit_transaction()\nassert table.properties == {\"abc\": \"def\"}\ntable = table.transaction().remove_properties(\"abc\").commit_transaction()\nassert table.properties == {}\n</code></pre>"},{"location":"api/#query-the-data","title":"Query the data","text":"<p>To query a table, a table scan is needed. A table scan accepts a filter, columns, optionally a limit and a snapshot ID:</p> <pre><code>from pyiceberg.catalog import load_catalog\nfrom pyiceberg.expressions import GreaterThanOrEqual\ncatalog = load_catalog(\"default\")\ntable = catalog.load_table(\"nyc.taxis\")\nscan = table.scan(\nrow_filter=GreaterThanOrEqual(\"trip_distance\", 10.0),\nselected_fields=(\"VendorID\", \"tpep_pickup_datetime\", \"tpep_dropoff_datetime\"),\nlimit=100,\n)\n# Or filter using a string predicate\nscan = table.scan(\nrow_filter=\"trip_distance &gt; 10.0\",\n)\n[task.file.file_path for task in scan.plan_files()]\n</code></pre> <p>The low level API <code>plan_files</code> methods returns a set of tasks that provide the files that might contain matching rows:</p> <pre><code>[\n\"s3a://warehouse/wh/nyc/taxis/data/00003-4-42464649-92dd-41ad-b83b-dea1a2fe4b58-00001.parquet\"\n]\n</code></pre> <p>In this case it is up to the engine itself to filter the file itself. Below, <code>to_arrow()</code> and <code>to_duckdb()</code> that already do this for you.</p>"},{"location":"api/#apache-arrow","title":"Apache Arrow","text":"<p>Requirements</p> <p>This requires PyArrow to be installed.</p> <p>Using PyIceberg it is filter out data from a huge table and pull it into a PyArrow table:</p> <pre><code>table.scan(\nrow_filter=GreaterThanOrEqual(\"trip_distance\", 10.0),\nselected_fields=(\"VendorID\", \"tpep_pickup_datetime\", \"tpep_dropoff_datetime\"),\n).to_arrow()\n</code></pre> <p>This will return a PyArrow table:</p> <pre><code>pyarrow.Table\nVendorID: int64\ntpep_pickup_datetime: timestamp[us, tz=+00:00]\ntpep_dropoff_datetime: timestamp[us, tz=+00:00]\n----\nVendorID: [[2,1,2,1,1,...,2,2,2,2,2],[2,1,1,1,2,...,1,1,2,1,2],...,[2,2,2,2,2,...,2,6,6,2,2],[2,2,2,2,2,...,2,2,2,2,2]]\ntpep_pickup_datetime: [[2021-04-01 00:28:05.000000,...,2021-04-30 23:44:25.000000]]\ntpep_dropoff_datetime: [[2021-04-01 00:47:59.000000,...,2021-05-01 00:14:47.000000]]\n</code></pre> <p>This will only pull in the files that that might contain matching rows.</p>"},{"location":"api/#duckdb","title":"DuckDB","text":"<p>Requirements</p> <p>This requires DuckDB to be installed.</p> <p>A table scan can also be converted into a in-memory DuckDB table:</p> <pre><code>con = table.scan(\nrow_filter=GreaterThanOrEqual(\"trip_distance\", 10.0),\nselected_fields=(\"VendorID\", \"tpep_pickup_datetime\", \"tpep_dropoff_datetime\"),\n).to_duckdb(table_name=\"distant_taxi_trips\")\n</code></pre> <p>Using the cursor that we can run queries on the DuckDB table:</p> <pre><code>print(\ncon.execute(\n\"SELECT tpep_dropoff_datetime - tpep_pickup_datetime AS duration FROM distant_taxi_trips LIMIT 4\"\n).fetchall()\n)\n[\n(datetime.timedelta(seconds=1194),),\n(datetime.timedelta(seconds=1118),),\n(datetime.timedelta(seconds=1697),),\n(datetime.timedelta(seconds=1581),),\n]\n</code></pre>"},{"location":"api/#ray","title":"Ray","text":"<p>Requirements</p> <p>This requires Ray to be installed.</p> <p>A table scan can also be converted into a Ray dataset:</p> <pre><code>ray_dataset = table.scan(\nrow_filter=GreaterThanOrEqual(\"trip_distance\", 10.0),\nselected_fields=(\"VendorID\", \"tpep_pickup_datetime\", \"tpep_dropoff_datetime\"),\n).to_ray()\n</code></pre> <p>This will return a Ray dataset:</p> <pre><code>Dataset(\n    num_blocks=1,\n    num_rows=1168798,\n    schema={\n        VendorID: int64,\n        tpep_pickup_datetime: timestamp[us, tz=UTC],\n        tpep_dropoff_datetime: timestamp[us, tz=UTC]\n    }\n)\n</code></pre> <p>Using Ray Dataset API to interact with the dataset:</p> <pre><code>print(\nray_dataset.take(2)\n)\n[\n{\n'VendorID': 2,\n'tpep_pickup_datetime': datetime.datetime(2008, 12, 31, 23, 23, 50, tzinfo=&lt;UTC&gt;),\n'tpep_dropoff_datetime': datetime.datetime(2009, 1, 1, 0, 34, 31, tzinfo=&lt;UTC&gt;)\n},\n{\n'VendorID': 2,\n'tpep_pickup_datetime': datetime.datetime(2008, 12, 31, 23, 5, 3, tzinfo=&lt;UTC&gt;),\n'tpep_dropoff_datetime': datetime.datetime(2009, 1, 1, 16, 10, 18, tzinfo=&lt;UTC&gt;)\n}\n]\n</code></pre>"},{"location":"cli/","title":"CLI","text":""},{"location":"cli/#python-cli","title":"Python CLI","text":"<p>Pyiceberg comes with a CLI that's available after installing the <code>pyiceberg</code> package.</p> <p>You can pass the path to the Catalog using the <code>--uri</code> and <code>--credential</code> argument, but it is recommended to setup a <code>~/.pyiceberg.yaml</code> config as described in the Catalog section.</p> <pre><code>\u279c  pyiceberg --help\nUsage: pyiceberg [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n--catalog TEXT\n--verbose BOOLEAN\n--output [text|json]\n--uri TEXT\n--credential TEXT\n--help                Show this message and exit.\n\nCommands:\ndescribe    Describes a namespace xor table\ndrop        Operations to drop a namespace or table\nlist        Lists tables or namespaces\nlocation    Returns the location of the table\nproperties  Properties on tables/namespaces\nrename      Renames a table\nschema      Gets the schema of the table\nspec        Returns the partition spec of the table\nuuid        Returns the UUID of the table\n</code></pre> <p>This example assumes that you have a default catalog set. If you want to load another catalog, for example, the rest example above. Then you need to set <code>--catalog rest</code>.</p> <pre><code>\u279c  pyiceberg list\ndefault\nnyc\n</code></pre> <pre><code>\u279c  pyiceberg list nyc\nnyc.taxis\n</code></pre> <pre><code>\u279c  pyiceberg describe nyc.taxis\nTable format version  1\nMetadata location     file:/.../nyc.db/taxis/metadata/00000-aa3a3eac-ea08-4255-b890-383a64a94e42.metadata.json\nTable UUID            6cdfda33-bfa3-48a7-a09e-7abb462e3460\nLast Updated          1661783158061\nPartition spec        []\nSort order            []\nCurrent schema        Schema, id=0\n\u251c\u2500\u2500 1: VendorID: optional long\n\u251c\u2500\u2500 2: tpep_pickup_datetime: optional timestamptz\n\u251c\u2500\u2500 3: tpep_dropoff_datetime: optional timestamptz\n\u251c\u2500\u2500 4: passenger_count: optional double\n\u251c\u2500\u2500 5: trip_distance: optional double\n\u251c\u2500\u2500 6: RatecodeID: optional double\n\u251c\u2500\u2500 7: store_and_fwd_flag: optional string\n\u251c\u2500\u2500 8: PULocationID: optional long\n\u251c\u2500\u2500 9: DOLocationID: optional long\n\u251c\u2500\u2500 10: payment_type: optional long\n\u251c\u2500\u2500 11: fare_amount: optional double\n\u251c\u2500\u2500 12: extra: optional double\n\u251c\u2500\u2500 13: mta_tax: optional double\n\u251c\u2500\u2500 14: tip_amount: optional double\n\u251c\u2500\u2500 15: tolls_amount: optional double\n\u251c\u2500\u2500 16: improvement_surcharge: optional double\n\u251c\u2500\u2500 17: total_amount: optional double\n\u251c\u2500\u2500 18: congestion_surcharge: optional double\n\u2514\u2500\u2500 19: airport_fee: optional double\nCurrent snapshot      Operation.APPEND: id=5937117119577207079, schema_id=0\nSnapshots             Snapshots\n\u2514\u2500\u2500 Snapshot 5937117119577207079, schema 0: file:/.../nyc.db/taxis/metadata/snap-5937117119577207079-1-94656c4f-4c66-4600-a4ca-f30377300527.avro\nProperties            owner                 root\nwrite.format.default  parquet\n</code></pre> <p>Or output in JSON for automation:</p> <pre><code>\u279c  pyiceberg --output json describe nyc.taxis | jq\n{\n\"identifier\": [\n\"nyc\",\n    \"taxis\"\n],\n  \"metadata_location\": \"file:/.../nyc.db/taxis/metadata/00000-aa3a3eac-ea08-4255-b890-383a64a94e42.metadata.json\",\n  \"metadata\": {\n\"location\": \"file:/.../nyc.db/taxis\",\n    \"table-uuid\": \"6cdfda33-bfa3-48a7-a09e-7abb462e3460\",\n    \"last-updated-ms\": 1661783158061,\n    \"last-column-id\": 19,\n    \"schemas\": [\n{\n\"type\": \"struct\",\n        \"fields\": [\n{\n\"id\": 1,\n            \"name\": \"VendorID\",\n            \"type\": \"long\",\n            \"required\": false\n},\n...\n          {\n\"id\": 19,\n            \"name\": \"airport_fee\",\n            \"type\": \"double\",\n            \"required\": false\n}\n],\n        \"schema-id\": 0,\n        \"identifier-field-ids\": []\n}\n],\n    \"current-schema-id\": 0,\n    \"partition-specs\": [\n{\n\"spec-id\": 0,\n        \"fields\": []\n}\n],\n    \"default-spec-id\": 0,\n    \"last-partition-id\": 999,\n    \"properties\": {\n\"owner\": \"root\",\n      \"write.format.default\": \"parquet\"\n},\n    \"current-snapshot-id\": 5937117119577207000,\n    \"snapshots\": [\n{\n\"snapshot-id\": 5937117119577207000,\n        \"timestamp-ms\": 1661783158061,\n        \"manifest-list\": \"file:/.../nyc.db/taxis/metadata/snap-5937117119577207079-1-94656c4f-4c66-4600-a4ca-f30377300527.avro\",\n        \"summary\": {\n\"operation\": \"append\",\n          \"spark.app.id\": \"local-1661783139151\",\n          \"added-data-files\": \"1\",\n          \"added-records\": \"2979431\",\n          \"added-files-size\": \"46600777\",\n          \"changed-partition-count\": \"1\",\n          \"total-records\": \"2979431\",\n          \"total-files-size\": \"46600777\",\n          \"total-data-files\": \"1\",\n          \"total-delete-files\": \"0\",\n          \"total-position-deletes\": \"0\",\n          \"total-equality-deletes\": \"0\"\n},\n        \"schema-id\": 0\n}\n],\n    \"snapshot-log\": [\n{\n\"snapshot-id\": \"5937117119577207079\",\n        \"timestamp-ms\": 1661783158061\n}\n],\n    \"metadata-log\": [],\n    \"sort-orders\": [\n{\n\"order-id\": 0,\n        \"fields\": []\n}\n],\n    \"default-sort-order-id\": 0,\n    \"refs\": {\n\"main\": {\n\"snapshot-id\": 5937117119577207000,\n        \"type\": \"branch\"\n}\n},\n    \"format-version\": 1,\n    \"schema\": {\n\"type\": \"struct\",\n      \"fields\": [\n{\n\"id\": 1,\n          \"name\": \"VendorID\",\n          \"type\": \"long\",\n          \"required\": false\n},\n...\n        {\n\"id\": 19,\n          \"name\": \"airport_fee\",\n          \"type\": \"double\",\n          \"required\": false\n}\n],\n      \"schema-id\": 0,\n      \"identifier-field-ids\": []\n},\n    \"partition-spec\": []\n}\n}\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#catalogs","title":"Catalogs","text":"<p>PyIceberg currently has native support for REST, Hive and Glue.</p> <p>There are three ways to pass in configuration:</p> <ul> <li>Using the <code>~/.pyiceberg.yaml</code> configuration file</li> <li>Through environment variables</li> <li>By passing in credentials through the CLI or the Python API</li> </ul> <p>The configuration file is recommended since that's the most transparent way. If you prefer environment configuration:</p> <pre><code>export PYICEBERG_CATALOG__DEFAULT__URI=thrift://localhost:9083\n</code></pre> <p>The environment variable picked up by Iceberg starts with <code>PYICEBERG_</code> and then follows the yaml structure below, where a double underscore <code>__</code> represents a nested field.</p>"},{"location":"configuration/#fileio","title":"FileIO","text":"<p>Iceberg works with the concept of a FileIO which is a pluggable module for reading, writing, and deleting files. By default, PyIceberg will try to initialize the FileIO that's suitable for the scheme (<code>s3://</code>, <code>gs://</code>, etc.) and will use the first one that's installed.</p> <ul> <li>s3, s3a, s3n: <code>PyArrowFileIO</code>, <code>FsspecFileIO</code></li> <li>gs: <code>PyArrowFileIO</code></li> <li>file: <code>PyArrowFileIO</code></li> <li>hdfs: <code>PyArrowFileIO</code></li> <li>abfs, abfss: <code>FsspecFileIO</code></li> </ul> <p>You can also set the FileIO explicitly:</p> Key Example Description py-io-impl pyiceberg.io.fsspec.FsspecFileIO Sets the FileIO explicitly to an implementation, and will fail explicitly if it can't be loaded <p>For the FileIO there are several configuration options available:</p>"},{"location":"configuration/#s3","title":"S3","text":"Key Example Description s3.endpoint https://10.0.19.25/ Configure an alternative endpoint of the S3 service for the FileIO to access. This could be used to use S3FileIO with any s3-compatible object storage service that has a different endpoint, or access a private S3 endpoint in a virtual private cloud. s3.access-key-id admin Configure the static secret access key used to access the FileIO. s3.secret-access-key password Configure the static session token used to access the FileIO. s3.signer bearer Configure the signature version of the FileIO. s3.region us-west-2 Sets the region of the bucket"},{"location":"configuration/#azure-data-lake","title":"Azure Data lake","text":"Key Example Description adlfs.connection-string AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqF...;BlobEndpoint=http://localhost/ A connection string. This could be used to use FileIO with any adlfs-compatible object storage service that has a different endpoint (like azurite). adlfs.account-name devstoreaccount1 The account that you want to connect to adlfs.account-key Eby8vdM02xNOcqF... The key to authentication against the account. adlfs.sas-token NuHOuuzdQN7VRM%2FOpOeqBlawRCA845IY05h9eu1Yte4%3D The shared access signature adlfs.tenant-id ad667be4-b811-11ed-afa1-0242ac120002 The tenant-id adlfs.client-id ad667be4-b811-11ed-afa1-0242ac120002 The client-id adlfs.client-secret oCA3R6P*ka#oa1Sms2J74z... The client-secret"},{"location":"configuration/#rest-catalog","title":"REST Catalog","text":"<pre><code>catalog:\ndefault:\nuri: http://rest-catalog/ws/\ncredential: t-1234:secret\ndefault-mtls-secured-catalog:\nuri: https://rest-catalog/ws/\nssl:\nclient:\ncert: /absolute/path/to/client.crt\nkey: /absolute/path/to/client.key\ncabundle: /absolute/path/to/cabundle.pem\n</code></pre> Key Example Description uri https://rest-catalog/ws URI identifying the REST Server credential t-1234:secret Credential to use for OAuth2 credential flow when initializing the catalog token FEW23.DFSDF.FSDF Bearer token value to use for <code>Authorization</code> header rest.sigv4-enabled true Sign requests to the REST Server using AWS SigV4 protocol rest.signing-region us-east-1 The region to use when SigV4 signing a request rest.signing-name execute-api The service signing name to use when SigV4 signing a request"},{"location":"configuration/#hive-catalog","title":"Hive Catalog","text":"<pre><code>catalog:\ndefault:\nuri: thrift://localhost:9083\ns3.endpoint: http://localhost:9000\ns3.access-key-id: admin\ns3.secret-access-key: password\n</code></pre>"},{"location":"configuration/#glue-catalog","title":"Glue Catalog","text":"<p>Your AWS credentials can be passed directly through the Python API. Otherwise, please refer to How to configure AWS credentials to set your AWS account credentials locally. If you did not set up a default AWS profile, you can configure the <code>profile_name</code>.</p> <pre><code>catalog:\ndefault:\ntype: glue\naws_access_key_id: &lt;ACCESS_KEY_ID&gt;\naws_secret_access_key: &lt;SECRET_ACCESS_KEY&gt;\naws_session_token: &lt;SESSION_TOKEN&gt;\nregion_name: &lt;REGION_NAME&gt;\n</code></pre> <pre><code>catalog:\ndefault:\ntype: glue\nprofile_name: &lt;PROFILE_NAME&gt;\nregion_name: &lt;REGION_NAME&gt;\n</code></pre>"},{"location":"configuration/#dynamodb-catalog","title":"DynamoDB Catalog","text":"<p>If you want to use AWS DynamoDB as the catalog, you can use the last two ways to configure the pyiceberg and refer How to configure AWS credentials to set your AWS account credentials locally.</p> <pre><code>catalog:\ndefault:\ntype: dynamodb\ntable-name: iceberg\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing-to-the-iceberg-python-library","title":"Contributing to the Iceberg Python library","text":"<p>For the development, Poetry is used for packing and dependency management. You can install this using:</p> <pre><code>pip install poetry\n</code></pre> <p>If you have an older version of pip and virtualenv you need to update these:</p> <pre><code>pip install --upgrade virtualenv pip\n</code></pre> <p>To get started, you can run <code>make install</code>, which installs Poetry and all the dependencies of the Iceberg library. This also installs the development dependencies. If you don't want to install the development dependencies, you need to install using <code>poetry install --no-dev</code>.</p> <p>If you want to install the library on the host, you can simply run <code>pip3 install -e .</code>. If you wish to use a virtual environment, you can run <code>poetry shell</code>. Poetry will open up a virtual environment with all the dependencies set.</p> <p>To set up IDEA with Poetry (also on Loom):</p> <ul> <li>Open up the Python project in IntelliJ</li> <li>Make sure that you're on latest master (that includes Poetry)</li> <li>Go to File -&gt; Project Structure (\u2318;)</li> <li>Go to Platform Settings -&gt; SDKs</li> <li>Click the + sign -&gt; Add Python SDK</li> <li>Select Poetry Environment from the left hand side bar and hit OK</li> <li>It can take some time to download all the dependencies based on your internet</li> <li>Go to Project Settings -&gt; Project</li> <li>Select the Poetry SDK from the SDK dropdown, and click OK</li> </ul> <p>For IDEA \u22642021 you need to install the Poetry integration as a plugin.</p> <p>Now you're set using Poetry, and all the tests will run in Poetry, and you'll have syntax highlighting in the pyproject.toml to indicate stale dependencies.</p>"},{"location":"contributing/#linting","title":"Linting","text":"<p><code>pre-commit</code> is used for autoformatting and linting:</p> <pre><code>make lint\n</code></pre> <p>Pre-commit will automatically fix the violations such as import orders, formatting etc. Pylint errors you need to fix yourself.</p> <p>In contrast to the name suggest, it doesn't run the checks on the commit. If this is something that you like, you can set this up by running <code>pre-commit install</code>.</p> <p>You can bump the integrations to the latest version using <code>pre-commit autoupdate</code>. This will check if there is a newer version of <code>{black,mypy,isort,...}</code> and update the yaml.</p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>For Python, <code>pytest</code> is used a testing framework in combination with <code>coverage</code> to enforce 90%+ code coverage.</p> <pre><code>make test\n</code></pre> <p>By default, S3 and ADLFS tests are ignored because that require minio and azurite to be running. To run the S3 suite:</p> <pre><code>make test-s3\n</code></pre> <p>To run the ADLFS suite:</p> <pre><code>make test-adlfs\n</code></pre> <p>To pass additional arguments to pytest, you can use <code>PYTEST_ARGS</code>.</p> <p>Run pytest in verbose mode</p> <pre><code>make test PYTEST_ARGS=\"-v\"\n</code></pre> <p>Run pytest with pdb enabled</p> <pre><code>make test PYTEST_ARGS=\"--pdb\"\n</code></pre> <p>To see all available pytest arguments, run <code>make test PYTEST_ARGS=\"--help\"</code>.</p>"},{"location":"contributing/#integration-tests","title":"Integration tests","text":"<p>PyIceberg has integration tests with Apache Spark. Spark will create a new database and provision some tables that PyIceberg can query against.</p> <pre><code>make test-integration\n</code></pre> <p>This will restart the containers, to get to a clean state, and then run the PyTest suite. In case something changed in the Dockerfile or the provision script, you can run:</p> <pre><code>make test-integration-rebuild\n</code></pre> <p>To rebuild the containers from scratch.</p>"},{"location":"contributing/#code-standards","title":"Code standards","text":"<p>Below are the formalized conventions that we adhere to in the PyIceberg project. The goal of this is to have a common agreement on how to evolve the codebase, but also using it as guidelines for newcomers to the project.</p>"},{"location":"contributing/#api-compatibility","title":"API Compatibility","text":"<p>It is important to keep the Python public API compatible across versions. The Python official PEP-8 defines public methods as: Public attributes should have no leading underscores. This means not removing any methods without any notice, or removing or renaming any existing parameters. Adding new optional parameters is okay.</p> <p>If you want to remove a method, please add a deprecation notice by annotating the function using <code>@deprecated</code>:</p> <pre><code>from pyiceberg.utils.deprecated import deprecated\n@deprecated(\ndeprecated_in=\"0.1.0\",\nremoved_in=\"0.2.0\",\nhelp_message=\"Please use load_something_else() instead\",\n)\ndef load_something():\npass\n</code></pre> <p>Which will warn:</p> <pre><code>Call to load_something, deprecated in 0.1.0, will be removed in 0.2.0. Please use load_something_else() instead.\n</code></pre>"},{"location":"contributing/#type-annotations","title":"Type annotations","text":"<p>For the type annotation the types from the <code>Typing</code> package are used.</p> <p>PyIceberg offers support from Python 3.8 onwards, we can't use the type hints from the standard collections.</p>"},{"location":"contributing/#third-party-libraries","title":"Third party libraries","text":"<p>PyIceberg naturally integrates into the rich Python ecosystem, however it is important to be hesistant to add third party packages. Adding a lot of packages makes the library heavyweight, and causes incompatibilities with other projects if they use a different version of the library. Also, big libraries such as <code>s3fs</code>, <code>adlfs</code>, <code>pyarrow</code>, <code>thrift</code> should be optional to avoid downloading everything, while not being sure if is actually being used.</p>"},{"location":"feature-support/","title":"Feature support","text":""},{"location":"feature-support/#feature-support","title":"Feature Support","text":"<p>The goal is that the python library will provide a functional, performant subset of the Java library. The initial focus has been on reading table metadata and provide a convenient CLI to go through the catalog.</p>"},{"location":"feature-support/#metadata","title":"Metadata","text":"Operation Java Python Get Schema X X Get Snapshots X X Plan Scan X X Plan Scan for Snapshot X X Update Current Snapshot X Create Table X X Rename Table X X Drop Table X X Alter Table X Set Table Properties X Create Namespace X X Drop Namespace X X Set Namespace Properties X X"},{"location":"feature-support/#types","title":"Types","text":"<p>The types are kept in <code>pyiceberg.types</code>.</p> <p>Primitive types:</p> <ul> <li><code>BooleanType</code></li> <li><code>StringType</code></li> <li><code>IntegerType</code></li> <li><code>LongType</code></li> <li><code>FloatType</code></li> <li><code>DoubleType</code></li> <li><code>DateType</code></li> <li><code>TimeType</code></li> <li><code>TimestampType</code></li> <li><code>TimestamptzType</code></li> <li><code>BinaryType</code></li> <li><code>UUIDType</code></li> </ul> <p>Complex types:</p> <ul> <li><code>StructType</code></li> <li><code>ListType</code></li> <li><code>MapType</code></li> <li><code>FixedType(16)</code></li> <li><code>DecimalType(8, 3)</code></li> </ul>"},{"location":"feature-support/#expressions","title":"Expressions","text":"<p>The expressions are kept in <code>pyiceberg.expressions</code>.</p> <ul> <li><code>IsNull</code></li> <li><code>NotNull</code></li> <li><code>IsNaN</code></li> <li><code>NotNaN</code></li> <li><code>In</code></li> <li><code>NotIn</code></li> <li><code>EqualTo</code></li> <li><code>NotEqualTo</code></li> <li><code>GreaterThanOrEqual</code></li> <li><code>GreaterThan</code></li> <li><code>LessThanOrEqual</code></li> <li><code>LessThan</code></li> <li><code>And</code></li> <li><code>Or</code></li> <li><code>Not</code></li> </ul>"},{"location":"how-to-release/","title":"How to release","text":""},{"location":"how-to-release/#how-to-release","title":"How to release","text":"<p>The guide to release PyIceberg.</p> <p>The first step is to publish a release candidate (RC) and publish it to the public for testing and validation. Once the vote has passed on the RC, the RC turns into the new release.</p>"},{"location":"how-to-release/#running-a-release-candidate","title":"Running a release candidate","text":"<p>Make sure that you're on the version that you want to release. And that the version is correct in <code>pyproject.toml</code> and <code>pyiceberg/__init__.py</code>. Correct means that it reflects the version that you want to release, and doesn't contain any additional modifiers, such as <code>dev0</code>.</p> <pre><code>export RC=rc1\nexport VERSION=0.1.0${RC}\nexport VERSION_WITHOUT_RC=${VERSION/rc?/}\nexport VERSION_BRANCH=${VERSION_WITHOUT_RC//./-}\nexport GIT_TAG=pyiceberg-${VERSION}\ngit tag -s ${GIT_TAG} -m \"PyIceberg ${VERSION}\"\ngit push apache ${GIT_TAG}\nexport GIT_TAG_REF=$(git show-ref ${GIT_TAG})\nexport GIT_TAG_HASH=${GIT_TAG_REF:0:40}\nexport LAST_COMMIT_ID=$(git rev-list ${GIT_TAG} 2&gt; /dev/null | head -n 1)\n</code></pre> <p>The <code>-s</code> option will sign the commit. If you don't have a key yet, you can find the instructions here. To install gpg on a M1 based Mac, a couple of additional steps are required: https://gist.github.com/phortuin/cf24b1cca3258720c71ad42977e1ba57</p> <p>Next step is to remove the <code>dist/</code> directory to make sure that we have a clean start. Create a source distribution (<code>sdist</code>) which will generate a <code>.tar.gz</code> with all the source files using <code>poetry build</code>. These files need to be uploaded to the Apache SVN.</p> <pre><code>rm -rf dist/\npoetry build\n</code></pre> <p>This will create two artifacts:</p> <pre><code>Building pyiceberg (0.1.0)\n  - Building sdist\n  - Built pyiceberg-0.1.0.tar.gz\n  - Building wheel\n  - Built apache_iceberg-0.1.0-py3-none-any.whl\n</code></pre> <p>The <code>sdist</code> contains the source which can be used for checking licenses, and the wheel is a compiled version for quick installation.</p> <p>Before committing the files to the Apache SVN artifact distribution SVN hashes need to be generated, and those need to be signed with gpg to make sure that they are authentic:</p> <pre><code>for name in \"pyiceberg-${VERSION_WITHOUT_RC}-py3-none-any.whl\" \"pyiceberg-${VERSION_WITHOUT_RC}.tar.gz\"\ndo\ngpg --yes --armor --local-user fokko@apache.org --output \"dist/${name}.asc\" --detach-sig \"dist/${name}\"\n(cd dist/ &amp;&amp; shasum -a 512 \"${name}\" &gt; \"${name}.sha512\")\ndone\n</code></pre> <p>Next step is to clone the Apache SVN, copy and commit the files:</p> <pre><code>export SVN_TMP_DIR=/tmp/iceberg-${VERSION_BRANCH}/\nsvn checkout https://dist.apache.org/repos/dist/dev/iceberg $SVN_TMP_DIR\nexport SVN_TMP_DIR_VERSIONED=${SVN_TMP_DIR}pyiceberg-$VERSION/\nmkdir -p $SVN_TMP_DIR_VERSIONED\ncp dist/* $SVN_TMP_DIR_VERSIONED\nsvn add $SVN_TMP_DIR_VERSIONED\nsvn ci -m \"PyIceberg ${VERSION}\" ${SVN_TMP_DIR_VERSIONED}\n</code></pre> <p>Next step is to upload them to pypi. Please keep in mind that this won't bump the version for everyone that hasn't pinned their version, since it is set to a RC pre-release and those are ignored.</p> <pre><code>poetry version ${VERSION}\nrm -rf dist/\npoetry build\ntwine upload -s dist/*\n</code></pre> <p>Final step is to generate the email to the dev mail list:</p> <pre><code>cat &lt;&lt; EOF &gt; release-announcement-email.txt\nTo: dev@iceberg.apache.org\nSubject: [VOTE] Release Apache PyIceberg $VERSION_WITHOUT_RC\nHi Everyone,\nI propose that we release the following RC as the official PyIceberg $VERSION_WITHOUT_RC release.\nThe commit ID is $LAST_COMMIT_ID\n* This corresponds to the tag: $GIT_TAG ($GIT_TAG_HASH)\n* https://github.com/apache/iceberg/releases/tag/$GIT_TAG\n* https://github.com/apache/iceberg/tree/$LAST_COMMIT_ID\nThe release tarball, signature, and checksums are here:\n* https://dist.apache.org/repos/dist/dev/iceberg/pyiceberg-$VERSION/\nYou can find the KEYS file here:\n* https://dist.apache.org/repos/dist/dev/iceberg/KEYS\nConvenience binary artifacts are staged on pypi:\nhttps://pypi.org/project/pyiceberg/$VERSION/\nAnd can be installed using: pip3 install pyiceberg==$VERSION\nPlease download, verify, and test.\nPlease vote in the next 72 hours.\n[ ] +1 Release this as PyIceberg $VERSION_WITHOUT_RC\n[ ] +0\n[ ] -1 Do not release this because...\nEOF\ncat release-announcement-email.txt\n</code></pre>"},{"location":"how-to-release/#vote-has-passed","title":"Vote has passed","text":"<p>Once the vote has been passed, the latest version can be pushed to PyPi. Check out the commit associated with the passing vote, and run:</p> <pre><code>rm -rf dist/\npoetry build\ntwine upload -s dist/*\n</code></pre> <p>Send out an announcement on the dev mail list:</p> <pre><code>To: dev@iceberg.apache.org\nSubject: [ANNOUNCE] Apache PyIceberg release &lt;VERSION&gt;\n\nI'm pleased to announce the release of Apache PyIceberg &lt;VERSION&gt;!\n\nApache Iceberg is an open table format for huge analytic datasets. Iceberg\ndelivers high query performance for tables with tens of petabytes of data,\nalong with atomic commits, concurrent writes, and SQL-compatible table\nevolution.\n\nThis Python release can be downloaded from: https://pypi.org/project/pyiceberg/&lt;VERSION&gt;/\n\nThanks to everyone for contributing!\n</code></pre>"},{"location":"how-to-release/#release-the-docs","title":"Release the docs","text":"<p>A committer triggers the <code>Python Docs</code> Github Actions through the UI by selecting the branch that just has been released. This will publish the new docs.</p>"},{"location":"verify-release/","title":"Verify a release","text":""},{"location":"verify-release/#verifying-a-release","title":"Verifying a release","text":"<p>Each Apache PyIceberg release is validated by the community by holding a vote. A community release manager will prepare a release candidate and call a vote on the Iceberg dev list. To validate the release candidate, community members will test it out in their downstream projects and environments.</p> <p>In addition to testing in downstream projects, community members also check the release\u2019s signatures, checksums, and license documentation.</p>"},{"location":"verify-release/#validating-a-release-candidate","title":"Validating a release candidate","text":"<p>Release announcements include links to the following:</p> <ul> <li>A source tarball</li> <li>A signature (.asc)</li> <li>A checksum (.sha512)</li> <li>KEYS file</li> <li>GitHub change comparison</li> </ul> <p>After downloading the source tarball, signature, checksum, and KEYS file, here are instructions on how to verify signatures, checksums, and documentation.</p>"},{"location":"verify-release/#verifying-signatures","title":"Verifying signatures","text":"<p>First, import the keys.</p> <pre><code>curl https://dist.apache.org/repos/dist/dev/iceberg/KEYS -o KEYS\ngpg --import KEYS\n</code></pre> <p>Next, verify the <code>.asc</code> file.</p> <pre><code>gpg --verify pyiceberg-0.4.0-py3-none-any.whl.asc pyiceberg-0.4.0-py3-none-any.whl\n</code></pre>"},{"location":"verify-release/#verifying-checksums","title":"Verifying checksums","text":"<pre><code>shasum -a 512 --check pyiceberg-0.4.0-py3-none-any.whl.sha512\n</code></pre>"},{"location":"verify-release/#verifying-license-documentation","title":"Verifying License Documentation","text":"<pre><code>tar xzf pyiceberg-0.4.0.tar.gz\ncd pyiceberg-0.4.0\n</code></pre> <p>Run RAT checks to validate license header:</p> <pre><code>./dev/check-license\n</code></pre>"},{"location":"verify-release/#testing","title":"Testing","text":"<p>This section explains how to run the tests of the source distribution.</p> <p>Clean environment</p> <p>To make sure that your environment is fresh is to run the tests in a new Docker container: <code>docker run -t -i -v $(pwd):/pyiceberg/ python:3.9 bash</code>. And change directory: <code>cd /pyiceberg/</code>.</p> <p>First step is to install the package:</p> <pre><code>make install\n</code></pre> <p>And then run the tests:</p> <pre><code>make test\n</code></pre> <p>To run the full integration tests:</p> <pre><code>make test-s3\n</code></pre> <p>This will include a Minio S3 container being spun up.</p>"},{"location":"verify-release/#cast-the-vote","title":"Cast the vote","text":"<p>Votes are cast by replying to the release candidate announcement email on the dev mailing list with either <code>+1</code>, <code>0</code>, or <code>-1</code>. For example :</p> <p>[ ] +1 Release this as PyIceberg 0.3.0 [ ] +0 [ ] -1 Do not release this because\u2026</p> <p>In addition to your vote, it\u2019s customary to specify if your vote is binding or non-binding. Only members of the Project Management Committee have formally binding votes. If you\u2019re unsure, you can specify that your vote is non-binding. To read more about voting in the Apache framework, checkout the Voting information page on the Apache foundation\u2019s website.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pyiceberg<ul> <li>avro<ul> <li>codecs<ul> <li>bzip2</li> <li>codec</li> <li>deflate</li> <li>snappy_codec</li> <li>zstandard_codec</li> </ul> </li> <li>decoder</li> <li>file</li> <li>reader</li> <li>resolver</li> </ul> </li> <li>catalog<ul> <li>dynamodb</li> <li>glue</li> <li>hive</li> <li>noop</li> <li>rest</li> </ul> </li> <li>cli<ul> <li>console</li> <li>output</li> </ul> </li> <li>conversions</li> <li>exceptions</li> <li>expressions<ul> <li>literals</li> <li>parser</li> <li>visitors</li> </ul> </li> <li>files</li> <li>io<ul> <li>fsspec</li> <li>memory</li> <li>pyarrow</li> </ul> </li> <li>manifest</li> <li>partitioning</li> <li>schema</li> <li>serializers</li> <li>table<ul> <li>metadata</li> <li>refs</li> <li>snapshots</li> <li>sorting</li> </ul> </li> <li>transforms</li> <li>typedef</li> <li>types</li> <li>utils<ul> <li>bin_packing</li> <li>config</li> <li>datetime</li> <li>decimal</li> <li>deprecated</li> <li>parsing</li> <li>schema_conversion</li> <li>singleton</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/pyiceberg/","title":"pyiceberg","text":""},{"location":"reference/pyiceberg/conversions/","title":"conversions","text":"<p>Utility module for various conversions around PrimitiveType implementations.</p> This module enables <ul> <li>Converting partition strings to built-in python objects.</li> <li>Converting a value to a byte buffer.</li> <li>Converting a byte buffer to a value.</li> </ul> Note <p>Conversion logic varies based on the PrimitiveType implementation. Therefore conversion functions are defined here as generic functions using the @singledispatch decorator. For each PrimitiveType implementation, a concrete function is registered for each generic conversion function. For PrimitiveType implementations that share the same conversion logic, registrations can be stacked.</p>"},{"location":"reference/pyiceberg/conversions/#pyiceberg.conversions.from_bytes","title":"<code>from_bytes(primitive_type, b)</code>","text":"<p>A generic function which converts bytes to a built-in python value.</p> <p>Parameters:</p> Name Type Description Default <code>primitive_type</code> <code>PrimitiveType</code> <p>An implementation of the PrimitiveType base class.</p> required <code>b</code> <code>bytes</code> <p>The bytes to convert.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/conversions.py</code> <pre><code>@singledispatch\ndef from_bytes(primitive_type: PrimitiveType, b: bytes) -&gt; L:\n\"\"\"A generic function which converts bytes to a built-in python value.\n    Args:\n        primitive_type (PrimitiveType): An implementation of the PrimitiveType base class.\n        b (bytes): The bytes to convert.\n    \"\"\"\nraise TypeError(f\"Cannot deserialize bytes, type {primitive_type} not supported: {str(b)}\")\n</code></pre>"},{"location":"reference/pyiceberg/conversions/#pyiceberg.conversions.handle_none","title":"<code>handle_none(func)</code>","text":"<p>A decorator function to handle cases where partition values are <code>None</code> or \"HIVE_DEFAULT_PARTITION\".</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A function registered to the singledispatch function <code>partition_to_py</code>.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/conversions.py</code> <pre><code>def handle_none(func: Callable) -&gt; Callable:  # type: ignore\n\"\"\"A decorator function to handle cases where partition values are `None` or \"__HIVE_DEFAULT_PARTITION__\".\n    Args:\n        func (Callable): A function registered to the singledispatch function `partition_to_py`.\n    \"\"\"\ndef wrapper(primitive_type: PrimitiveType, value_str: Optional[str]) -&gt; Any:\nif value_str is None:\nreturn None\nelif value_str == \"__HIVE_DEFAULT_PARTITION__\":\nreturn None\nreturn func(primitive_type, value_str)\nreturn wrapper\n</code></pre>"},{"location":"reference/pyiceberg/conversions/#pyiceberg.conversions.partition_to_py","title":"<code>partition_to_py(primitive_type, value_str)</code>","text":"<p>A generic function which converts a partition string to a python built-in.</p> <p>Parameters:</p> Name Type Description Default <code>primitive_type</code> <code>PrimitiveType</code> <p>An implementation of the PrimitiveType base class.</p> required <code>value_str</code> <code>str</code> <p>A string representation of a partition value.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/conversions.py</code> <pre><code>@singledispatch\ndef partition_to_py(primitive_type: PrimitiveType, value_str: str) -&gt; Union[int, float, str, uuid.UUID, bytes, Decimal]:\n\"\"\"A generic function which converts a partition string to a python built-in.\n    Args:\n        primitive_type (PrimitiveType): An implementation of the PrimitiveType base class.\n        value_str (str): A string representation of a partition value.\n    \"\"\"\nraise TypeError(f\"Cannot convert '{value_str}' to unsupported type: {primitive_type}\")\n</code></pre>"},{"location":"reference/pyiceberg/conversions/#pyiceberg.conversions.to_bytes","title":"<code>to_bytes(primitive_type, _)</code>","text":"<p>A generic function which converts a built-in python value to bytes.</p> <p>This conversion follows the serialization scheme for storing single values as individual binary values defined in the Iceberg specification that can be found at https://iceberg.apache.org/spec/#appendix-d-single-value-serialization</p> <p>Parameters:</p> Name Type Description Default <code>primitive_type</code> <code>PrimitiveType</code> <p>An implementation of the PrimitiveType base class.</p> required <code>_</code> <code>Union[bool, bytes, Decimal, float, int, str, uuid.UUID]</code> <p>The value to convert to bytes (The type of this value depends on which dispatched function is used--check dispatchable functions for type hints).</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/conversions.py</code> <pre><code>@singledispatch\ndef to_bytes(primitive_type: PrimitiveType, _: Union[bool, bytes, Decimal, float, int, str, uuid.UUID]) -&gt; bytes:\n\"\"\"A generic function which converts a built-in python value to bytes.\n    This conversion follows the serialization scheme for storing single values as individual binary values defined in the Iceberg specification that\n    can be found at https://iceberg.apache.org/spec/#appendix-d-single-value-serialization\n    Args:\n        primitive_type (PrimitiveType): An implementation of the PrimitiveType base class.\n        _: The value to convert to bytes (The type of this value depends on which dispatched function is\n            used--check dispatchable functions for type hints).\n    \"\"\"\nraise TypeError(f\"scale does not match {primitive_type}\")\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/","title":"exceptions","text":""},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.AuthorizationExpiredError","title":"<code>AuthorizationExpiredError</code>","text":"<p>         Bases: <code>RESTError</code></p> <p>When the credentials are expired when performing an action on the REST catalog.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class AuthorizationExpiredError(RESTError):\n\"\"\"When the credentials are expired when performing an action on the REST catalog.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.BadRequestError","title":"<code>BadRequestError</code>","text":"<p>         Bases: <code>RESTError</code></p> <p>Raises when an invalid request is being made.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class BadRequestError(RESTError):\n\"\"\"Raises when an invalid request is being made.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.CommitFailedException","title":"<code>CommitFailedException</code>","text":"<p>         Bases: <code>RESTError</code></p> <p>Commit failed, refresh and try again.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class CommitFailedException(RESTError):\n\"\"\"Commit failed, refresh and try again.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.CommitStateUnknownException","title":"<code>CommitStateUnknownException</code>","text":"<p>         Bases: <code>RESTError</code></p> <p>Commit failed due to unknown reason.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class CommitStateUnknownException(RESTError):\n\"\"\"Commit failed due to unknown reason.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.ForbiddenError","title":"<code>ForbiddenError</code>","text":"<p>         Bases: <code>RESTError</code></p> <p>Raises when you don't have the credentials to perform the action on the REST catalog.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class ForbiddenError(RESTError):\n\"\"\"Raises when you don't have the credentials to perform the action on the REST catalog.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.NamespaceAlreadyExistsError","title":"<code>NamespaceAlreadyExistsError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raised when a name-space being created already exists in the catalog.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class NamespaceAlreadyExistsError(Exception):\n\"\"\"Raised when a name-space being created already exists in the catalog.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.NamespaceNotEmptyError","title":"<code>NamespaceNotEmptyError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raised when a name-space being dropped is not empty.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class NamespaceNotEmptyError(Exception):\n\"\"\"Raised when a name-space being dropped is not empty.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.NoSuchIcebergTableError","title":"<code>NoSuchIcebergTableError</code>","text":"<p>         Bases: <code>NoSuchTableError</code></p> <p>Raises when the table found in the REST catalog is not an iceberg table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class NoSuchIcebergTableError(NoSuchTableError):\n\"\"\"Raises when the table found in the REST catalog is not an iceberg table.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.NoSuchNamespaceError","title":"<code>NoSuchNamespaceError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raised when a referenced name-space is not found.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class NoSuchNamespaceError(Exception):\n\"\"\"Raised when a referenced name-space is not found.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.NoSuchPropertyException","title":"<code>NoSuchPropertyException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>When a property is missing.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class NoSuchPropertyException(Exception):\n\"\"\"When a property is missing.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.NoSuchTableError","title":"<code>NoSuchTableError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raises when the table can't be found in the REST catalog.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class NoSuchTableError(Exception):\n\"\"\"Raises when the table can't be found in the REST catalog.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.NotInstalledError","title":"<code>NotInstalledError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>When an optional dependency is not installed.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class NotInstalledError(Exception):\n\"\"\"When an optional dependency is not installed.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.OAuthError","title":"<code>OAuthError</code>","text":"<p>         Bases: <code>RESTError</code></p> <p>Raises when there is an error with the OAuth call.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class OAuthError(RESTError):\n\"\"\"Raises when there is an error with the OAuth call.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.RESTError","title":"<code>RESTError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raises when there is an unknown response from the REST Catalog.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class RESTError(Exception):\n\"\"\"Raises when there is an unknown response from the REST Catalog.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.ServerError","title":"<code>ServerError</code>","text":"<p>         Bases: <code>RESTError</code></p> <p>Raises when there is an unhandled exception on the server side.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class ServerError(RESTError):\n\"\"\"Raises when there is an unhandled exception on the server side.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.ServiceUnavailableError","title":"<code>ServiceUnavailableError</code>","text":"<p>         Bases: <code>RESTError</code></p> <p>Raises when the service doesn't respond.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class ServiceUnavailableError(RESTError):\n\"\"\"Raises when the service doesn't respond.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.SignError","title":"<code>SignError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raises when unable to sign a S3 request.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class SignError(Exception):\n\"\"\"Raises when unable to sign a S3 request.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.TableAlreadyExistsError","title":"<code>TableAlreadyExistsError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raised when creating a table with a name that already exists.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class TableAlreadyExistsError(Exception):\n\"\"\"Raised when creating a table with a name that already exists.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.UnauthorizedError","title":"<code>UnauthorizedError</code>","text":"<p>         Bases: <code>RESTError</code></p> <p>Raises when you don't have the proper authorization.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class UnauthorizedError(RESTError):\n\"\"\"Raises when you don't have the proper authorization.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/exceptions/#pyiceberg.exceptions.ValidationError","title":"<code>ValidationError</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Raises when there is an issue with the schema.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/exceptions.py</code> <pre><code>class ValidationError(Exception):\n\"\"\"Raises when there is an issue with the schema.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/files/","title":"files","text":""},{"location":"reference/pyiceberg/files/#pyiceberg.files.FileContentType","title":"<code>FileContentType</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enum that includes all possible content types for an Iceberg data file.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/files.py</code> <pre><code>class FileContentType(Enum):\n\"\"\"An enum that includes all possible content types for an Iceberg data file.\"\"\"\nDATA = auto()\nPOSITION_DELETES = auto()\nEQUALITY_DELETES = auto()\n</code></pre>"},{"location":"reference/pyiceberg/files/#pyiceberg.files.FileFormat","title":"<code>FileFormat</code>","text":"<p>         Bases: <code>Enum</code></p> <p>An enum that includes all possible formats for an Iceberg data file.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/files.py</code> <pre><code>class FileFormat(Enum):\n\"\"\"An enum that includes all possible formats for an Iceberg data file.\"\"\"\nORC = \"ORC\"\nPARQUET = \"PARQUET\"\nAVRO = \"AVRO\"\nMETADATA = \"METADATA\"\n</code></pre>"},{"location":"reference/pyiceberg/manifest/","title":"manifest","text":""},{"location":"reference/pyiceberg/manifest/#pyiceberg.manifest.DataFile","title":"<code>DataFile</code>","text":"<p>         Bases: <code>Record</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/manifest.py</code> <pre><code>class DataFile(Record):\ncontent: DataFileContent\nfile_path: str\nfile_format: FileFormat\npartition: Record\nrecord_count: int\nfile_size_in_bytes: int\ncolumn_sizes: Dict[int, int]\nvalue_counts: Dict[int, int]\nnull_value_counts: Dict[int, int]\nnan_value_counts: Dict[int, int]\nlower_bounds: Dict[int, bytes]\nupper_bounds: Dict[int, bytes]\nkey_metadata: Optional[bytes]\nsplit_offsets: Optional[List[int]]\nequality_ids: Optional[List[int]]\nsort_order_id: Optional[int]\nspec_id: Optional[int]\ndef __setattr__(self, name: str, value: Any) -&gt; None:\n\"\"\"Used for assigning a key/value to a DataFile.\"\"\"\n# The file_format is written as a string, so we need to cast it to the Enum\nif name == \"file_format\":\nvalue = FileFormat[value]\nsuper().__setattr__(name, value)\ndef __init__(self, *data: Any, **named_data: Any) -&gt; None:\nsuper().__init__(*data, **{\"struct\": DATA_FILE_TYPE, **named_data})\ndef __hash__(self) -&gt; int:\n\"\"\"Returns the hash of the file path.\"\"\"\nreturn hash(self.file_path)\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Compares the datafile with another object.\n        If it is a datafile, it will compare based on the file_path.\n        \"\"\"\nreturn self.file_path == other.file_path if isinstance(other, DataFile) else False\n</code></pre>"},{"location":"reference/pyiceberg/manifest/#pyiceberg.manifest.DataFile.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compares the datafile with another object.</p> <p>If it is a datafile, it will compare based on the file_path.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/manifest.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Compares the datafile with another object.\n    If it is a datafile, it will compare based on the file_path.\n    \"\"\"\nreturn self.file_path == other.file_path if isinstance(other, DataFile) else False\n</code></pre>"},{"location":"reference/pyiceberg/manifest/#pyiceberg.manifest.DataFile.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns the hash of the file path.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/manifest.py</code> <pre><code>def __hash__(self) -&gt; int:\n\"\"\"Returns the hash of the file path.\"\"\"\nreturn hash(self.file_path)\n</code></pre>"},{"location":"reference/pyiceberg/manifest/#pyiceberg.manifest.DataFile.__setattr__","title":"<code>__setattr__(name, value)</code>","text":"<p>Used for assigning a key/value to a DataFile.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/manifest.py</code> <pre><code>def __setattr__(self, name: str, value: Any) -&gt; None:\n\"\"\"Used for assigning a key/value to a DataFile.\"\"\"\n# The file_format is written as a string, so we need to cast it to the Enum\nif name == \"file_format\":\nvalue = FileFormat[value]\nsuper().__setattr__(name, value)\n</code></pre>"},{"location":"reference/pyiceberg/manifest/#pyiceberg.manifest.DataFileContent","title":"<code>DataFileContent</code>","text":"<p>         Bases: <code>int</code>, <code>Enum</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/manifest.py</code> <pre><code>class DataFileContent(int, Enum):\nDATA = 0\nPOSITION_DELETES = 1\nEQUALITY_DELETES = 2\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the DataFileContent class.\"\"\"\nreturn f\"DataFileContent.{self.name}\"\n</code></pre>"},{"location":"reference/pyiceberg/manifest/#pyiceberg.manifest.DataFileContent.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the DataFileContent class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/manifest.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the DataFileContent class.\"\"\"\nreturn f\"DataFileContent.{self.name}\"\n</code></pre>"},{"location":"reference/pyiceberg/manifest/#pyiceberg.manifest.FileFormat","title":"<code>FileFormat</code>","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/manifest.py</code> <pre><code>class FileFormat(str, Enum):\nAVRO = \"AVRO\"\nPARQUET = \"PARQUET\"\nORC = \"ORC\"\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the FileFormat class.\"\"\"\nreturn f\"FileFormat.{self.name}\"\n</code></pre>"},{"location":"reference/pyiceberg/manifest/#pyiceberg.manifest.FileFormat.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the FileFormat class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/manifest.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the FileFormat class.\"\"\"\nreturn f\"FileFormat.{self.name}\"\n</code></pre>"},{"location":"reference/pyiceberg/manifest/#pyiceberg.manifest.ManifestContent","title":"<code>ManifestContent</code>","text":"<p>         Bases: <code>int</code>, <code>Enum</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/manifest.py</code> <pre><code>class ManifestContent(int, Enum):\nDATA = 0\nDELETES = 1\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the ManifestContent class.\"\"\"\nreturn f\"ManifestContent.{self.name}\"\n</code></pre>"},{"location":"reference/pyiceberg/manifest/#pyiceberg.manifest.ManifestContent.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the ManifestContent class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/manifest.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the ManifestContent class.\"\"\"\nreturn f\"ManifestContent.{self.name}\"\n</code></pre>"},{"location":"reference/pyiceberg/manifest/#pyiceberg.manifest.ManifestEntryStatus","title":"<code>ManifestEntryStatus</code>","text":"<p>         Bases: <code>int</code>, <code>Enum</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/manifest.py</code> <pre><code>class ManifestEntryStatus(int, Enum):\nEXISTING = 0\nADDED = 1\nDELETED = 2\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the ManifestEntryStatus class.\"\"\"\nreturn f\"ManifestEntryStatus.{self.name}\"\n</code></pre>"},{"location":"reference/pyiceberg/manifest/#pyiceberg.manifest.ManifestEntryStatus.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the ManifestEntryStatus class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/manifest.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the ManifestEntryStatus class.\"\"\"\nreturn f\"ManifestEntryStatus.{self.name}\"\n</code></pre>"},{"location":"reference/pyiceberg/manifest/#pyiceberg.manifest.ManifestFile","title":"<code>ManifestFile</code>","text":"<p>         Bases: <code>Record</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/manifest.py</code> <pre><code>class ManifestFile(Record):\nmanifest_path: str\nmanifest_length: int\npartition_spec_id: int\ncontent: ManifestContent\nsequence_number: int\nmin_sequence_number: int\nadded_snapshot_id: int\nadded_files_count: Optional[int]\nexisting_files_count: Optional[int]\ndeleted_files_count: Optional[int]\nadded_rows_count: Optional[int]\nexisting_rows_count: Optional[int]\ndeleted_rows_count: Optional[int]\npartitions: Optional[List[PartitionFieldSummary]]\nkey_metadata: Optional[bytes]\ndef __init__(self, *data: Any, **named_data: Any) -&gt; None:\nsuper().__init__(*data, **{\"struct\": MANIFEST_FILE_SCHEMA.as_struct(), **named_data})\ndef has_added_files(self) -&gt; bool:\nreturn self.added_files_count is None or self.added_files_count &gt; 0\ndef has_existing_files(self) -&gt; bool:\nreturn self.existing_files_count is None or self.existing_files_count &gt; 0\ndef fetch_manifest_entry(self, io: FileIO, discard_deleted: bool = True) -&gt; List[ManifestEntry]:\n\"\"\"\n        Reads the manifest entries from the manifest file.\n        Args:\n            io: The FileIO to fetch the file.\n            discard_deleted: Filter on live entries.\n        Returns:\n            An Iterator of manifest entries.\n        \"\"\"\ninput_file = io.new_input(self.manifest_path)\nwith AvroFile[ManifestEntry](\ninput_file,\nMANIFEST_ENTRY_SCHEMA,\nread_types={-1: ManifestEntry, 2: DataFile},\nread_enums={0: ManifestEntryStatus, 101: FileFormat, 134: DataFileContent},\n) as reader:\nreturn [\n_inherit_sequence_number(entry, self)\nfor entry in reader\nif not discard_deleted or entry.status != ManifestEntryStatus.DELETED\n]\n</code></pre>"},{"location":"reference/pyiceberg/manifest/#pyiceberg.manifest.ManifestFile.fetch_manifest_entry","title":"<code>fetch_manifest_entry(io, discard_deleted=True)</code>","text":"<p>Reads the manifest entries from the manifest file.</p> <p>Parameters:</p> Name Type Description Default <code>io</code> <code>FileIO</code> <p>The FileIO to fetch the file.</p> required <code>discard_deleted</code> <code>bool</code> <p>Filter on live entries.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[ManifestEntry]</code> <p>An Iterator of manifest entries.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/manifest.py</code> <pre><code>def fetch_manifest_entry(self, io: FileIO, discard_deleted: bool = True) -&gt; List[ManifestEntry]:\n\"\"\"\n    Reads the manifest entries from the manifest file.\n    Args:\n        io: The FileIO to fetch the file.\n        discard_deleted: Filter on live entries.\n    Returns:\n        An Iterator of manifest entries.\n    \"\"\"\ninput_file = io.new_input(self.manifest_path)\nwith AvroFile[ManifestEntry](\ninput_file,\nMANIFEST_ENTRY_SCHEMA,\nread_types={-1: ManifestEntry, 2: DataFile},\nread_enums={0: ManifestEntryStatus, 101: FileFormat, 134: DataFileContent},\n) as reader:\nreturn [\n_inherit_sequence_number(entry, self)\nfor entry in reader\nif not discard_deleted or entry.status != ManifestEntryStatus.DELETED\n]\n</code></pre>"},{"location":"reference/pyiceberg/manifest/#pyiceberg.manifest.read_manifest_list","title":"<code>read_manifest_list(input_file)</code>","text":"<p>Reads the manifests from the manifest list.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>InputFile</code> <p>The input file where the stream can be read from.</p> required <p>Returns:</p> Type Description <code>Iterator[ManifestFile]</code> <p>An iterator of ManifestFiles that are part of the list.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/manifest.py</code> <pre><code>def read_manifest_list(input_file: InputFile) -&gt; Iterator[ManifestFile]:\n\"\"\"\n    Reads the manifests from the manifest list.\n    Args:\n        input_file: The input file where the stream can be read from.\n    Returns:\n        An iterator of ManifestFiles that are part of the list.\n    \"\"\"\nwith AvroFile[ManifestFile](\ninput_file,\nMANIFEST_FILE_SCHEMA,\nread_types={-1: ManifestFile, 508: PartitionFieldSummary},\nread_enums={517: ManifestContent},\n) as reader:\nyield from reader\n</code></pre>"},{"location":"reference/pyiceberg/partitioning/","title":"partitioning","text":""},{"location":"reference/pyiceberg/partitioning/#pyiceberg.partitioning.PartitionField","title":"<code>PartitionField</code>","text":"<p>         Bases: <code>IcebergBaseModel</code></p> <p>PartitionField represents how one partition value is derived from the source column via transformation.</p> <p>Attributes:</p> Name Type Description <code>source_id(int)</code> <p>The source column id of table's schema.</p> <code>field_id(int)</code> <p>The partition field id across all the table partition specs.</p> <code>transform(Transform)</code> <p>The transform used to produce partition values from source column.</p> <code>name(str)</code> <p>The name of this partition field.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/partitioning.py</code> <pre><code>class PartitionField(IcebergBaseModel):\n\"\"\"PartitionField represents how one partition value is derived from the source column via transformation.\n    Attributes:\n        source_id(int): The source column id of table's schema.\n        field_id(int): The partition field id across all the table partition specs.\n        transform(Transform): The transform used to produce partition values from source column.\n        name(str): The name of this partition field.\n    \"\"\"\nsource_id: int = Field(alias=\"source-id\")\nfield_id: int = Field(alias=\"field-id\")\ntransform: Transform[Any, Any] = Field()\nname: str = Field()\ndef __init__(\nself,\nsource_id: Optional[int] = None,\nfield_id: Optional[int] = None,\ntransform: Optional[Transform[Any, Any]] = None,\nname: Optional[str] = None,\n**data: Any,\n):\nif source_id is not None:\ndata[\"source-id\"] = source_id\nif field_id is not None:\ndata[\"field-id\"] = field_id\nif transform is not None:\ndata[\"transform\"] = transform\nif name is not None:\ndata[\"name\"] = name\nsuper().__init__(**data)\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the PartitionField class.\"\"\"\nreturn f\"{self.field_id}: {self.name}: {self.transform}({self.source_id})\"\n</code></pre>"},{"location":"reference/pyiceberg/partitioning/#pyiceberg.partitioning.PartitionField.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the PartitionField class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/partitioning.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the PartitionField class.\"\"\"\nreturn f\"{self.field_id}: {self.name}: {self.transform}({self.source_id})\"\n</code></pre>"},{"location":"reference/pyiceberg/partitioning/#pyiceberg.partitioning.PartitionSpec","title":"<code>PartitionSpec</code>","text":"<p>         Bases: <code>IcebergBaseModel</code></p> <p>PartitionSpec captures the transformation from table data to partition values.</p> <p>Attributes:</p> Name Type Description <code>spec_id(int)</code> <p>any change to PartitionSpec will produce a new specId.</p> <code>fields(Tuple[PartitionField)</code> <p>list of partition fields to produce partition values.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/partitioning.py</code> <pre><code>class PartitionSpec(IcebergBaseModel):\n\"\"\"\n    PartitionSpec captures the transformation from table data to partition values.\n    Attributes:\n        spec_id(int): any change to PartitionSpec will produce a new specId.\n        fields(Tuple[PartitionField): list of partition fields to produce partition values.\n    \"\"\"\nspec_id: int = Field(alias=\"spec-id\", default=INITIAL_PARTITION_SPEC_ID)\nfields: Tuple[PartitionField, ...] = Field(alias=\"fields\", default_factory=tuple)\ndef __init__(\nself,\n*fields: PartitionField,\n**data: Any,\n):\nif fields:\ndata[\"fields\"] = tuple(fields)\nsuper().__init__(**data)\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"\n        Produce a boolean to return True if two objects are considered equal.\n        Note:\n            Equality of PartitionSpec is determined by spec_id and partition fields only.\n        \"\"\"\nif not isinstance(other, PartitionSpec):\nreturn False\nreturn self.spec_id == other.spec_id and self.fields == other.fields\ndef __str__(self) -&gt; str:\n\"\"\"\n        Produce a human-readable string representation of PartitionSpec.\n        Note:\n            Only include list of partition fields in the PartitionSpec's string representation.\n        \"\"\"\nresult_str = \"[\"\nif self.fields:\nresult_str += \"\\n  \" + \"\\n  \".join([str(field) for field in self.fields]) + \"\\n\"\nresult_str += \"]\"\nreturn result_str\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the PartitionSpec class.\"\"\"\nfields = f\"{', '.join(repr(column) for column in self.fields)}, \" if self.fields else \"\"\nreturn f\"PartitionSpec({fields}spec_id={self.spec_id})\"\ndef is_unpartitioned(self) -&gt; bool:\nreturn not self.fields\n@property\ndef last_assigned_field_id(self) -&gt; int:\nif self.fields:\nreturn max(pf.field_id for pf in self.fields)\nreturn _PARTITION_DATA_ID_START\n@cached_property\ndef source_id_to_fields_map(self) -&gt; Dict[int, List[PartitionField]]:\nsource_id_to_fields_map: Dict[int, List[PartitionField]] = {}\nfor partition_field in self.fields:\nexisting = source_id_to_fields_map.get(partition_field.source_id, [])\nexisting.append(partition_field)\nsource_id_to_fields_map[partition_field.source_id] = existing\nreturn source_id_to_fields_map\ndef fields_by_source_id(self, field_id: int) -&gt; List[PartitionField]:\nreturn self.source_id_to_fields_map.get(field_id, [])\ndef compatible_with(self, other: \"PartitionSpec\") -&gt; bool:\n\"\"\"Produce a boolean to return True if two PartitionSpec are considered compatible.\"\"\"\nif self == other:\nreturn True\nif len(self.fields) != len(other.fields):\nreturn False\nreturn all(\nthis_field.source_id == that_field.source_id\nand this_field.transform == that_field.transform\nand this_field.name == that_field.name\nfor this_field, that_field in zip(self.fields, other.fields)\n)\ndef partition_type(self, schema: Schema) -&gt; StructType:\n\"\"\"Produces a struct of the PartitionSpec.\n        The partition fields should be optional:\n        - All partition transforms are required to produce null if the input value is null, so it can\n          happen when the source column is optional.\n        - Partition fields may be added later, in which case not all files would have the result field,\n          and it may be null.\n        There is a case where we can guarantee that a partition field in the first and only partition spec\n        that uses a required source column will never be null, but it doesn't seem worth tracking this case.\n        :param schema: The schema to bind to.\n        :return: A StructType that represents the PartitionSpec, with a NestedField for each PartitionField.\n        \"\"\"\nnested_fields = []\nfor field in self.fields:\nsource_type = schema.find_type(field.source_id)\nresult_type = field.transform.result_type(source_type)\nnested_fields.append(NestedField(field.field_id, field.name, result_type, required=False))\nreturn StructType(*nested_fields)\n</code></pre>"},{"location":"reference/pyiceberg/partitioning/#pyiceberg.partitioning.PartitionSpec.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Produce a boolean to return True if two objects are considered equal.</p> Note <p>Equality of PartitionSpec is determined by spec_id and partition fields only.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/partitioning.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"\n    Produce a boolean to return True if two objects are considered equal.\n    Note:\n        Equality of PartitionSpec is determined by spec_id and partition fields only.\n    \"\"\"\nif not isinstance(other, PartitionSpec):\nreturn False\nreturn self.spec_id == other.spec_id and self.fields == other.fields\n</code></pre>"},{"location":"reference/pyiceberg/partitioning/#pyiceberg.partitioning.PartitionSpec.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the PartitionSpec class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/partitioning.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the PartitionSpec class.\"\"\"\nfields = f\"{', '.join(repr(column) for column in self.fields)}, \" if self.fields else \"\"\nreturn f\"PartitionSpec({fields}spec_id={self.spec_id})\"\n</code></pre>"},{"location":"reference/pyiceberg/partitioning/#pyiceberg.partitioning.PartitionSpec.__str__","title":"<code>__str__()</code>","text":"<p>Produce a human-readable string representation of PartitionSpec.</p> Note <p>Only include list of partition fields in the PartitionSpec's string representation.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/partitioning.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"\n    Produce a human-readable string representation of PartitionSpec.\n    Note:\n        Only include list of partition fields in the PartitionSpec's string representation.\n    \"\"\"\nresult_str = \"[\"\nif self.fields:\nresult_str += \"\\n  \" + \"\\n  \".join([str(field) for field in self.fields]) + \"\\n\"\nresult_str += \"]\"\nreturn result_str\n</code></pre>"},{"location":"reference/pyiceberg/partitioning/#pyiceberg.partitioning.PartitionSpec.compatible_with","title":"<code>compatible_with(other)</code>","text":"<p>Produce a boolean to return True if two PartitionSpec are considered compatible.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/partitioning.py</code> <pre><code>def compatible_with(self, other: \"PartitionSpec\") -&gt; bool:\n\"\"\"Produce a boolean to return True if two PartitionSpec are considered compatible.\"\"\"\nif self == other:\nreturn True\nif len(self.fields) != len(other.fields):\nreturn False\nreturn all(\nthis_field.source_id == that_field.source_id\nand this_field.transform == that_field.transform\nand this_field.name == that_field.name\nfor this_field, that_field in zip(self.fields, other.fields)\n)\n</code></pre>"},{"location":"reference/pyiceberg/partitioning/#pyiceberg.partitioning.PartitionSpec.partition_type","title":"<code>partition_type(schema)</code>","text":"<p>Produces a struct of the PartitionSpec.</p> <p>The partition fields should be optional:</p> <ul> <li>All partition transforms are required to produce null if the input value is null, so it can   happen when the source column is optional.</li> <li>Partition fields may be added later, in which case not all files would have the result field,   and it may be null.</li> </ul> <p>There is a case where we can guarantee that a partition field in the first and only partition spec that uses a required source column will never be null, but it doesn't seem worth tracking this case.</p> <p>:param schema: The schema to bind to. :return: A StructType that represents the PartitionSpec, with a NestedField for each PartitionField.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/partitioning.py</code> <pre><code>def partition_type(self, schema: Schema) -&gt; StructType:\n\"\"\"Produces a struct of the PartitionSpec.\n    The partition fields should be optional:\n    - All partition transforms are required to produce null if the input value is null, so it can\n      happen when the source column is optional.\n    - Partition fields may be added later, in which case not all files would have the result field,\n      and it may be null.\n    There is a case where we can guarantee that a partition field in the first and only partition spec\n    that uses a required source column will never be null, but it doesn't seem worth tracking this case.\n    :param schema: The schema to bind to.\n    :return: A StructType that represents the PartitionSpec, with a NestedField for each PartitionField.\n    \"\"\"\nnested_fields = []\nfor field in self.fields:\nsource_type = schema.find_type(field.source_id)\nresult_type = field.transform.result_type(source_type)\nnested_fields.append(NestedField(field.field_id, field.name, result_type, required=False))\nreturn StructType(*nested_fields)\n</code></pre>"},{"location":"reference/pyiceberg/schema/","title":"schema","text":""},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Accessor","title":"<code>Accessor</code>  <code>dataclass</code>","text":"<p>An accessor for a specific position in a container that implements the StructProtocol.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@dataclass(init=True, eq=True, frozen=True)\nclass Accessor:\n\"\"\"An accessor for a specific position in a container that implements the StructProtocol.\"\"\"\nposition: int\ninner: Optional[\"Accessor\"] = None\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the Accessor class.\"\"\"\nreturn f\"Accessor(position={self.position},inner={self.inner})\"\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Accessor class.\"\"\"\nreturn self.__str__()\ndef get(self, container: StructProtocol) -&gt; Any:\n\"\"\"Returns the value at self.position in `container`.\n        Args:\n            container (StructProtocol): A container to access at position `self.position`.\n        Returns:\n            Any: The value at position `self.position` in the container.\n        \"\"\"\npos = self.position\nval = container[pos]\ninner = self\nwhile inner.inner:\ninner = inner.inner\nval = val[inner.position]\nreturn val\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Accessor.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the Accessor class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Accessor class.\"\"\"\nreturn self.__str__()\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Accessor.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the Accessor class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the Accessor class.\"\"\"\nreturn f\"Accessor(position={self.position},inner={self.inner})\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Accessor.get","title":"<code>get(container)</code>","text":"<p>Returns the value at self.position in <code>container</code>.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>StructProtocol</code> <p>A container to access at position <code>self.position</code>.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value at position <code>self.position</code> in the container.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def get(self, container: StructProtocol) -&gt; Any:\n\"\"\"Returns the value at self.position in `container`.\n    Args:\n        container (StructProtocol): A container to access at position `self.position`.\n    Returns:\n        Any: The value at position `self.position` in the container.\n    \"\"\"\npos = self.position\nval = container[pos]\ninner = self\nwhile inner.inner:\ninner = inner.inner\nval = val[inner.position]\nreturn val\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PartnerAccessor","title":"<code>PartnerAccessor</code>","text":"<p>         Bases: <code>Generic[P]</code>, <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>class PartnerAccessor(Generic[P], ABC):\n@abstractmethod\ndef schema_partner(self, partner: Optional[P]) -&gt; Optional[P]:\n\"\"\"Returns the equivalent of the schema as a struct.\"\"\"\n@abstractmethod\ndef field_partner(self, partner_struct: Optional[P], field_id: int, field_name: str) -&gt; Optional[P]:\n\"\"\"Returns the equivalent struct field by name or id in the partner struct.\"\"\"\n@abstractmethod\ndef list_element_partner(self, partner_list: Optional[P]) -&gt; Optional[P]:\n\"\"\"Returns the equivalent list element in the partner list.\"\"\"\n@abstractmethod\ndef map_key_partner(self, partner_map: Optional[P]) -&gt; Optional[P]:\n\"\"\"Returns the equivalent map key in the partner map.\"\"\"\n@abstractmethod\ndef map_value_partner(self, partner_map: Optional[P]) -&gt; Optional[P]:\n\"\"\"Returns the equivalent map value in the partner map.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PartnerAccessor.field_partner","title":"<code>field_partner(partner_struct, field_id, field_name)</code>  <code>abstractmethod</code>","text":"<p>Returns the equivalent struct field by name or id in the partner struct.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef field_partner(self, partner_struct: Optional[P], field_id: int, field_name: str) -&gt; Optional[P]:\n\"\"\"Returns the equivalent struct field by name or id in the partner struct.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PartnerAccessor.list_element_partner","title":"<code>list_element_partner(partner_list)</code>  <code>abstractmethod</code>","text":"<p>Returns the equivalent list element in the partner list.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef list_element_partner(self, partner_list: Optional[P]) -&gt; Optional[P]:\n\"\"\"Returns the equivalent list element in the partner list.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PartnerAccessor.map_key_partner","title":"<code>map_key_partner(partner_map)</code>  <code>abstractmethod</code>","text":"<p>Returns the equivalent map key in the partner map.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef map_key_partner(self, partner_map: Optional[P]) -&gt; Optional[P]:\n\"\"\"Returns the equivalent map key in the partner map.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PartnerAccessor.map_value_partner","title":"<code>map_value_partner(partner_map)</code>  <code>abstractmethod</code>","text":"<p>Returns the equivalent map value in the partner map.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef map_value_partner(self, partner_map: Optional[P]) -&gt; Optional[P]:\n\"\"\"Returns the equivalent map value in the partner map.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PartnerAccessor.schema_partner","title":"<code>schema_partner(partner)</code>  <code>abstractmethod</code>","text":"<p>Returns the equivalent of the schema as a struct.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef schema_partner(self, partner: Optional[P]) -&gt; Optional[P]:\n\"\"\"Returns the equivalent of the schema as a struct.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PreOrderSchemaVisitor","title":"<code>PreOrderSchemaVisitor</code>","text":"<p>         Bases: <code>Generic[T]</code>, <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>class PreOrderSchemaVisitor(Generic[T], ABC):\n@abstractmethod\ndef schema(self, schema: Schema, struct_result: Callable[[], T]) -&gt; T:\n\"\"\"Visit a Schema.\"\"\"\n@abstractmethod\ndef struct(self, struct: StructType, field_results: List[Callable[[], T]]) -&gt; T:\n\"\"\"Visit a StructType.\"\"\"\n@abstractmethod\ndef field(self, field: NestedField, field_result: Callable[[], T]) -&gt; T:\n\"\"\"Visit a NestedField.\"\"\"\n@abstractmethod\ndef list(self, list_type: ListType, element_result: Callable[[], T]) -&gt; T:\n\"\"\"Visit a ListType.\"\"\"\n@abstractmethod\ndef map(self, map_type: MapType, key_result: Callable[[], T], value_result: Callable[[], T]) -&gt; T:\n\"\"\"Visit a MapType.\"\"\"\n@abstractmethod\ndef primitive(self, primitive: PrimitiveType) -&gt; T:\n\"\"\"Visit a PrimitiveType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PreOrderSchemaVisitor.field","title":"<code>field(field, field_result)</code>  <code>abstractmethod</code>","text":"<p>Visit a NestedField.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef field(self, field: NestedField, field_result: Callable[[], T]) -&gt; T:\n\"\"\"Visit a NestedField.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PreOrderSchemaVisitor.list","title":"<code>list(list_type, element_result)</code>  <code>abstractmethod</code>","text":"<p>Visit a ListType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef list(self, list_type: ListType, element_result: Callable[[], T]) -&gt; T:\n\"\"\"Visit a ListType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PreOrderSchemaVisitor.map","title":"<code>map(map_type, key_result, value_result)</code>  <code>abstractmethod</code>","text":"<p>Visit a MapType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef map(self, map_type: MapType, key_result: Callable[[], T], value_result: Callable[[], T]) -&gt; T:\n\"\"\"Visit a MapType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PreOrderSchemaVisitor.primitive","title":"<code>primitive(primitive)</code>  <code>abstractmethod</code>","text":"<p>Visit a PrimitiveType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef primitive(self, primitive: PrimitiveType) -&gt; T:\n\"\"\"Visit a PrimitiveType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PreOrderSchemaVisitor.schema","title":"<code>schema(schema, struct_result)</code>  <code>abstractmethod</code>","text":"<p>Visit a Schema.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef schema(self, schema: Schema, struct_result: Callable[[], T]) -&gt; T:\n\"\"\"Visit a Schema.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PreOrderSchemaVisitor.struct","title":"<code>struct(struct, field_results)</code>  <code>abstractmethod</code>","text":"<p>Visit a StructType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef struct(self, struct: StructType, field_results: List[Callable[[], T]]) -&gt; T:\n\"\"\"Visit a StructType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PrimitiveWithPartnerVisitor","title":"<code>PrimitiveWithPartnerVisitor</code>","text":"<p>         Bases: <code>SchemaWithPartnerVisitor[P, T]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>class PrimitiveWithPartnerVisitor(SchemaWithPartnerVisitor[P, T]):\ndef primitive(self, primitive: PrimitiveType, primitive_partner: Optional[P]) -&gt; T:\n\"\"\"Visit a PrimitiveType.\"\"\"\nif isinstance(primitive, BooleanType):\nreturn self.visit_boolean(primitive, primitive_partner)\nelif isinstance(primitive, IntegerType):\nreturn self.visit_integer(primitive, primitive_partner)\nelif isinstance(primitive, LongType):\nreturn self.visit_long(primitive, primitive_partner)\nelif isinstance(primitive, FloatType):\nreturn self.visit_float(primitive, primitive_partner)\nelif isinstance(primitive, DoubleType):\nreturn self.visit_double(primitive, primitive_partner)\nelif isinstance(primitive, DecimalType):\nreturn self.visit_decimal(primitive, primitive_partner)\nelif isinstance(primitive, DateType):\nreturn self.visit_date(primitive, primitive_partner)\nelif isinstance(primitive, TimeType):\nreturn self.visit_time(primitive, primitive_partner)\nelif isinstance(primitive, TimestampType):\nreturn self.visit_timestamp(primitive, primitive_partner)\nelif isinstance(primitive, TimestamptzType):\nreturn self.visit_timestampz(primitive, primitive_partner)\nelif isinstance(primitive, StringType):\nreturn self.visit_string(primitive, primitive_partner)\nelif isinstance(primitive, UUIDType):\nreturn self.visit_uuid(primitive, primitive_partner)\nelif isinstance(primitive, FixedType):\nreturn self.visit_fixed(primitive, primitive_partner)\nelif isinstance(primitive, BinaryType):\nreturn self.visit_binary(primitive, primitive_partner)\nelse:\nraise ValueError(f\"Unknown type: {primitive}\")\n@abstractmethod\ndef visit_boolean(self, boolean_type: BooleanType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a BooleanType.\"\"\"\n@abstractmethod\ndef visit_integer(self, integer_type: IntegerType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a IntegerType.\"\"\"\n@abstractmethod\ndef visit_long(self, long_type: LongType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a LongType.\"\"\"\n@abstractmethod\ndef visit_float(self, float_type: FloatType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a FloatType.\"\"\"\n@abstractmethod\ndef visit_double(self, double_type: DoubleType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a DoubleType.\"\"\"\n@abstractmethod\ndef visit_decimal(self, decimal_type: DecimalType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a DecimalType.\"\"\"\n@abstractmethod\ndef visit_date(self, date_type: DateType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a DecimalType.\"\"\"\n@abstractmethod\ndef visit_time(self, time_type: TimeType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a DecimalType.\"\"\"\n@abstractmethod\ndef visit_timestamp(self, timestamp_type: TimestampType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a TimestampType.\"\"\"\n@abstractmethod\ndef visit_timestampz(self, timestamptz_type: TimestamptzType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a TimestamptzType.\"\"\"\n@abstractmethod\ndef visit_string(self, string_type: StringType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a StringType.\"\"\"\n@abstractmethod\ndef visit_uuid(self, uuid_type: UUIDType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a UUIDType.\"\"\"\n@abstractmethod\ndef visit_fixed(self, fixed_type: FixedType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a FixedType.\"\"\"\n@abstractmethod\ndef visit_binary(self, binary_type: BinaryType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a BinaryType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PrimitiveWithPartnerVisitor.primitive","title":"<code>primitive(primitive, primitive_partner)</code>","text":"<p>Visit a PrimitiveType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def primitive(self, primitive: PrimitiveType, primitive_partner: Optional[P]) -&gt; T:\n\"\"\"Visit a PrimitiveType.\"\"\"\nif isinstance(primitive, BooleanType):\nreturn self.visit_boolean(primitive, primitive_partner)\nelif isinstance(primitive, IntegerType):\nreturn self.visit_integer(primitive, primitive_partner)\nelif isinstance(primitive, LongType):\nreturn self.visit_long(primitive, primitive_partner)\nelif isinstance(primitive, FloatType):\nreturn self.visit_float(primitive, primitive_partner)\nelif isinstance(primitive, DoubleType):\nreturn self.visit_double(primitive, primitive_partner)\nelif isinstance(primitive, DecimalType):\nreturn self.visit_decimal(primitive, primitive_partner)\nelif isinstance(primitive, DateType):\nreturn self.visit_date(primitive, primitive_partner)\nelif isinstance(primitive, TimeType):\nreturn self.visit_time(primitive, primitive_partner)\nelif isinstance(primitive, TimestampType):\nreturn self.visit_timestamp(primitive, primitive_partner)\nelif isinstance(primitive, TimestamptzType):\nreturn self.visit_timestampz(primitive, primitive_partner)\nelif isinstance(primitive, StringType):\nreturn self.visit_string(primitive, primitive_partner)\nelif isinstance(primitive, UUIDType):\nreturn self.visit_uuid(primitive, primitive_partner)\nelif isinstance(primitive, FixedType):\nreturn self.visit_fixed(primitive, primitive_partner)\nelif isinstance(primitive, BinaryType):\nreturn self.visit_binary(primitive, primitive_partner)\nelse:\nraise ValueError(f\"Unknown type: {primitive}\")\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PrimitiveWithPartnerVisitor.visit_binary","title":"<code>visit_binary(binary_type, partner)</code>  <code>abstractmethod</code>","text":"<p>Visit a BinaryType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_binary(self, binary_type: BinaryType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a BinaryType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PrimitiveWithPartnerVisitor.visit_boolean","title":"<code>visit_boolean(boolean_type, partner)</code>  <code>abstractmethod</code>","text":"<p>Visit a BooleanType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_boolean(self, boolean_type: BooleanType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a BooleanType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PrimitiveWithPartnerVisitor.visit_date","title":"<code>visit_date(date_type, partner)</code>  <code>abstractmethod</code>","text":"<p>Visit a DecimalType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_date(self, date_type: DateType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a DecimalType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PrimitiveWithPartnerVisitor.visit_decimal","title":"<code>visit_decimal(decimal_type, partner)</code>  <code>abstractmethod</code>","text":"<p>Visit a DecimalType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_decimal(self, decimal_type: DecimalType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a DecimalType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PrimitiveWithPartnerVisitor.visit_double","title":"<code>visit_double(double_type, partner)</code>  <code>abstractmethod</code>","text":"<p>Visit a DoubleType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_double(self, double_type: DoubleType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a DoubleType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PrimitiveWithPartnerVisitor.visit_fixed","title":"<code>visit_fixed(fixed_type, partner)</code>  <code>abstractmethod</code>","text":"<p>Visit a FixedType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_fixed(self, fixed_type: FixedType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a FixedType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PrimitiveWithPartnerVisitor.visit_float","title":"<code>visit_float(float_type, partner)</code>  <code>abstractmethod</code>","text":"<p>Visit a FloatType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_float(self, float_type: FloatType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a FloatType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PrimitiveWithPartnerVisitor.visit_integer","title":"<code>visit_integer(integer_type, partner)</code>  <code>abstractmethod</code>","text":"<p>Visit a IntegerType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_integer(self, integer_type: IntegerType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a IntegerType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PrimitiveWithPartnerVisitor.visit_long","title":"<code>visit_long(long_type, partner)</code>  <code>abstractmethod</code>","text":"<p>Visit a LongType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_long(self, long_type: LongType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a LongType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PrimitiveWithPartnerVisitor.visit_string","title":"<code>visit_string(string_type, partner)</code>  <code>abstractmethod</code>","text":"<p>Visit a StringType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_string(self, string_type: StringType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a StringType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PrimitiveWithPartnerVisitor.visit_time","title":"<code>visit_time(time_type, partner)</code>  <code>abstractmethod</code>","text":"<p>Visit a DecimalType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_time(self, time_type: TimeType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a DecimalType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PrimitiveWithPartnerVisitor.visit_timestamp","title":"<code>visit_timestamp(timestamp_type, partner)</code>  <code>abstractmethod</code>","text":"<p>Visit a TimestampType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_timestamp(self, timestamp_type: TimestampType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a TimestampType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PrimitiveWithPartnerVisitor.visit_timestampz","title":"<code>visit_timestampz(timestamptz_type, partner)</code>  <code>abstractmethod</code>","text":"<p>Visit a TimestamptzType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_timestampz(self, timestamptz_type: TimestamptzType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a TimestamptzType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.PrimitiveWithPartnerVisitor.visit_uuid","title":"<code>visit_uuid(uuid_type, partner)</code>  <code>abstractmethod</code>","text":"<p>Visit a UUIDType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_uuid(self, uuid_type: UUIDType, partner: Optional[P]) -&gt; T:\n\"\"\"Visit a UUIDType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Schema","title":"<code>Schema</code>","text":"<p>         Bases: <code>IcebergBaseModel</code></p> <p>A table Schema.</p> Example <p>from pyiceberg import schema from pyiceberg import types</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>class Schema(IcebergBaseModel):\n\"\"\"A table Schema.\n    Example:\n        &gt;&gt;&gt; from pyiceberg import schema\n        &gt;&gt;&gt; from pyiceberg import types\n    \"\"\"\ntype: Literal[\"struct\"] = \"struct\"\nfields: Tuple[NestedField, ...] = Field(default_factory=tuple)\nschema_id: int = Field(alias=\"schema-id\", default=INITIAL_SCHEMA_ID)\nidentifier_field_ids: List[int] = Field(alias=\"identifier-field-ids\", default_factory=list)\n_name_to_id: Dict[str, int] = PrivateAttr()\ndef __init__(self, *fields: NestedField, **data: Any):\nif fields:\ndata[\"fields\"] = fields\nsuper().__init__(**data)\nself._name_to_id = index_by_name(self)\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the Schema class.\"\"\"\nreturn \"table {\\n\" + \"\\n\".join([\"  \" + str(field) for field in self.columns]) + \"\\n}\"\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Schema class.\"\"\"\nreturn f\"Schema({', '.join(repr(column) for column in self.columns)}, schema_id={self.schema_id}, identifier_field_ids={self.identifier_field_ids})\"\ndef __len__(self) -&gt; int:\n\"\"\"Returns the length of an instance of the Literal class.\"\"\"\nreturn len(self.fields)\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the Schema class.\"\"\"\nif not other:\nreturn False\nif not isinstance(other, Schema):\nreturn False\nif len(self.columns) != len(other.columns):\nreturn False\nidentifier_field_ids_is_equal = self.identifier_field_ids == other.identifier_field_ids\nschema_is_equal = all(lhs == rhs for lhs, rhs in zip(self.columns, other.columns))\nreturn identifier_field_ids_is_equal and schema_is_equal\n@property\ndef columns(self) -&gt; Tuple[NestedField, ...]:\n\"\"\"A tuple of the top-level fields.\"\"\"\nreturn self.fields\n@cached_property\ndef _lazy_id_to_field(self) -&gt; Dict[int, NestedField]:\n\"\"\"Returns an index of field ID to NestedField instance.\n        This is calculated once when called for the first time. Subsequent calls to this method will use a cached index.\n        \"\"\"\nreturn index_by_id(self)\n@cached_property\ndef _lazy_name_to_id_lower(self) -&gt; Dict[str, int]:\n\"\"\"Returns an index of lower-case field names to field IDs.\n        This is calculated once when called for the first time. Subsequent calls to this method will use a cached index.\n        \"\"\"\nreturn {name.lower(): field_id for name, field_id in self._name_to_id.items()}\n@cached_property\ndef _lazy_id_to_name(self) -&gt; Dict[int, str]:\n\"\"\"Returns an index of field ID to full name.\n        This is calculated once when called for the first time. Subsequent calls to this method will use a cached index.\n        \"\"\"\nreturn index_name_by_id(self)\n@cached_property\ndef _lazy_id_to_accessor(self) -&gt; Dict[int, \"Accessor\"]:\n\"\"\"Returns an index of field ID to accessor.\n        This is calculated once when called for the first time. Subsequent calls to this method will use a cached index.\n        \"\"\"\nreturn build_position_accessors(self)\ndef as_struct(self) -&gt; StructType:\n\"\"\"Returns the schema as a struct.\"\"\"\nreturn StructType(*self.fields)\ndef find_field(self, name_or_id: Union[str, int], case_sensitive: bool = True) -&gt; NestedField:\n\"\"\"Find a field using a field name or field ID.\n        Args:\n            name_or_id (Union[str, int]): Either a field name or a field ID.\n            case_sensitive (bool, optional): Whether to perform a case-sensitive lookup using a field name. Defaults to True.\n        Raises:\n            ValueError: When the value cannot be found.\n        Returns:\n            NestedField: The matched NestedField.\n        \"\"\"\nif isinstance(name_or_id, int):\nif name_or_id not in self._lazy_id_to_field:\nraise ValueError(f\"Could not find field with id: {name_or_id}\")\nreturn self._lazy_id_to_field[name_or_id]\nif case_sensitive:\nfield_id = self._name_to_id.get(name_or_id)\nelse:\nfield_id = self._lazy_name_to_id_lower.get(name_or_id.lower())\nif field_id is None:\nraise ValueError(f\"Could not find field with name {name_or_id}, case_sensitive={case_sensitive}\")\nreturn self._lazy_id_to_field[field_id]\ndef find_type(self, name_or_id: Union[str, int], case_sensitive: bool = True) -&gt; IcebergType:\n\"\"\"Find a field type using a field name or field ID.\n        Args:\n            name_or_id (Union[str, int]): Either a field name or a field ID.\n            case_sensitive (bool, optional): Whether to perform a case-sensitive lookup using a field name. Defaults to True.\n        Returns:\n            NestedField: The type of the matched NestedField.\n        \"\"\"\nfield = self.find_field(name_or_id=name_or_id, case_sensitive=case_sensitive)\nif not field:\nraise ValueError(f\"Could not find field with name or id {name_or_id}, case_sensitive={case_sensitive}\")\nreturn field.field_type\n@property\ndef highest_field_id(self) -&gt; int:\nreturn visit(self.as_struct(), _FindLastFieldId())\ndef find_column_name(self, column_id: int) -&gt; Optional[str]:\n\"\"\"Find a column name given a column ID.\n        Args:\n            column_id (int): The ID of the column.\n        Returns:\n            str: The column name (or None if the column ID cannot be found).\n        \"\"\"\nreturn self._lazy_id_to_name.get(column_id)\n@property\ndef column_names(self) -&gt; List[str]:\n\"\"\"\n        Returns a list of all the column names, including nested fields.\n        Excludes short names.\n        Returns:\n            List[str]: The column names.\n        \"\"\"\nreturn list(self._lazy_id_to_name.values())\ndef accessor_for_field(self, field_id: int) -&gt; \"Accessor\":\n\"\"\"Find a schema position accessor given a field ID.\n        Args:\n            field_id (int): The ID of the field.\n        Raises:\n            ValueError: When the value cannot be found.\n        Returns:\n            Accessor: An accessor for the given field ID.\n        \"\"\"\nif field_id not in self._lazy_id_to_accessor:\nraise ValueError(f\"Could not find accessor for field with id: {field_id}\")\nreturn self._lazy_id_to_accessor[field_id]\ndef select(self, *names: str, case_sensitive: bool = True) -&gt; \"Schema\":\n\"\"\"Return a new schema instance pruned to a subset of columns.\n        Args:\n            names (List[str]): A list of column names.\n            case_sensitive (bool, optional): Whether to perform a case-sensitive lookup for each column name. Defaults to True.\n        Returns:\n            Schema: A new schema with pruned columns.\n        Raises:\n            ValueError: If a column is selected that doesn't exist.\n        \"\"\"\ntry:\nif case_sensitive:\nids = {self._name_to_id[name] for name in names}\nelse:\nids = {self._lazy_name_to_id_lower[name.lower()] for name in names}\nexcept KeyError as e:\nraise ValueError(f\"Could not find column: {e}\") from e\nreturn prune_columns(self, ids)\n@property\ndef field_ids(self) -&gt; Set[int]:\n\"\"\"Returns the IDs of the current schema.\"\"\"\nreturn set(self._name_to_id.values())\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Schema.column_names","title":"<code>column_names: List[str]</code>  <code>property</code>","text":"<p>Returns a list of all the column names, including nested fields.</p> <p>Excludes short names.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: The column names.</p>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Schema.columns","title":"<code>columns: Tuple[NestedField, ...]</code>  <code>property</code>","text":"<p>A tuple of the top-level fields.</p>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Schema.field_ids","title":"<code>field_ids: Set[int]</code>  <code>property</code>","text":"<p>Returns the IDs of the current schema.</p>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Schema.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the Schema class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the Schema class.\"\"\"\nif not other:\nreturn False\nif not isinstance(other, Schema):\nreturn False\nif len(self.columns) != len(other.columns):\nreturn False\nidentifier_field_ids_is_equal = self.identifier_field_ids == other.identifier_field_ids\nschema_is_equal = all(lhs == rhs for lhs, rhs in zip(self.columns, other.columns))\nreturn identifier_field_ids_is_equal and schema_is_equal\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Schema.__len__","title":"<code>__len__()</code>","text":"<p>Returns the length of an instance of the Literal class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Returns the length of an instance of the Literal class.\"\"\"\nreturn len(self.fields)\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Schema.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the Schema class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Schema class.\"\"\"\nreturn f\"Schema({', '.join(repr(column) for column in self.columns)}, schema_id={self.schema_id}, identifier_field_ids={self.identifier_field_ids})\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Schema.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the Schema class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the Schema class.\"\"\"\nreturn \"table {\\n\" + \"\\n\".join([\"  \" + str(field) for field in self.columns]) + \"\\n}\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Schema.accessor_for_field","title":"<code>accessor_for_field(field_id)</code>","text":"<p>Find a schema position accessor given a field ID.</p> <p>Parameters:</p> Name Type Description Default <code>field_id</code> <code>int</code> <p>The ID of the field.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>When the value cannot be found.</p> <p>Returns:</p> Name Type Description <code>Accessor</code> <code>Accessor</code> <p>An accessor for the given field ID.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def accessor_for_field(self, field_id: int) -&gt; \"Accessor\":\n\"\"\"Find a schema position accessor given a field ID.\n    Args:\n        field_id (int): The ID of the field.\n    Raises:\n        ValueError: When the value cannot be found.\n    Returns:\n        Accessor: An accessor for the given field ID.\n    \"\"\"\nif field_id not in self._lazy_id_to_accessor:\nraise ValueError(f\"Could not find accessor for field with id: {field_id}\")\nreturn self._lazy_id_to_accessor[field_id]\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Schema.as_struct","title":"<code>as_struct()</code>","text":"<p>Returns the schema as a struct.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def as_struct(self) -&gt; StructType:\n\"\"\"Returns the schema as a struct.\"\"\"\nreturn StructType(*self.fields)\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Schema.find_column_name","title":"<code>find_column_name(column_id)</code>","text":"<p>Find a column name given a column ID.</p> <p>Parameters:</p> Name Type Description Default <code>column_id</code> <code>int</code> <p>The ID of the column.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>The column name (or None if the column ID cannot be found).</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def find_column_name(self, column_id: int) -&gt; Optional[str]:\n\"\"\"Find a column name given a column ID.\n    Args:\n        column_id (int): The ID of the column.\n    Returns:\n        str: The column name (or None if the column ID cannot be found).\n    \"\"\"\nreturn self._lazy_id_to_name.get(column_id)\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Schema.find_field","title":"<code>find_field(name_or_id, case_sensitive=True)</code>","text":"<p>Find a field using a field name or field ID.</p> <p>Parameters:</p> Name Type Description Default <code>name_or_id</code> <code>Union[str, int]</code> <p>Either a field name or a field ID.</p> required <code>case_sensitive</code> <code>bool</code> <p>Whether to perform a case-sensitive lookup using a field name. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>When the value cannot be found.</p> <p>Returns:</p> Name Type Description <code>NestedField</code> <code>NestedField</code> <p>The matched NestedField.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def find_field(self, name_or_id: Union[str, int], case_sensitive: bool = True) -&gt; NestedField:\n\"\"\"Find a field using a field name or field ID.\n    Args:\n        name_or_id (Union[str, int]): Either a field name or a field ID.\n        case_sensitive (bool, optional): Whether to perform a case-sensitive lookup using a field name. Defaults to True.\n    Raises:\n        ValueError: When the value cannot be found.\n    Returns:\n        NestedField: The matched NestedField.\n    \"\"\"\nif isinstance(name_or_id, int):\nif name_or_id not in self._lazy_id_to_field:\nraise ValueError(f\"Could not find field with id: {name_or_id}\")\nreturn self._lazy_id_to_field[name_or_id]\nif case_sensitive:\nfield_id = self._name_to_id.get(name_or_id)\nelse:\nfield_id = self._lazy_name_to_id_lower.get(name_or_id.lower())\nif field_id is None:\nraise ValueError(f\"Could not find field with name {name_or_id}, case_sensitive={case_sensitive}\")\nreturn self._lazy_id_to_field[field_id]\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Schema.find_type","title":"<code>find_type(name_or_id, case_sensitive=True)</code>","text":"<p>Find a field type using a field name or field ID.</p> <p>Parameters:</p> Name Type Description Default <code>name_or_id</code> <code>Union[str, int]</code> <p>Either a field name or a field ID.</p> required <code>case_sensitive</code> <code>bool</code> <p>Whether to perform a case-sensitive lookup using a field name. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>NestedField</code> <code>IcebergType</code> <p>The type of the matched NestedField.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def find_type(self, name_or_id: Union[str, int], case_sensitive: bool = True) -&gt; IcebergType:\n\"\"\"Find a field type using a field name or field ID.\n    Args:\n        name_or_id (Union[str, int]): Either a field name or a field ID.\n        case_sensitive (bool, optional): Whether to perform a case-sensitive lookup using a field name. Defaults to True.\n    Returns:\n        NestedField: The type of the matched NestedField.\n    \"\"\"\nfield = self.find_field(name_or_id=name_or_id, case_sensitive=case_sensitive)\nif not field:\nraise ValueError(f\"Could not find field with name or id {name_or_id}, case_sensitive={case_sensitive}\")\nreturn field.field_type\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.Schema.select","title":"<code>select(*names, case_sensitive=True)</code>","text":"<p>Return a new schema instance pruned to a subset of columns.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>List[str]</code> <p>A list of column names.</p> <code>()</code> <code>case_sensitive</code> <code>bool</code> <p>Whether to perform a case-sensitive lookup for each column name. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Schema</code> <code>Schema</code> <p>A new schema with pruned columns.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a column is selected that doesn't exist.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def select(self, *names: str, case_sensitive: bool = True) -&gt; \"Schema\":\n\"\"\"Return a new schema instance pruned to a subset of columns.\n    Args:\n        names (List[str]): A list of column names.\n        case_sensitive (bool, optional): Whether to perform a case-sensitive lookup for each column name. Defaults to True.\n    Returns:\n        Schema: A new schema with pruned columns.\n    Raises:\n        ValueError: If a column is selected that doesn't exist.\n    \"\"\"\ntry:\nif case_sensitive:\nids = {self._name_to_id[name] for name in names}\nelse:\nids = {self._lazy_name_to_id_lower[name.lower()] for name in names}\nexcept KeyError as e:\nraise ValueError(f\"Could not find column: {e}\") from e\nreturn prune_columns(self, ids)\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitor","title":"<code>SchemaVisitor</code>","text":"<p>         Bases: <code>Generic[T]</code>, <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>class SchemaVisitor(Generic[T], ABC):\ndef before_field(self, field: NestedField) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting a field.\"\"\"\ndef after_field(self, field: NestedField) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting a field.\"\"\"\ndef before_list_element(self, element: NestedField) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting an element within a ListType.\"\"\"\nself.before_field(element)\ndef after_list_element(self, element: NestedField) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting an element within a ListType.\"\"\"\nself.after_field(element)\ndef before_map_key(self, key: NestedField) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting a key within a MapType.\"\"\"\nself.before_field(key)\ndef after_map_key(self, key: NestedField) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting a key within a MapType.\"\"\"\nself.after_field(key)\ndef before_map_value(self, value: NestedField) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting a value within a MapType.\"\"\"\nself.before_field(value)\ndef after_map_value(self, value: NestedField) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting a value within a MapType.\"\"\"\nself.after_field(value)\n@abstractmethod\ndef schema(self, schema: Schema, struct_result: T) -&gt; T:\n\"\"\"Visit a Schema.\"\"\"\n@abstractmethod\ndef struct(self, struct: StructType, field_results: List[T]) -&gt; T:\n\"\"\"Visit a StructType.\"\"\"\n@abstractmethod\ndef field(self, field: NestedField, field_result: T) -&gt; T:\n\"\"\"Visit a NestedField.\"\"\"\n@abstractmethod\ndef list(self, list_type: ListType, element_result: T) -&gt; T:\n\"\"\"Visit a ListType.\"\"\"\n@abstractmethod\ndef map(self, map_type: MapType, key_result: T, value_result: T) -&gt; T:\n\"\"\"Visit a MapType.\"\"\"\n@abstractmethod\ndef primitive(self, primitive: PrimitiveType) -&gt; T:\n\"\"\"Visit a PrimitiveType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitor.after_field","title":"<code>after_field(field)</code>","text":"<p>Override this method to perform an action immediately after visiting a field.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def after_field(self, field: NestedField) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting a field.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitor.after_list_element","title":"<code>after_list_element(element)</code>","text":"<p>Override this method to perform an action immediately after visiting an element within a ListType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def after_list_element(self, element: NestedField) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting an element within a ListType.\"\"\"\nself.after_field(element)\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitor.after_map_key","title":"<code>after_map_key(key)</code>","text":"<p>Override this method to perform an action immediately after visiting a key within a MapType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def after_map_key(self, key: NestedField) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting a key within a MapType.\"\"\"\nself.after_field(key)\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitor.after_map_value","title":"<code>after_map_value(value)</code>","text":"<p>Override this method to perform an action immediately after visiting a value within a MapType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def after_map_value(self, value: NestedField) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting a value within a MapType.\"\"\"\nself.after_field(value)\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitor.before_field","title":"<code>before_field(field)</code>","text":"<p>Override this method to perform an action immediately before visiting a field.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def before_field(self, field: NestedField) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting a field.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitor.before_list_element","title":"<code>before_list_element(element)</code>","text":"<p>Override this method to perform an action immediately before visiting an element within a ListType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def before_list_element(self, element: NestedField) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting an element within a ListType.\"\"\"\nself.before_field(element)\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitor.before_map_key","title":"<code>before_map_key(key)</code>","text":"<p>Override this method to perform an action immediately before visiting a key within a MapType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def before_map_key(self, key: NestedField) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting a key within a MapType.\"\"\"\nself.before_field(key)\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitor.before_map_value","title":"<code>before_map_value(value)</code>","text":"<p>Override this method to perform an action immediately before visiting a value within a MapType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def before_map_value(self, value: NestedField) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting a value within a MapType.\"\"\"\nself.before_field(value)\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitor.field","title":"<code>field(field, field_result)</code>  <code>abstractmethod</code>","text":"<p>Visit a NestedField.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef field(self, field: NestedField, field_result: T) -&gt; T:\n\"\"\"Visit a NestedField.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitor.list","title":"<code>list(list_type, element_result)</code>  <code>abstractmethod</code>","text":"<p>Visit a ListType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef list(self, list_type: ListType, element_result: T) -&gt; T:\n\"\"\"Visit a ListType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitor.map","title":"<code>map(map_type, key_result, value_result)</code>  <code>abstractmethod</code>","text":"<p>Visit a MapType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef map(self, map_type: MapType, key_result: T, value_result: T) -&gt; T:\n\"\"\"Visit a MapType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitor.primitive","title":"<code>primitive(primitive)</code>  <code>abstractmethod</code>","text":"<p>Visit a PrimitiveType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef primitive(self, primitive: PrimitiveType) -&gt; T:\n\"\"\"Visit a PrimitiveType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitor.schema","title":"<code>schema(schema, struct_result)</code>  <code>abstractmethod</code>","text":"<p>Visit a Schema.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef schema(self, schema: Schema, struct_result: T) -&gt; T:\n\"\"\"Visit a Schema.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitor.struct","title":"<code>struct(struct, field_results)</code>  <code>abstractmethod</code>","text":"<p>Visit a StructType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef struct(self, struct: StructType, field_results: List[T]) -&gt; T:\n\"\"\"Visit a StructType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitorPerPrimitiveType","title":"<code>SchemaVisitorPerPrimitiveType</code>","text":"<p>         Bases: <code>SchemaVisitor[T]</code>, <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>class SchemaVisitorPerPrimitiveType(SchemaVisitor[T], ABC):\ndef primitive(self, primitive: PrimitiveType) -&gt; T:\n\"\"\"Visit a PrimitiveType.\"\"\"\nif isinstance(primitive, FixedType):\nreturn self.visit_fixed(primitive)\nelif isinstance(primitive, DecimalType):\nreturn self.visit_decimal(primitive)\nelif isinstance(primitive, BooleanType):\nreturn self.visit_boolean(primitive)\nelif isinstance(primitive, IntegerType):\nreturn self.visit_integer(primitive)\nelif isinstance(primitive, LongType):\nreturn self.visit_long(primitive)\nelif isinstance(primitive, FloatType):\nreturn self.visit_float(primitive)\nelif isinstance(primitive, DoubleType):\nreturn self.visit_double(primitive)\nelif isinstance(primitive, DateType):\nreturn self.visit_date(primitive)\nelif isinstance(primitive, TimeType):\nreturn self.visit_time(primitive)\nelif isinstance(primitive, TimestampType):\nreturn self.visit_timestamp(primitive)\nelif isinstance(primitive, TimestamptzType):\nreturn self.visit_timestampz(primitive)\nelif isinstance(primitive, StringType):\nreturn self.visit_string(primitive)\nelif isinstance(primitive, UUIDType):\nreturn self.visit_uuid(primitive)\nelif isinstance(primitive, BinaryType):\nreturn self.visit_binary(primitive)\nelse:\nraise ValueError(f\"Unknown type: {primitive}\")\n@abstractmethod\ndef visit_fixed(self, fixed_type: FixedType) -&gt; T:\n\"\"\"Visit a FixedType.\"\"\"\n@abstractmethod\ndef visit_decimal(self, decimal_type: DecimalType) -&gt; T:\n\"\"\"Visit a DecimalType.\"\"\"\n@abstractmethod\ndef visit_boolean(self, boolean_type: BooleanType) -&gt; T:\n\"\"\"Visit a BooleanType.\"\"\"\n@abstractmethod\ndef visit_integer(self, integer_type: IntegerType) -&gt; T:\n\"\"\"Visit a IntegerType.\"\"\"\n@abstractmethod\ndef visit_long(self, long_type: LongType) -&gt; T:\n\"\"\"Visit a LongType.\"\"\"\n@abstractmethod\ndef visit_float(self, float_type: FloatType) -&gt; T:\n\"\"\"Visit a FloatType.\"\"\"\n@abstractmethod\ndef visit_double(self, double_type: DoubleType) -&gt; T:\n\"\"\"Visit a DoubleType.\"\"\"\n@abstractmethod\ndef visit_date(self, date_type: DateType) -&gt; T:\n\"\"\"Visit a DecimalType.\"\"\"\n@abstractmethod\ndef visit_time(self, time_type: TimeType) -&gt; T:\n\"\"\"Visit a DecimalType.\"\"\"\n@abstractmethod\ndef visit_timestamp(self, timestamp_type: TimestampType) -&gt; T:\n\"\"\"Visit a TimestampType.\"\"\"\n@abstractmethod\ndef visit_timestampz(self, timestamptz_type: TimestamptzType) -&gt; T:\n\"\"\"Visit a TimestamptzType.\"\"\"\n@abstractmethod\ndef visit_string(self, string_type: StringType) -&gt; T:\n\"\"\"Visit a StringType.\"\"\"\n@abstractmethod\ndef visit_uuid(self, uuid_type: UUIDType) -&gt; T:\n\"\"\"Visit a UUIDType.\"\"\"\n@abstractmethod\ndef visit_binary(self, binary_type: BinaryType) -&gt; T:\n\"\"\"Visit a BinaryType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitorPerPrimitiveType.primitive","title":"<code>primitive(primitive)</code>","text":"<p>Visit a PrimitiveType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def primitive(self, primitive: PrimitiveType) -&gt; T:\n\"\"\"Visit a PrimitiveType.\"\"\"\nif isinstance(primitive, FixedType):\nreturn self.visit_fixed(primitive)\nelif isinstance(primitive, DecimalType):\nreturn self.visit_decimal(primitive)\nelif isinstance(primitive, BooleanType):\nreturn self.visit_boolean(primitive)\nelif isinstance(primitive, IntegerType):\nreturn self.visit_integer(primitive)\nelif isinstance(primitive, LongType):\nreturn self.visit_long(primitive)\nelif isinstance(primitive, FloatType):\nreturn self.visit_float(primitive)\nelif isinstance(primitive, DoubleType):\nreturn self.visit_double(primitive)\nelif isinstance(primitive, DateType):\nreturn self.visit_date(primitive)\nelif isinstance(primitive, TimeType):\nreturn self.visit_time(primitive)\nelif isinstance(primitive, TimestampType):\nreturn self.visit_timestamp(primitive)\nelif isinstance(primitive, TimestamptzType):\nreturn self.visit_timestampz(primitive)\nelif isinstance(primitive, StringType):\nreturn self.visit_string(primitive)\nelif isinstance(primitive, UUIDType):\nreturn self.visit_uuid(primitive)\nelif isinstance(primitive, BinaryType):\nreturn self.visit_binary(primitive)\nelse:\nraise ValueError(f\"Unknown type: {primitive}\")\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitorPerPrimitiveType.visit_binary","title":"<code>visit_binary(binary_type)</code>  <code>abstractmethod</code>","text":"<p>Visit a BinaryType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_binary(self, binary_type: BinaryType) -&gt; T:\n\"\"\"Visit a BinaryType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitorPerPrimitiveType.visit_boolean","title":"<code>visit_boolean(boolean_type)</code>  <code>abstractmethod</code>","text":"<p>Visit a BooleanType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_boolean(self, boolean_type: BooleanType) -&gt; T:\n\"\"\"Visit a BooleanType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitorPerPrimitiveType.visit_date","title":"<code>visit_date(date_type)</code>  <code>abstractmethod</code>","text":"<p>Visit a DecimalType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_date(self, date_type: DateType) -&gt; T:\n\"\"\"Visit a DecimalType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitorPerPrimitiveType.visit_decimal","title":"<code>visit_decimal(decimal_type)</code>  <code>abstractmethod</code>","text":"<p>Visit a DecimalType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_decimal(self, decimal_type: DecimalType) -&gt; T:\n\"\"\"Visit a DecimalType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitorPerPrimitiveType.visit_double","title":"<code>visit_double(double_type)</code>  <code>abstractmethod</code>","text":"<p>Visit a DoubleType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_double(self, double_type: DoubleType) -&gt; T:\n\"\"\"Visit a DoubleType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitorPerPrimitiveType.visit_fixed","title":"<code>visit_fixed(fixed_type)</code>  <code>abstractmethod</code>","text":"<p>Visit a FixedType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_fixed(self, fixed_type: FixedType) -&gt; T:\n\"\"\"Visit a FixedType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitorPerPrimitiveType.visit_float","title":"<code>visit_float(float_type)</code>  <code>abstractmethod</code>","text":"<p>Visit a FloatType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_float(self, float_type: FloatType) -&gt; T:\n\"\"\"Visit a FloatType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitorPerPrimitiveType.visit_integer","title":"<code>visit_integer(integer_type)</code>  <code>abstractmethod</code>","text":"<p>Visit a IntegerType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_integer(self, integer_type: IntegerType) -&gt; T:\n\"\"\"Visit a IntegerType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitorPerPrimitiveType.visit_long","title":"<code>visit_long(long_type)</code>  <code>abstractmethod</code>","text":"<p>Visit a LongType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_long(self, long_type: LongType) -&gt; T:\n\"\"\"Visit a LongType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitorPerPrimitiveType.visit_string","title":"<code>visit_string(string_type)</code>  <code>abstractmethod</code>","text":"<p>Visit a StringType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_string(self, string_type: StringType) -&gt; T:\n\"\"\"Visit a StringType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitorPerPrimitiveType.visit_time","title":"<code>visit_time(time_type)</code>  <code>abstractmethod</code>","text":"<p>Visit a DecimalType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_time(self, time_type: TimeType) -&gt; T:\n\"\"\"Visit a DecimalType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitorPerPrimitiveType.visit_timestamp","title":"<code>visit_timestamp(timestamp_type)</code>  <code>abstractmethod</code>","text":"<p>Visit a TimestampType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_timestamp(self, timestamp_type: TimestampType) -&gt; T:\n\"\"\"Visit a TimestampType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitorPerPrimitiveType.visit_timestampz","title":"<code>visit_timestampz(timestamptz_type)</code>  <code>abstractmethod</code>","text":"<p>Visit a TimestamptzType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_timestampz(self, timestamptz_type: TimestamptzType) -&gt; T:\n\"\"\"Visit a TimestamptzType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaVisitorPerPrimitiveType.visit_uuid","title":"<code>visit_uuid(uuid_type)</code>  <code>abstractmethod</code>","text":"<p>Visit a UUIDType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef visit_uuid(self, uuid_type: UUIDType) -&gt; T:\n\"\"\"Visit a UUIDType.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaWithPartnerVisitor","title":"<code>SchemaWithPartnerVisitor</code>","text":"<p>         Bases: <code>Generic[P, T]</code>, <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>class SchemaWithPartnerVisitor(Generic[P, T], ABC):\ndef before_field(self, field: NestedField, field_partner: Optional[P]) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting a field.\"\"\"\ndef after_field(self, field: NestedField, field_partner: Optional[P]) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting a field.\"\"\"\ndef before_list_element(self, element: NestedField, element_partner: Optional[P]) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting an element within a ListType.\"\"\"\nself.before_field(element, element_partner)\ndef after_list_element(self, element: NestedField, element_partner: Optional[P]) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting an element within a ListType.\"\"\"\nself.after_field(element, element_partner)\ndef before_map_key(self, key: NestedField, key_partner: Optional[P]) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting a key within a MapType.\"\"\"\nself.before_field(key, key_partner)\ndef after_map_key(self, key: NestedField, key_partner: Optional[P]) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting a key within a MapType.\"\"\"\nself.after_field(key, key_partner)\ndef before_map_value(self, value: NestedField, value_partner: Optional[P]) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting a value within a MapType.\"\"\"\nself.before_field(value, value_partner)\ndef after_map_value(self, value: NestedField, value_partner: Optional[P]) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting a value within a MapType.\"\"\"\nself.after_field(value, value_partner)\n@abstractmethod\ndef schema(self, schema: Schema, schema_partner: Optional[P], struct_result: T) -&gt; T:\n\"\"\"Visit a schema with a partner.\"\"\"\n@abstractmethod\ndef struct(self, struct: StructType, struct_partner: Optional[P], field_results: List[T]) -&gt; T:\n\"\"\"Visit a struct type with a partner.\"\"\"\n@abstractmethod\ndef field(self, field: NestedField, field_partner: Optional[P], field_result: T) -&gt; T:\n\"\"\"Visit a nested field with a partner.\"\"\"\n@abstractmethod\ndef list(self, list_type: ListType, list_partner: Optional[P], element_result: T) -&gt; T:\n\"\"\"Visit a list type with a partner.\"\"\"\n@abstractmethod\ndef map(self, map_type: MapType, map_partner: Optional[P], key_result: T, value_result: T) -&gt; T:\n\"\"\"Visit a map type with a partner.\"\"\"\n@abstractmethod\ndef primitive(self, primitive: PrimitiveType, primitive_partner: Optional[P]) -&gt; T:\n\"\"\"Visit a primitive type with a partner.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaWithPartnerVisitor.after_field","title":"<code>after_field(field, field_partner)</code>","text":"<p>Override this method to perform an action immediately after visiting a field.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def after_field(self, field: NestedField, field_partner: Optional[P]) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting a field.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaWithPartnerVisitor.after_list_element","title":"<code>after_list_element(element, element_partner)</code>","text":"<p>Override this method to perform an action immediately after visiting an element within a ListType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def after_list_element(self, element: NestedField, element_partner: Optional[P]) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting an element within a ListType.\"\"\"\nself.after_field(element, element_partner)\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaWithPartnerVisitor.after_map_key","title":"<code>after_map_key(key, key_partner)</code>","text":"<p>Override this method to perform an action immediately after visiting a key within a MapType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def after_map_key(self, key: NestedField, key_partner: Optional[P]) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting a key within a MapType.\"\"\"\nself.after_field(key, key_partner)\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaWithPartnerVisitor.after_map_value","title":"<code>after_map_value(value, value_partner)</code>","text":"<p>Override this method to perform an action immediately after visiting a value within a MapType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def after_map_value(self, value: NestedField, value_partner: Optional[P]) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting a value within a MapType.\"\"\"\nself.after_field(value, value_partner)\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaWithPartnerVisitor.before_field","title":"<code>before_field(field, field_partner)</code>","text":"<p>Override this method to perform an action immediately before visiting a field.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def before_field(self, field: NestedField, field_partner: Optional[P]) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting a field.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaWithPartnerVisitor.before_list_element","title":"<code>before_list_element(element, element_partner)</code>","text":"<p>Override this method to perform an action immediately before visiting an element within a ListType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def before_list_element(self, element: NestedField, element_partner: Optional[P]) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting an element within a ListType.\"\"\"\nself.before_field(element, element_partner)\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaWithPartnerVisitor.before_map_key","title":"<code>before_map_key(key, key_partner)</code>","text":"<p>Override this method to perform an action immediately before visiting a key within a MapType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def before_map_key(self, key: NestedField, key_partner: Optional[P]) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting a key within a MapType.\"\"\"\nself.before_field(key, key_partner)\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaWithPartnerVisitor.before_map_value","title":"<code>before_map_value(value, value_partner)</code>","text":"<p>Override this method to perform an action immediately before visiting a value within a MapType.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def before_map_value(self, value: NestedField, value_partner: Optional[P]) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting a value within a MapType.\"\"\"\nself.before_field(value, value_partner)\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaWithPartnerVisitor.field","title":"<code>field(field, field_partner, field_result)</code>  <code>abstractmethod</code>","text":"<p>Visit a nested field with a partner.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef field(self, field: NestedField, field_partner: Optional[P], field_result: T) -&gt; T:\n\"\"\"Visit a nested field with a partner.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaWithPartnerVisitor.list","title":"<code>list(list_type, list_partner, element_result)</code>  <code>abstractmethod</code>","text":"<p>Visit a list type with a partner.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef list(self, list_type: ListType, list_partner: Optional[P], element_result: T) -&gt; T:\n\"\"\"Visit a list type with a partner.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaWithPartnerVisitor.map","title":"<code>map(map_type, map_partner, key_result, value_result)</code>  <code>abstractmethod</code>","text":"<p>Visit a map type with a partner.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef map(self, map_type: MapType, map_partner: Optional[P], key_result: T, value_result: T) -&gt; T:\n\"\"\"Visit a map type with a partner.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaWithPartnerVisitor.primitive","title":"<code>primitive(primitive, primitive_partner)</code>  <code>abstractmethod</code>","text":"<p>Visit a primitive type with a partner.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef primitive(self, primitive: PrimitiveType, primitive_partner: Optional[P]) -&gt; T:\n\"\"\"Visit a primitive type with a partner.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaWithPartnerVisitor.schema","title":"<code>schema(schema, schema_partner, struct_result)</code>  <code>abstractmethod</code>","text":"<p>Visit a schema with a partner.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef schema(self, schema: Schema, schema_partner: Optional[P], struct_result: T) -&gt; T:\n\"\"\"Visit a schema with a partner.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.SchemaWithPartnerVisitor.struct","title":"<code>struct(struct, struct_partner, field_results)</code>  <code>abstractmethod</code>","text":"<p>Visit a struct type with a partner.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@abstractmethod\ndef struct(self, struct: StructType, struct_partner: Optional[P], field_results: List[T]) -&gt; T:\n\"\"\"Visit a struct type with a partner.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.assign_fresh_schema_ids","title":"<code>assign_fresh_schema_ids(schema)</code>","text":"<p>Traverses the schema, and sets new IDs.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def assign_fresh_schema_ids(schema: Schema) -&gt; Schema:\n\"\"\"Traverses the schema, and sets new IDs.\"\"\"\nreturn pre_order_visit(schema, _SetFreshIDs())\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.build_position_accessors","title":"<code>build_position_accessors(schema_or_type)</code>","text":"<p>Generate an index of field IDs to schema position accessors.</p> <p>Parameters:</p> Name Type Description Default <code>schema_or_type</code> <code>Union[Schema, IcebergType]</code> <p>A schema or type to index.</p> required <p>Returns:</p> Type Description <code>Dict[int, Accessor]</code> <p>Dict[int, Accessor]: An index of field IDs to accessors.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def build_position_accessors(schema_or_type: Union[Schema, IcebergType]) -&gt; Dict[int, Accessor]:\n\"\"\"Generate an index of field IDs to schema position accessors.\n    Args:\n        schema_or_type (Union[Schema, IcebergType]): A schema or type to index.\n    Returns:\n        Dict[int, Accessor]: An index of field IDs to accessors.\n    \"\"\"\nreturn visit(schema_or_type, _BuildPositionAccessors())\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.index_by_id","title":"<code>index_by_id(schema_or_type)</code>","text":"<p>Generate an index of field IDs to NestedField instances.</p> <p>Parameters:</p> Name Type Description Default <code>schema_or_type</code> <code>Union[Schema, IcebergType]</code> <p>A schema or type to index.</p> required <p>Returns:</p> Type Description <code>Dict[int, NestedField]</code> <p>Dict[int, NestedField]: An index of field IDs to NestedField instances.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def index_by_id(schema_or_type: Union[Schema, IcebergType]) -&gt; Dict[int, NestedField]:\n\"\"\"Generate an index of field IDs to NestedField instances.\n    Args:\n        schema_or_type (Union[Schema, IcebergType]): A schema or type to index.\n    Returns:\n        Dict[int, NestedField]: An index of field IDs to NestedField instances.\n    \"\"\"\nreturn visit(schema_or_type, _IndexById())\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.index_by_name","title":"<code>index_by_name(schema_or_type)</code>","text":"<p>Generate an index of field names to field IDs.</p> <p>Parameters:</p> Name Type Description Default <code>schema_or_type</code> <code>Union[Schema, IcebergType]</code> <p>A schema or type to index.</p> required <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dict[str, int]: An index of field names to field IDs.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def index_by_name(schema_or_type: Union[Schema, IcebergType]) -&gt; Dict[str, int]:\n\"\"\"Generate an index of field names to field IDs.\n    Args:\n        schema_or_type (Union[Schema, IcebergType]): A schema or type to index.\n    Returns:\n        Dict[str, int]: An index of field names to field IDs.\n    \"\"\"\nif len(schema_or_type.fields) &gt; 0:\nindexer = _IndexByName()\nvisit(schema_or_type, indexer)\nreturn indexer.by_name()\nelse:\nreturn EMPTY_DICT\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.index_name_by_id","title":"<code>index_name_by_id(schema_or_type)</code>","text":"<p>Generate an index of field IDs full field names.</p> <p>Parameters:</p> Name Type Description Default <code>schema_or_type</code> <code>Union[Schema, IcebergType]</code> <p>A schema or type to index.</p> required <p>Returns:</p> Type Description <code>Dict[int, str]</code> <p>Dict[str, int]: An index of field IDs to full names.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>def index_name_by_id(schema_or_type: Union[Schema, IcebergType]) -&gt; Dict[int, str]:\n\"\"\"Generate an index of field IDs full field names.\n    Args:\n        schema_or_type (Union[Schema, IcebergType]): A schema or type to index.\n    Returns:\n        Dict[str, int]: An index of field IDs to full names.\n    \"\"\"\nindexer = _IndexByName()\nvisit(schema_or_type, indexer)\nreturn indexer.by_id()\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.pre_order_visit","title":"<code>pre_order_visit(obj, visitor)</code>","text":"<p>A generic function for applying a schema visitor to any point within a schema.</p> <p>The function traverses the schema in pre-order fashion. This is a slimmed down version compared to the post-order traversal (missing before and after methods), mostly because we don't use the pre-order traversal much.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[Schema, IcebergType]</code> <p>An instance of a Schema or an IcebergType.</p> required <code>visitor</code> <code>PreOrderSchemaVisitor[T]</code> <p>An instance of an implementation of the generic PreOrderSchemaVisitor base class.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If attempting to visit an unrecognized object type.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@singledispatch\ndef pre_order_visit(obj: Union[Schema, IcebergType], visitor: PreOrderSchemaVisitor[T]) -&gt; T:\n\"\"\"A generic function for applying a schema visitor to any point within a schema.\n    The function traverses the schema in pre-order fashion. This is a slimmed down version\n    compared to the post-order traversal (missing before and after methods), mostly\n    because we don't use the pre-order traversal much.\n    Args:\n        obj (Union[Schema, IcebergType]): An instance of a Schema or an IcebergType.\n        visitor (PreOrderSchemaVisitor[T]): An instance of an implementation of the generic PreOrderSchemaVisitor base class.\n    Raises:\n        NotImplementedError: If attempting to visit an unrecognized object type.\n    \"\"\"\nraise NotImplementedError(\"Cannot visit non-type: %s\" % obj)\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.promote","title":"<code>promote(file_type, read_type)</code>","text":"<p>Promotes reading a file type to a read type.</p> <p>Parameters:</p> Name Type Description Default <code>file_type</code> <code>IcebergType</code> <p>The type of the Avro file.</p> required <code>read_type</code> <code>IcebergType</code> <p>The requested read type.</p> required <p>Raises:</p> Type Description <code>ResolveError</code> <p>If attempting to resolve an unrecognized object type.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@singledispatch\ndef promote(file_type: IcebergType, read_type: IcebergType) -&gt; IcebergType:\n\"\"\"Promotes reading a file type to a read type.\n    Args:\n        file_type (IcebergType): The type of the Avro file.\n        read_type (IcebergType): The requested read type.\n    Raises:\n        ResolveError: If attempting to resolve an unrecognized object type.\n    \"\"\"\nif file_type == read_type:\nreturn file_type\nelse:\nraise ResolveError(f\"Cannot promote {file_type} to {read_type}\")\n</code></pre>"},{"location":"reference/pyiceberg/schema/#pyiceberg.schema.visit","title":"<code>visit(obj, visitor)</code>","text":"<p>A generic function for applying a schema visitor to any point within a schema.</p> <p>The function traverses the schema in post-order fashion.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[Schema, IcebergType]</code> <p>An instance of a Schema or an IcebergType.</p> required <code>visitor</code> <code>SchemaVisitor[T]</code> <p>An instance of an implementation of the generic SchemaVisitor base class.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If attempting to visit an unrecognized object type.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/schema.py</code> <pre><code>@singledispatch\ndef visit(obj: Union[Schema, IcebergType], visitor: SchemaVisitor[T]) -&gt; T:\n\"\"\"A generic function for applying a schema visitor to any point within a schema.\n    The function traverses the schema in post-order fashion.\n    Args:\n        obj (Union[Schema, IcebergType]): An instance of a Schema or an IcebergType.\n        visitor (SchemaVisitor[T]): An instance of an implementation of the generic SchemaVisitor base class.\n    Raises:\n        NotImplementedError: If attempting to visit an unrecognized object type.\n    \"\"\"\nraise NotImplementedError(\"Cannot visit non-type: %s\" % obj)\n</code></pre>"},{"location":"reference/pyiceberg/serializers/","title":"serializers","text":""},{"location":"reference/pyiceberg/serializers/#pyiceberg.serializers.FromByteStream","title":"<code>FromByteStream</code>","text":"<p>A collection of methods that deserialize dictionaries into Iceberg objects.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/serializers.py</code> <pre><code>class FromByteStream:\n\"\"\"A collection of methods that deserialize dictionaries into Iceberg objects.\"\"\"\n@staticmethod\ndef table_metadata(byte_stream: InputStream, encoding: str = \"utf-8\") -&gt; TableMetadata:\n\"\"\"Instantiate a TableMetadata object from a byte stream.\n        Args:\n            byte_stream: A file-like byte stream object.\n            encoding (default \"utf-8\"): The byte encoder to use for the reader.\n        \"\"\"\nreader = codecs.getreader(encoding)\nmetadata = json.load(reader(byte_stream))\nreturn TableMetadataUtil.parse_obj(metadata)\n</code></pre>"},{"location":"reference/pyiceberg/serializers/#pyiceberg.serializers.FromByteStream.table_metadata","title":"<code>table_metadata(byte_stream, encoding='utf-8')</code>  <code>staticmethod</code>","text":"<p>Instantiate a TableMetadata object from a byte stream.</p> <p>Parameters:</p> Name Type Description Default <code>byte_stream</code> <code>InputStream</code> <p>A file-like byte stream object.</p> required <code>encoding</code> <code>default \"utf-8\"</code> <p>The byte encoder to use for the reader.</p> <code>'utf-8'</code> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/serializers.py</code> <pre><code>@staticmethod\ndef table_metadata(byte_stream: InputStream, encoding: str = \"utf-8\") -&gt; TableMetadata:\n\"\"\"Instantiate a TableMetadata object from a byte stream.\n    Args:\n        byte_stream: A file-like byte stream object.\n        encoding (default \"utf-8\"): The byte encoder to use for the reader.\n    \"\"\"\nreader = codecs.getreader(encoding)\nmetadata = json.load(reader(byte_stream))\nreturn TableMetadataUtil.parse_obj(metadata)\n</code></pre>"},{"location":"reference/pyiceberg/serializers/#pyiceberg.serializers.FromInputFile","title":"<code>FromInputFile</code>","text":"<p>A collection of methods that deserialize InputFiles into Iceberg objects.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/serializers.py</code> <pre><code>class FromInputFile:\n\"\"\"A collection of methods that deserialize InputFiles into Iceberg objects.\"\"\"\n@staticmethod\ndef table_metadata(input_file: InputFile, encoding: str = \"utf-8\") -&gt; TableMetadata:\n\"\"\"Create a TableMetadata instance from an input file.\n        Args:\n            input_file (InputFile): A custom implementation of the iceberg.io.file.InputFile abstract base class.\n            encoding (str): Encoding to use when loading bytestream.\n        Returns:\n            TableMetadata: A table metadata instance.\n        \"\"\"\nwith input_file.open() as input_stream:\nreturn FromByteStream.table_metadata(byte_stream=input_stream, encoding=encoding)\n</code></pre>"},{"location":"reference/pyiceberg/serializers/#pyiceberg.serializers.FromInputFile.table_metadata","title":"<code>table_metadata(input_file, encoding='utf-8')</code>  <code>staticmethod</code>","text":"<p>Create a TableMetadata instance from an input file.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>InputFile</code> <p>A custom implementation of the iceberg.io.file.InputFile abstract base class.</p> required <code>encoding</code> <code>str</code> <p>Encoding to use when loading bytestream.</p> <code>'utf-8'</code> <p>Returns:</p> Name Type Description <code>TableMetadata</code> <code>TableMetadata</code> <p>A table metadata instance.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/serializers.py</code> <pre><code>@staticmethod\ndef table_metadata(input_file: InputFile, encoding: str = \"utf-8\") -&gt; TableMetadata:\n\"\"\"Create a TableMetadata instance from an input file.\n    Args:\n        input_file (InputFile): A custom implementation of the iceberg.io.file.InputFile abstract base class.\n        encoding (str): Encoding to use when loading bytestream.\n    Returns:\n        TableMetadata: A table metadata instance.\n    \"\"\"\nwith input_file.open() as input_stream:\nreturn FromByteStream.table_metadata(byte_stream=input_stream, encoding=encoding)\n</code></pre>"},{"location":"reference/pyiceberg/serializers/#pyiceberg.serializers.ToOutputFile","title":"<code>ToOutputFile</code>","text":"<p>A collection of methods that serialize Iceberg objects into files given an OutputFile instance.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/serializers.py</code> <pre><code>class ToOutputFile:\n\"\"\"A collection of methods that serialize Iceberg objects into files given an OutputFile instance.\"\"\"\n@staticmethod\ndef table_metadata(metadata: TableMetadata, output_file: OutputFile, overwrite: bool = False) -&gt; None:\n\"\"\"Write a TableMetadata instance to an output file.\n        Args:\n            output_file (OutputFile): A custom implementation of the iceberg.io.file.OutputFile abstract base class.\n            overwrite (bool): Where to overwrite the file if it already exists. Defaults to `False`.\n        \"\"\"\nwith output_file.create(overwrite=overwrite) as output_stream:\noutput_stream.write(metadata.json().encode(\"utf-8\"))\n</code></pre>"},{"location":"reference/pyiceberg/serializers/#pyiceberg.serializers.ToOutputFile.table_metadata","title":"<code>table_metadata(metadata, output_file, overwrite=False)</code>  <code>staticmethod</code>","text":"<p>Write a TableMetadata instance to an output file.</p> <p>Parameters:</p> Name Type Description Default <code>output_file</code> <code>OutputFile</code> <p>A custom implementation of the iceberg.io.file.OutputFile abstract base class.</p> required <code>overwrite</code> <code>bool</code> <p>Where to overwrite the file if it already exists. Defaults to <code>False</code>.</p> <code>False</code> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/serializers.py</code> <pre><code>@staticmethod\ndef table_metadata(metadata: TableMetadata, output_file: OutputFile, overwrite: bool = False) -&gt; None:\n\"\"\"Write a TableMetadata instance to an output file.\n    Args:\n        output_file (OutputFile): A custom implementation of the iceberg.io.file.OutputFile abstract base class.\n        overwrite (bool): Where to overwrite the file if it already exists. Defaults to `False`.\n    \"\"\"\nwith output_file.create(overwrite=overwrite) as output_stream:\noutput_stream.write(metadata.json().encode(\"utf-8\"))\n</code></pre>"},{"location":"reference/pyiceberg/transforms/","title":"transforms","text":""},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.BoundTransform","title":"<code>BoundTransform</code>","text":"<p>         Bases: <code>BoundTerm[L]</code></p> <p>A transform expression.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>class BoundTransform(BoundTerm[L]):\n\"\"\"A transform expression.\"\"\"\ntransform: Transform[L, Any]\ndef __init__(self, term: BoundTerm[L], transform: Transform[L, Any]):\nself.term: BoundTerm[L] = term\nself.transform = transform\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.BucketTransform","title":"<code>BucketTransform</code>","text":"<p>         Bases: <code>Transform[S, int]</code></p> <p>Base Transform class to transform a value into a bucket partition value.</p> <p>Transforms are parameterized by a number of buckets. Bucket partition transforms use a 32-bit hash of the source value to produce a positive value by mod the bucket number.</p> <p>Parameters:</p> Name Type Description Default <code>num_buckets</code> <code>int</code> <p>The number of buckets.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>class BucketTransform(Transform[S, int]):\n\"\"\"Base Transform class to transform a value into a bucket partition value.\n    Transforms are parameterized by a number of buckets. Bucket partition transforms use a 32-bit\n    hash of the source value to produce a positive value by mod the bucket number.\n    Args:\n      num_buckets (int): The number of buckets.\n    \"\"\"\n_num_buckets: PositiveInt = PrivateAttr()\ndef __init__(self, num_buckets: int, **data: Any) -&gt; None:\nsuper().__init__(__root__=f\"bucket[{num_buckets}]\", **data)\nself._num_buckets = num_buckets\n@property\ndef num_buckets(self) -&gt; int:\nreturn self._num_buckets\ndef hash(self, value: S) -&gt; int:\nraise NotImplementedError()\ndef apply(self, value: Optional[S]) -&gt; Optional[int]:\nreturn (self.hash(value) &amp; IntegerType.max) % self._num_buckets if value else None\ndef result_type(self, source: IcebergType) -&gt; IcebergType:\nreturn IntegerType()\ndef project(self, name: str, pred: BoundPredicate[L]) -&gt; Optional[UnboundPredicate[Any]]:\ntransformer = self.transform(pred.term.ref().field.field_type)\nif isinstance(pred.term, BoundTransform):\nreturn _project_transform_predicate(self, name, pred)\nelif isinstance(pred, BoundUnaryPredicate):\nreturn pred.as_unbound(Reference(name))\nelif isinstance(pred, BoundEqualTo):\nreturn pred.as_unbound(Reference(name), _transform_literal(transformer, pred.literal))\nelif isinstance(pred, BoundIn):  # NotIn can't be projected\nreturn pred.as_unbound(Reference(name), {_transform_literal(transformer, literal) for literal in pred.literals})\nelse:\n# - Comparison predicates can't be projected, notEq can't be projected\n# - Small ranges can be projected:\n#   For example, (x &gt; 0) and (x &lt; 3) can be turned into in({1, 2}) and projected.\nreturn None\ndef can_transform(self, source: IcebergType) -&gt; bool:\nreturn type(source) in {\nIntegerType,\nDateType,\nLongType,\nTimeType,\nTimestampType,\nTimestamptzType,\nDecimalType,\nStringType,\nFixedType,\nBinaryType,\nUUIDType,\n}\ndef transform(self, source: IcebergType, bucket: bool = True) -&gt; Callable[[Optional[Any]], Optional[int]]:\nsource_type = type(source)\nif source_type in {IntegerType, LongType, DateType, TimeType, TimestampType, TimestamptzType}:\ndef hash_func(v: Any) -&gt; int:\nreturn mmh3.hash(struct.pack(\"&lt;q\", v))\nelif source_type == DecimalType:\ndef hash_func(v: Any) -&gt; int:\nreturn mmh3.hash(decimal_to_bytes(v))\nelif source_type in {StringType, FixedType, BinaryType}:\ndef hash_func(v: Any) -&gt; int:\nreturn mmh3.hash(v)\nelif source_type == UUIDType:\ndef hash_func(v: Any) -&gt; int:\nreturn mmh3.hash(\nstruct.pack(\n\"&gt;QQ\",\n(v.int &gt;&gt; 64) &amp; 0xFFFFFFFFFFFFFFFF,\nv.int &amp; 0xFFFFFFFFFFFFFFFF,\n)\n)\nelse:\nraise ValueError(f\"Unknown type {source}\")\nif bucket:\nreturn lambda v: (hash_func(v) &amp; IntegerType.max) % self._num_buckets if v else None\nreturn hash_func\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the BucketTransform class.\"\"\"\nreturn f\"BucketTransform(num_buckets={self._num_buckets})\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.BucketTransform.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the BucketTransform class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the BucketTransform class.\"\"\"\nreturn f\"BucketTransform(num_buckets={self._num_buckets})\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.DayTransform","title":"<code>DayTransform</code>","text":"<p>         Bases: <code>TimeTransform[S]</code></p> <p>Transforms a datetime value into a day value.</p> Example <p>transform = MonthTransform() transform.transform(DateType())(17501) 17501</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>class DayTransform(TimeTransform[S]):\n\"\"\"Transforms a datetime value into a day value.\n    Example:\n        &gt;&gt;&gt; transform = MonthTransform()\n        &gt;&gt;&gt; transform.transform(DateType())(17501)\n        17501\n    \"\"\"\n__root__: LiteralType[\"day\"] = Field(default=\"day\")  # noqa: F821\ndef transform(self, source: IcebergType) -&gt; Callable[[Optional[S]], Optional[int]]:\nsource_type = type(source)\nif source_type == DateType:\ndef day_func(v: Any) -&gt; int:\nreturn v\nelif source_type in {TimestampType, TimestamptzType}:\ndef day_func(v: Any) -&gt; int:\nreturn datetime.micros_to_days(v)\nelse:\nraise ValueError(f\"Cannot apply day transform for type: {source}\")\nreturn lambda v: day_func(v) if v else None\ndef can_transform(self, source: IcebergType) -&gt; bool:\nreturn type(source) in {\nDateType,\nTimestampType,\nTimestamptzType,\n}\ndef result_type(self, source: IcebergType) -&gt; IcebergType:\nreturn DateType()\n@property\ndef granularity(self) -&gt; TimeResolution:\nreturn TimeResolution.DAY\ndef to_human_string(self, _: IcebergType, value: Optional[S]) -&gt; str:\nreturn datetime.to_human_day(value) if isinstance(value, int) else \"null\"\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the DayTransform class.\"\"\"\nreturn \"DayTransform()\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.DayTransform.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the DayTransform class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the DayTransform class.\"\"\"\nreturn \"DayTransform()\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.HourTransform","title":"<code>HourTransform</code>","text":"<p>         Bases: <code>TimeTransform[S]</code></p> <p>Transforms a datetime value into a hour value.</p> Example <p>transform = HourTransform() transform.transform(TimestampType())(1512151975038194) 420042</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>class HourTransform(TimeTransform[S]):\n\"\"\"Transforms a datetime value into a hour value.\n    Example:\n        &gt;&gt;&gt; transform = HourTransform()\n        &gt;&gt;&gt; transform.transform(TimestampType())(1512151975038194)\n        420042\n    \"\"\"\n__root__: LiteralType[\"hour\"] = Field(default=\"hour\")  # noqa: F821\ndef transform(self, source: IcebergType) -&gt; Callable[[Optional[S]], Optional[int]]:\nif type(source) in {TimestampType, TimestamptzType}:\ndef hour_func(v: Any) -&gt; int:\nreturn datetime.micros_to_hours(v)\nelse:\nraise ValueError(f\"Cannot apply hour transform for type: {source}\")\nreturn lambda v: hour_func(v) if v else None\ndef can_transform(self, source: IcebergType) -&gt; bool:\nreturn type(source) in {\nTimestampType,\nTimestamptzType,\n}\n@property\ndef granularity(self) -&gt; TimeResolution:\nreturn TimeResolution.HOUR\ndef to_human_string(self, _: IcebergType, value: Optional[S]) -&gt; str:\nreturn datetime.to_human_hour(value) if isinstance(value, int) else \"null\"\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the HourTransform class.\"\"\"\nreturn \"HourTransform()\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.HourTransform.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the HourTransform class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the HourTransform class.\"\"\"\nreturn \"HourTransform()\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.IdentityTransform","title":"<code>IdentityTransform</code>","text":"<p>         Bases: <code>Transform[S, S]</code></p> <p>Transforms a value into itself.</p> Example <p>transform = IdentityTransform() transform.transform(StringType())('hello-world') 'hello-world'</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>class IdentityTransform(Transform[S, S]):\n\"\"\"Transforms a value into itself.\n    Example:\n        &gt;&gt;&gt; transform = IdentityTransform()\n        &gt;&gt;&gt; transform.transform(StringType())('hello-world')\n        'hello-world'\n    \"\"\"\n__root__: LiteralType[\"identity\"] = Field(default=\"identity\")  # noqa: F821\ndef transform(self, source: IcebergType) -&gt; Callable[[Optional[S]], Optional[S]]:\nreturn lambda v: v\ndef can_transform(self, source: IcebergType) -&gt; bool:\nreturn source.is_primitive\ndef result_type(self, source: IcebergType) -&gt; IcebergType:\nreturn source\ndef project(self, name: str, pred: BoundPredicate[L]) -&gt; Optional[UnboundPredicate[Any]]:\nif isinstance(pred.term, BoundTransform):\nreturn _project_transform_predicate(self, name, pred)\nelif isinstance(pred, BoundUnaryPredicate):\nreturn pred.as_unbound(Reference(name))\nelif isinstance(pred, BoundLiteralPredicate):\nreturn pred.as_unbound(Reference(name), pred.literal)\nelif isinstance(pred, (BoundIn, BoundNotIn)):\nreturn pred.as_unbound(Reference(name), pred.literals)\nelse:\nraise ValueError(f\"Could not project: {pred}\")\n@property\ndef preserves_order(self) -&gt; bool:\nreturn True\ndef satisfies_order_of(self, other: Transform[S, T]) -&gt; bool:\n\"\"\"Ordering by value is the same as long as the other preserves order.\"\"\"\nreturn other.preserves_order\ndef to_human_string(self, source_type: IcebergType, value: Optional[S]) -&gt; str:\nreturn _human_string(value, source_type) if value is not None else \"null\"\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the IdentityTransform class.\"\"\"\nreturn \"identity\"\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the IdentityTransform class.\"\"\"\nreturn \"IdentityTransform()\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.IdentityTransform.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the IdentityTransform class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the IdentityTransform class.\"\"\"\nreturn \"IdentityTransform()\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.IdentityTransform.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the IdentityTransform class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the IdentityTransform class.\"\"\"\nreturn \"identity\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.IdentityTransform.satisfies_order_of","title":"<code>satisfies_order_of(other)</code>","text":"<p>Ordering by value is the same as long as the other preserves order.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>def satisfies_order_of(self, other: Transform[S, T]) -&gt; bool:\n\"\"\"Ordering by value is the same as long as the other preserves order.\"\"\"\nreturn other.preserves_order\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.MonthTransform","title":"<code>MonthTransform</code>","text":"<p>         Bases: <code>TimeTransform[S]</code></p> <p>Transforms a datetime value into a month value.</p> Example <p>transform = MonthTransform() transform.transform(DateType())(17501) 575</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>class MonthTransform(TimeTransform[S]):\n\"\"\"Transforms a datetime value into a month value.\n    Example:\n        &gt;&gt;&gt; transform = MonthTransform()\n        &gt;&gt;&gt; transform.transform(DateType())(17501)\n        575\n    \"\"\"\n__root__: LiteralType[\"month\"] = Field(default=\"month\")  # noqa: F821\ndef transform(self, source: IcebergType) -&gt; Callable[[Optional[S]], Optional[int]]:\nsource_type = type(source)\nif source_type == DateType:\ndef month_func(v: Any) -&gt; int:\nreturn datetime.days_to_months(v)\nelif source_type in {TimestampType, TimestamptzType}:\ndef month_func(v: Any) -&gt; int:\nreturn datetime.micros_to_months(v)\nelse:\nraise ValueError(f\"Cannot apply month transform for type: {source}\")\nreturn lambda v: month_func(v) if v else None\ndef can_transform(self, source: IcebergType) -&gt; bool:\nreturn type(source) in {\nDateType,\nTimestampType,\nTimestamptzType,\n}\n@property\ndef granularity(self) -&gt; TimeResolution:\nreturn TimeResolution.MONTH\ndef to_human_string(self, _: IcebergType, value: Optional[S]) -&gt; str:\nreturn datetime.to_human_month(value) if isinstance(value, int) else \"null\"\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the MonthTransform class.\"\"\"\nreturn \"MonthTransform()\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.MonthTransform.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the MonthTransform class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the MonthTransform class.\"\"\"\nreturn \"MonthTransform()\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.Transform","title":"<code>Transform</code>","text":"<p>         Bases: <code>IcebergBaseModel</code>, <code>ABC</code>, <code>Generic[S, T]</code></p> <p>Transform base class for concrete transforms.</p> <p>A base class to transform values and project predicates on partition values. This class is not used directly. Instead, use one of module method to create the child classes.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>class Transform(IcebergBaseModel, ABC, Generic[S, T]):\n\"\"\"Transform base class for concrete transforms.\n    A base class to transform values and project predicates on partition values.\n    This class is not used directly. Instead, use one of module method to create the child classes.\n    \"\"\"\n__root__: str = Field()\n@classmethod\ndef __get_validators__(cls) -&gt; Generator[AnyCallable, None, None]:\n\"\"\"Called to validate the input of the Transform class.\"\"\"\n# one or more validators may be yielded which will be called in the\n# order to validate the input, each validator will receive as an input\n# the value returned from the previous validator\nyield cls.validate\n@classmethod\ndef validate(cls, v: Any) -&gt; IcebergBaseModel:\n# When Pydantic is unable to determine the subtype\n# In this case we'll help pydantic a bit by parsing the transform type ourselves\nif isinstance(v, str):\nif v == IDENTITY:\nreturn IdentityTransform()\nelif v == VOID:\nreturn VoidTransform()\nelif v.startswith(BUCKET):\nreturn BucketTransform(num_buckets=BUCKET_PARSER.match(v))\nelif v.startswith(TRUNCATE):\nreturn TruncateTransform(width=TRUNCATE_PARSER.match(v))\nelif v == YEAR:\nreturn YearTransform()\nelif v == MONTH:\nreturn MonthTransform()\nelif v == DAY:\nreturn DayTransform()\nelif v == HOUR:\nreturn HourTransform()\nelse:\nreturn UnknownTransform(transform=v)\nreturn v\n@abstractmethod\ndef transform(self, source: IcebergType) -&gt; Callable[[Optional[S]], Optional[T]]:\n...\n@abstractmethod\ndef can_transform(self, source: IcebergType) -&gt; bool:\nreturn False\n@abstractmethod\ndef result_type(self, source: IcebergType) -&gt; IcebergType:\n...\n@abstractmethod\ndef project(self, name: str, pred: BoundPredicate[L]) -&gt; Optional[UnboundPredicate[Any]]:\n...\n@property\ndef preserves_order(self) -&gt; bool:\nreturn False\ndef satisfies_order_of(self, other: Any) -&gt; bool:\nreturn self == other\ndef to_human_string(self, _: IcebergType, value: Optional[S]) -&gt; str:\nreturn str(value) if value is not None else \"null\"\n@property\ndef dedup_name(self) -&gt; str:\nreturn self.__str__()\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the Transform class.\"\"\"\nreturn self.__root__\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the Transform class.\"\"\"\nif isinstance(other, Transform):\nreturn self.__root__ == other.__root__\nreturn False\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.Transform.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the Transform class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the Transform class.\"\"\"\nif isinstance(other, Transform):\nreturn self.__root__ == other.__root__\nreturn False\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.Transform.__get_validators__","title":"<code>__get_validators__()</code>  <code>classmethod</code>","text":"<p>Called to validate the input of the Transform class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>@classmethod\ndef __get_validators__(cls) -&gt; Generator[AnyCallable, None, None]:\n\"\"\"Called to validate the input of the Transform class.\"\"\"\n# one or more validators may be yielded which will be called in the\n# order to validate the input, each validator will receive as an input\n# the value returned from the previous validator\nyield cls.validate\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.Transform.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the Transform class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the Transform class.\"\"\"\nreturn self.__root__\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.TruncateTransform","title":"<code>TruncateTransform</code>","text":"<p>         Bases: <code>Transform[S, S]</code></p> <p>A transform for truncating a value to a specified width.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>The truncate width, should be positive.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If a type is provided that is incompatible with a Truncate transform.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>class TruncateTransform(Transform[S, S]):\n\"\"\"A transform for truncating a value to a specified width.\n    Args:\n      width (int): The truncate width, should be positive.\n    Raises:\n      ValueError: If a type is provided that is incompatible with a Truncate transform.\n    \"\"\"\n__root__: str = Field()\n_source_type: IcebergType = PrivateAttr()\n_width: PositiveInt = PrivateAttr()\ndef __init__(self, width: int, **data: Any):\nsuper().__init__(__root__=f\"truncate[{width}]\", **data)\nself._width = width\ndef can_transform(self, source: IcebergType) -&gt; bool:\nreturn type(source) in {IntegerType, LongType, StringType, BinaryType, DecimalType}\ndef result_type(self, source: IcebergType) -&gt; IcebergType:\nreturn source\n@property\ndef preserves_order(self) -&gt; bool:\nreturn True\n@property\ndef source_type(self) -&gt; IcebergType:\nreturn self._source_type\ndef project(self, name: str, pred: BoundPredicate[L]) -&gt; Optional[UnboundPredicate[Any]]:\nfield_type = pred.term.ref().field.field_type\nif isinstance(pred.term, BoundTransform):\nreturn _project_transform_predicate(self, name, pred)\nif isinstance(pred, BoundUnaryPredicate):\nreturn pred.as_unbound(Reference(name))\nelif isinstance(pred, BoundIn):\nreturn _set_apply_transform(name, pred, self.transform(field_type))\nelif isinstance(field_type, (IntegerType, LongType, DecimalType)):\nif isinstance(pred, BoundLiteralPredicate):\nreturn _truncate_number(name, pred, self.transform(field_type))\nelif isinstance(field_type, (BinaryType, StringType)):\nif isinstance(pred, BoundLiteralPredicate):\nreturn _truncate_array(name, pred, self.transform(field_type))\nreturn None\n@property\ndef width(self) -&gt; int:\nreturn self._width\ndef transform(self, source: IcebergType) -&gt; Callable[[Optional[S]], Optional[S]]:\nsource_type = type(source)\nif source_type in {IntegerType, LongType}:\ndef truncate_func(v: Any) -&gt; Any:\nreturn v - v % self._width\nelif source_type in {StringType, BinaryType}:\ndef truncate_func(v: Any) -&gt; Any:\nreturn v[0 : min(self._width, len(v))]\nelif source_type == DecimalType:\ndef truncate_func(v: Any) -&gt; Any:\nreturn truncate_decimal(v, self._width)\nelse:\nraise ValueError(f\"Cannot truncate for type: {source}\")\nreturn lambda v: truncate_func(v) if v else None\ndef satisfies_order_of(self, other: Transform[S, T]) -&gt; bool:\nif self == other:\nreturn True\nelif (\nisinstance(self.source_type, StringType)\nand isinstance(other, TruncateTransform)\nand isinstance(other.source_type, StringType)\n):\nreturn self.width &gt;= other.width\nreturn False\ndef to_human_string(self, _: IcebergType, value: Optional[S]) -&gt; str:\nif value is None:\nreturn \"null\"\nelif isinstance(value, bytes):\nreturn _base64encode(value)\nelse:\nreturn str(value)\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the TruncateTransform class.\"\"\"\nreturn f\"TruncateTransform(width={self._width})\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.TruncateTransform.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the TruncateTransform class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the TruncateTransform class.\"\"\"\nreturn f\"TruncateTransform(width={self._width})\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.UnknownTransform","title":"<code>UnknownTransform</code>","text":"<p>         Bases: <code>Transform[S, T]</code></p> <p>A transform that represents when an unknown transform is provided.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <code>str</code> <p>A string name of a transform.</p> required <p>Other Parameters:</p> Name Type Description <code>source_type</code> <code>IcebergType</code> <p>An Iceberg <code>Type</code>.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>class UnknownTransform(Transform[S, T]):\n\"\"\"A transform that represents when an unknown transform is provided.\n    Args:\n      transform (str): A string name of a transform.\n    Keyword Args:\n      source_type (IcebergType): An Iceberg `Type`.\n    \"\"\"\n__root__: LiteralType[\"unknown\"] = Field(default=\"unknown\")  # noqa: F821\n_transform: str = PrivateAttr()\ndef __init__(self, transform: str, **data: Any):\nsuper().__init__(**data)\nself._transform = transform\ndef transform(self, source: IcebergType) -&gt; Callable[[Optional[S]], Optional[T]]:\nraise AttributeError(f\"Cannot apply unsupported transform: {self}\")\ndef can_transform(self, source: IcebergType) -&gt; bool:\nreturn False\ndef result_type(self, source: IcebergType) -&gt; StringType:\nreturn StringType()\ndef project(self, name: str, pred: BoundPredicate[L]) -&gt; Optional[UnboundPredicate[Any]]:\nreturn None\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the UnknownTransform class.\"\"\"\nreturn f\"UnknownTransform(transform={repr(self._transform)})\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.UnknownTransform.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the UnknownTransform class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the UnknownTransform class.\"\"\"\nreturn f\"UnknownTransform(transform={repr(self._transform)})\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.VoidTransform","title":"<code>VoidTransform</code>","text":"<p>         Bases: <code>Transform[S, None]</code>, <code>Singleton</code></p> <p>A transform that always returns None.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>class VoidTransform(Transform[S, None], Singleton):\n\"\"\"A transform that always returns None.\"\"\"\n__root__ = \"void\"\ndef transform(self, source: IcebergType) -&gt; Callable[[Optional[S]], Optional[T]]:\nreturn lambda v: None\ndef can_transform(self, _: IcebergType) -&gt; bool:\nreturn True\ndef result_type(self, source: IcebergType) -&gt; IcebergType:\nreturn source\ndef project(self, name: str, pred: BoundPredicate[L]) -&gt; Optional[UnboundPredicate[Any]]:\nreturn None\ndef to_human_string(self, _: IcebergType, value: Optional[S]) -&gt; str:\nreturn \"null\"\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the VoidTransform class.\"\"\"\nreturn \"VoidTransform()\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.VoidTransform.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the VoidTransform class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the VoidTransform class.\"\"\"\nreturn \"VoidTransform()\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.YearTransform","title":"<code>YearTransform</code>","text":"<p>         Bases: <code>TimeTransform[S]</code></p> <p>Transforms a datetime value into a year value.</p> Example <p>transform = YearTransform() transform.transform(TimestampType())(1512151975038194) 47</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>class YearTransform(TimeTransform[S]):\n\"\"\"Transforms a datetime value into a year value.\n    Example:\n        &gt;&gt;&gt; transform = YearTransform()\n        &gt;&gt;&gt; transform.transform(TimestampType())(1512151975038194)\n        47\n    \"\"\"\n__root__: LiteralType[\"year\"] = Field(default=\"year\")  # noqa: F821\ndef transform(self, source: IcebergType) -&gt; Callable[[Optional[S]], Optional[int]]:\nsource_type = type(source)\nif source_type == DateType:\ndef year_func(v: Any) -&gt; int:\nreturn datetime.days_to_years(v)\nelif source_type in {TimestampType, TimestamptzType}:\ndef year_func(v: Any) -&gt; int:\nreturn datetime.micros_to_years(v)\nelse:\nraise ValueError(f\"Cannot apply year transform for type: {source}\")\nreturn lambda v: year_func(v) if v is not None else None\ndef can_transform(self, source: IcebergType) -&gt; bool:\nreturn type(source) in {\nDateType,\nTimestampType,\nTimestamptzType,\n}\n@property\ndef granularity(self) -&gt; TimeResolution:\nreturn TimeResolution.YEAR\ndef to_human_string(self, _: IcebergType, value: Optional[S]) -&gt; str:\nreturn datetime.to_human_year(value) if isinstance(value, int) else \"null\"\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the YearTransform class.\"\"\"\nreturn \"YearTransform()\"\n</code></pre>"},{"location":"reference/pyiceberg/transforms/#pyiceberg.transforms.YearTransform.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the YearTransform class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/transforms.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the YearTransform class.\"\"\"\nreturn \"YearTransform()\"\n</code></pre>"},{"location":"reference/pyiceberg/typedef/","title":"typedef","text":""},{"location":"reference/pyiceberg/typedef/#pyiceberg.typedef.FrozenDict","title":"<code>FrozenDict</code>","text":"<p>         Bases: <code>Dict[Any, Any]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/typedef.py</code> <pre><code>class FrozenDict(Dict[Any, Any]):\ndef __setitem__(self, instance: Any, value: Any) -&gt; None:\n\"\"\"Used for assigning a value to a FrozenDict.\"\"\"\nraise AttributeError(\"FrozenDict does not support assignment\")\ndef update(self, *args: Any, **kwargs: Any) -&gt; None:\nraise AttributeError(\"FrozenDict does not support .update()\")\n</code></pre>"},{"location":"reference/pyiceberg/typedef/#pyiceberg.typedef.FrozenDict.__setitem__","title":"<code>__setitem__(instance, value)</code>","text":"<p>Used for assigning a value to a FrozenDict.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/typedef.py</code> <pre><code>def __setitem__(self, instance: Any, value: Any) -&gt; None:\n\"\"\"Used for assigning a value to a FrozenDict.\"\"\"\nraise AttributeError(\"FrozenDict does not support assignment\")\n</code></pre>"},{"location":"reference/pyiceberg/typedef/#pyiceberg.typedef.IcebergBaseModel","title":"<code>IcebergBaseModel</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>This class extends the Pydantic BaseModel to set default values by overriding them.</p> <p>This is because we always want to set by_alias to True. In Python, the dash can't be used in variable names, and this is used throughout the Iceberg spec.</p> <p>The same goes for exclude_none, if a field is None we want to omit it from serialization, for example, the doc attribute on the NestedField object. Default non-null values will be serialized.</p> <p>This is recommended by Pydantic: https://pydantic-docs.helpmanual.io/usage/model_config/#change-behaviour-globally</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/typedef.py</code> <pre><code>class IcebergBaseModel(BaseModel):\n\"\"\"\n    This class extends the Pydantic BaseModel to set default values by overriding them.\n    This is because we always want to set by_alias to True. In Python, the dash can't\n    be used in variable names, and this is used throughout the Iceberg spec.\n    The same goes for exclude_none, if a field is None we want to omit it from\n    serialization, for example, the doc attribute on the NestedField object.\n    Default non-null values will be serialized.\n    This is recommended by Pydantic:\n    https://pydantic-docs.helpmanual.io/usage/model_config/#change-behaviour-globally\n    \"\"\"\nclass Config:\nkeep_untouched = (cached_property,)\nallow_population_by_field_name = True\nfrozen = True\ndef _exclude_private_properties(self, exclude: Optional[Set[str]] = None) -&gt; Set[str]:\n# A small trick to exclude private properties. Properties are serialized by pydantic,\n# regardless if they start with an underscore.\n# This will look at the dict, and find the fields and exclude them\nreturn set.union(\n{field for field in self.__dict__ if field.startswith(\"_\") and not field == \"__root__\"}, exclude or set()\n)\ndef dict(self, exclude_none: bool = True, exclude: Optional[Set[str]] = None, **kwargs: Any) -&gt; Dict[str, Any]:\nreturn super().dict(exclude_none=exclude_none, exclude=self._exclude_private_properties(exclude), **kwargs)\ndef json(self, exclude_none: bool = True, exclude: Optional[Set[str]] = None, by_alias: bool = True, **kwargs: Any) -&gt; str:\nreturn super().json(\nexclude_none=exclude_none, exclude=self._exclude_private_properties(exclude), by_alias=by_alias, **kwargs\n)\n</code></pre>"},{"location":"reference/pyiceberg/typedef/#pyiceberg.typedef.KeyDefaultDict","title":"<code>KeyDefaultDict</code>","text":"<p>         Bases: <code>Dict[K, V]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/typedef.py</code> <pre><code>class KeyDefaultDict(Dict[K, V]):\ndef __init__(self, default_factory: Callable[[K], V]):\nsuper().__init__()\nself.default_factory = default_factory\ndef __missing__(self, key: K) -&gt; V:\n\"\"\"Defines behavior if you access a non-existent key in a KeyDefaultDict.\"\"\"\nval = self.default_factory(key)\nself[key] = val\nreturn val\n</code></pre>"},{"location":"reference/pyiceberg/typedef/#pyiceberg.typedef.KeyDefaultDict.__missing__","title":"<code>__missing__(key)</code>","text":"<p>Defines behavior if you access a non-existent key in a KeyDefaultDict.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/typedef.py</code> <pre><code>def __missing__(self, key: K) -&gt; V:\n\"\"\"Defines behavior if you access a non-existent key in a KeyDefaultDict.\"\"\"\nval = self.default_factory(key)\nself[key] = val\nreturn val\n</code></pre>"},{"location":"reference/pyiceberg/typedef/#pyiceberg.typedef.Record","title":"<code>Record</code>","text":"<p>         Bases: <code>StructProtocol</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/typedef.py</code> <pre><code>class Record(StructProtocol):\n_position_to_field_name: Dict[int, str]\ndef __init__(self, *data: Any, struct: Optional[StructType] = None, **named_data: Any) -&gt; None:\nif struct is not None:\nself._position_to_field_name = {idx: field.name for idx, field in enumerate(struct.fields)}\nelif named_data:\n# Order of named_data is preserved (PEP 468) so this can be used to generate the position dict\nself._position_to_field_name = dict(enumerate(named_data.keys()))\nelse:\nself._position_to_field_name = {idx: f\"field{idx + 1}\" for idx in range(len(data))}\nfor idx, d in enumerate(data):\nself[idx] = d\nfor field_name, d in named_data.items():\nself.__setattr__(field_name, d)\ndef __setitem__(self, pos: int, value: Any) -&gt; None:\n\"\"\"Used for assigning a value to a Record.\"\"\"\nself.__setattr__(self._position_to_field_name[pos], value)\ndef __getitem__(self, pos: int) -&gt; Any:\n\"\"\"Used for fetching a value from a Record.\"\"\"\nreturn self.__getattribute__(self._position_to_field_name[pos])\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the Record class.\"\"\"\nif not isinstance(other, Record):\nreturn False\nreturn self.__dict__ == other.__dict__\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Record class.\"\"\"\nreturn f\"{self.__class__.__name__}[{', '.join(f'{key}={repr(value)}' for key, value in self.__dict__.items() if not key.startswith('_'))}]\"\n</code></pre>"},{"location":"reference/pyiceberg/typedef/#pyiceberg.typedef.Record.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the Record class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/typedef.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the Record class.\"\"\"\nif not isinstance(other, Record):\nreturn False\nreturn self.__dict__ == other.__dict__\n</code></pre>"},{"location":"reference/pyiceberg/typedef/#pyiceberg.typedef.Record.__getitem__","title":"<code>__getitem__(pos)</code>","text":"<p>Used for fetching a value from a Record.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/typedef.py</code> <pre><code>def __getitem__(self, pos: int) -&gt; Any:\n\"\"\"Used for fetching a value from a Record.\"\"\"\nreturn self.__getattribute__(self._position_to_field_name[pos])\n</code></pre>"},{"location":"reference/pyiceberg/typedef/#pyiceberg.typedef.Record.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the Record class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/typedef.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Record class.\"\"\"\nreturn f\"{self.__class__.__name__}[{', '.join(f'{key}={repr(value)}' for key, value in self.__dict__.items() if not key.startswith('_'))}]\"\n</code></pre>"},{"location":"reference/pyiceberg/typedef/#pyiceberg.typedef.Record.__setitem__","title":"<code>__setitem__(pos, value)</code>","text":"<p>Used for assigning a value to a Record.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/typedef.py</code> <pre><code>def __setitem__(self, pos: int, value: Any) -&gt; None:\n\"\"\"Used for assigning a value to a Record.\"\"\"\nself.__setattr__(self._position_to_field_name[pos], value)\n</code></pre>"},{"location":"reference/pyiceberg/typedef/#pyiceberg.typedef.StructProtocol","title":"<code>StructProtocol</code>","text":"<p>         Bases: <code>Protocol</code></p> <p>A generic protocol used by accessors to get and set at positions of an object.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/typedef.py</code> <pre><code>@runtime_checkable\nclass StructProtocol(Protocol):  # pragma: no cover\n\"\"\"A generic protocol used by accessors to get and set at positions of an object.\"\"\"\n@abstractmethod\ndef __getitem__(self, pos: int) -&gt; Any:\n\"\"\"Used for fetching a value from a StructProtocol.\"\"\"\n@abstractmethod\ndef __setitem__(self, pos: int, value: Any) -&gt; None:\n\"\"\"Used for assigning a value to a StructProtocol.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/typedef/#pyiceberg.typedef.StructProtocol.__getitem__","title":"<code>__getitem__(pos)</code>  <code>abstractmethod</code>","text":"<p>Used for fetching a value from a StructProtocol.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/typedef.py</code> <pre><code>@abstractmethod\ndef __getitem__(self, pos: int) -&gt; Any:\n\"\"\"Used for fetching a value from a StructProtocol.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/typedef/#pyiceberg.typedef.StructProtocol.__setitem__","title":"<code>__setitem__(pos, value)</code>  <code>abstractmethod</code>","text":"<p>Used for assigning a value to a StructProtocol.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/typedef.py</code> <pre><code>@abstractmethod\ndef __setitem__(self, pos: int, value: Any) -&gt; None:\n\"\"\"Used for assigning a value to a StructProtocol.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/types/","title":"types","text":"<p>Data types used in describing Iceberg schemas.</p> <p>This module implements the data types described in the Iceberg specification for Iceberg schemas. To describe an Iceberg table schema, these classes can be used in the construction of a StructType instance.</p> Example <p>str(StructType( ...     NestedField(1, \"required_field\", StringType(), True), ...     NestedField(2, \"optional_field\", IntegerType()) ... )) 'struct&lt;1: required_field: optional string, 2: optional_field: optional int&gt;'</p> Notes <ul> <li>https://iceberg.apache.org/#spec/#primitive-types</li> </ul>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.BinaryType","title":"<code>BinaryType</code>","text":"<p>         Bases: <code>PrimitiveType</code></p> <p>A Binary data type in Iceberg can be represented using an instance of this class.</p> <p>Binaries in Iceberg are arbitrary-length byte arrays.</p> Example <p>column_foo = BinaryType() isinstance(column_foo, BinaryType) True column_foo BinaryType()</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class BinaryType(PrimitiveType):\n\"\"\"A Binary data type in Iceberg can be represented using an instance of this class.\n    Binaries in Iceberg are arbitrary-length byte arrays.\n    Example:\n        &gt;&gt;&gt; column_foo = BinaryType()\n        &gt;&gt;&gt; isinstance(column_foo, BinaryType)\n        True\n        &gt;&gt;&gt; column_foo\n        BinaryType()\n    \"\"\"\n__root__ = \"binary\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.BooleanType","title":"<code>BooleanType</code>","text":"<p>         Bases: <code>PrimitiveType</code></p> <p>A boolean data type in Iceberg can be represented using an instance of this class.</p> Example <p>column_foo = BooleanType() isinstance(column_foo, BooleanType) True column_foo BooleanType()</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class BooleanType(PrimitiveType):\n\"\"\"A boolean data type in Iceberg can be represented using an instance of this class.\n    Example:\n        &gt;&gt;&gt; column_foo = BooleanType()\n        &gt;&gt;&gt; isinstance(column_foo, BooleanType)\n        True\n        &gt;&gt;&gt; column_foo\n        BooleanType()\n    \"\"\"\n__root__ = \"boolean\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.DateType","title":"<code>DateType</code>","text":"<p>         Bases: <code>PrimitiveType</code></p> <p>A Date data type in Iceberg can be represented using an instance of this class.</p> <p>Dates in Iceberg are calendar dates without a timezone or time.</p> Example <p>column_foo = DateType() isinstance(column_foo, DateType) True column_foo DateType()</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class DateType(PrimitiveType):\n\"\"\"A Date data type in Iceberg can be represented using an instance of this class.\n    Dates in Iceberg are calendar dates without a timezone or time.\n    Example:\n        &gt;&gt;&gt; column_foo = DateType()\n        &gt;&gt;&gt; isinstance(column_foo, DateType)\n        True\n        &gt;&gt;&gt; column_foo\n        DateType()\n    \"\"\"\n__root__ = \"date\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.DecimalType","title":"<code>DecimalType</code>","text":"<p>         Bases: <code>PrimitiveType</code></p> <p>A fixed data type in Iceberg.</p> Example <p>DecimalType(32, 3) DecimalType(precision=32, scale=3) DecimalType(8, 3) == DecimalType(8, 3) True</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class DecimalType(PrimitiveType):\n\"\"\"A fixed data type in Iceberg.\n    Example:\n        &gt;&gt;&gt; DecimalType(32, 3)\n        DecimalType(precision=32, scale=3)\n        &gt;&gt;&gt; DecimalType(8, 3) == DecimalType(8, 3)\n        True\n    \"\"\"\n__root__: str = Field()\n_precision: int = PrivateAttr()\n_scale: int = PrivateAttr()\n@staticmethod\ndef parse(str_repr: str) -&gt; DecimalType:\nmatches = DECIMAL_REGEX.search(str_repr)\nif matches:\nprecision = int(matches.group(1))\nscale = int(matches.group(2))\nreturn DecimalType(precision, scale)\nelse:\nraise ValueError(f\"Could not parse {str_repr} into a DecimalType\")\ndef __init__(self, precision: int, scale: int):\nsuper().__init__(\n__root__=f\"decimal({precision}, {scale})\",\n)\n# assert precision &lt; scale, \"precision should be smaller than scale\"\nself._precision = precision\nself._scale = scale\n@property\ndef precision(self) -&gt; int:\nreturn self._precision\n@property\ndef scale(self) -&gt; int:\nreturn self._scale\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the DecimalType class.\"\"\"\nreturn f\"DecimalType(precision={self._precision}, scale={self._scale})\"\ndef __getnewargs__(self) -&gt; Tuple[int, int]:\n\"\"\"A magic function for pickling the DecimalType class.\"\"\"\nreturn (self._precision, self._scale)\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.DecimalType.__getnewargs__","title":"<code>__getnewargs__()</code>","text":"<p>A magic function for pickling the DecimalType class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>def __getnewargs__(self) -&gt; Tuple[int, int]:\n\"\"\"A magic function for pickling the DecimalType class.\"\"\"\nreturn (self._precision, self._scale)\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.DecimalType.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the DecimalType class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the DecimalType class.\"\"\"\nreturn f\"DecimalType(precision={self._precision}, scale={self._scale})\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.DoubleType","title":"<code>DoubleType</code>","text":"<p>         Bases: <code>PrimitiveType</code></p> <p>A Double data type in Iceberg can be represented using an instance of this class.</p> <p>Doubles in Iceberg are 64-bit IEEE 754 floating points.</p> Example <p>column_foo = DoubleType() isinstance(column_foo, DoubleType) True column_foo DoubleType()</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class DoubleType(PrimitiveType):\n\"\"\"A Double data type in Iceberg can be represented using an instance of this class.\n    Doubles in Iceberg are 64-bit IEEE 754 floating points.\n    Example:\n        &gt;&gt;&gt; column_foo = DoubleType()\n        &gt;&gt;&gt; isinstance(column_foo, DoubleType)\n        True\n        &gt;&gt;&gt; column_foo\n        DoubleType()\n    \"\"\"\n__root__ = \"double\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.FixedType","title":"<code>FixedType</code>","text":"<p>         Bases: <code>PrimitiveType</code></p> <p>A fixed data type in Iceberg.</p> Example <p>FixedType(8) FixedType(length=8) FixedType(8) == FixedType(8) True FixedType(19) == FixedType(25) False</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class FixedType(PrimitiveType):\n\"\"\"A fixed data type in Iceberg.\n    Example:\n        &gt;&gt;&gt; FixedType(8)\n        FixedType(length=8)\n        &gt;&gt;&gt; FixedType(8) == FixedType(8)\n        True\n        &gt;&gt;&gt; FixedType(19) == FixedType(25)\n        False\n    \"\"\"\n__root__: str = Field()\n_len: int = PrivateAttr()\n@staticmethod\ndef parse(str_repr: str) -&gt; FixedType:\nreturn FixedType(length=FIXED_PARSER.match(str_repr))\ndef __init__(self, length: int):\nsuper().__init__(__root__=f\"fixed[{length}]\")\nself._len = length\ndef __len__(self) -&gt; int:\n\"\"\"Returns the length of an instance of the FixedType class.\"\"\"\nreturn self._len\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the FixedType class.\"\"\"\nreturn f\"FixedType(length={self._len})\"\ndef __getnewargs__(self) -&gt; Tuple[int]:\n\"\"\"A magic function for pickling the FixedType class.\"\"\"\nreturn (self._len,)\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.FixedType.__getnewargs__","title":"<code>__getnewargs__()</code>","text":"<p>A magic function for pickling the FixedType class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>def __getnewargs__(self) -&gt; Tuple[int]:\n\"\"\"A magic function for pickling the FixedType class.\"\"\"\nreturn (self._len,)\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.FixedType.__len__","title":"<code>__len__()</code>","text":"<p>Returns the length of an instance of the FixedType class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Returns the length of an instance of the FixedType class.\"\"\"\nreturn self._len\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.FixedType.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the FixedType class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the FixedType class.\"\"\"\nreturn f\"FixedType(length={self._len})\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.FloatType","title":"<code>FloatType</code>","text":"<p>         Bases: <code>PrimitiveType</code></p> <p>A Float data type in Iceberg can be represented using an instance of this class.</p> <p>Floats in Iceberg are 32-bit IEEE 754 floating points and can be promoted to Doubles.</p> Example <p>column_foo = FloatType() isinstance(column_foo, FloatType) True column_foo FloatType()</p> <p>Attributes:</p> Name Type Description <code>max</code> <code>float</code> <p>The maximum allowed value for Floats, inherited from the canonical Iceberg implementation in Java. (returns <code>3.4028235e38</code>)</p> <code>min</code> <code>float</code> <p>The minimum allowed value for Floats, inherited from the canonical Iceberg implementation in Java (returns <code>-3.4028235e38</code>)</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class FloatType(PrimitiveType):\n\"\"\"A Float data type in Iceberg can be represented using an instance of this class.\n    Floats in Iceberg are 32-bit IEEE 754 floating points and can be promoted to Doubles.\n    Example:\n        &gt;&gt;&gt; column_foo = FloatType()\n        &gt;&gt;&gt; isinstance(column_foo, FloatType)\n        True\n        &gt;&gt;&gt; column_foo\n        FloatType()\n    Attributes:\n        max (float): The maximum allowed value for Floats, inherited from the canonical Iceberg implementation\n            in Java. (returns `3.4028235e38`)\n        min (float): The minimum allowed value for Floats, inherited from the canonical Iceberg implementation\n            in Java (returns `-3.4028235e38`)\n    \"\"\"\nmax: ClassVar[float] = 3.4028235e38\nmin: ClassVar[float] = -3.4028235e38\n__root__ = \"float\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.IcebergType","title":"<code>IcebergType</code>","text":"<p>         Bases: <code>IcebergBaseModel</code>, <code>Singleton</code></p> <p>Base type for all Iceberg Types.</p> Example <p>str(IcebergType()) 'IcebergType()' repr(IcebergType()) 'IcebergType()'</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class IcebergType(IcebergBaseModel, Singleton):\n\"\"\"Base type for all Iceberg Types.\n    Example:\n        &gt;&gt;&gt; str(IcebergType())\n        'IcebergType()'\n        &gt;&gt;&gt; repr(IcebergType())\n        'IcebergType()'\n    \"\"\"\n@classmethod\ndef __get_validators__(cls) -&gt; Generator[AnyCallable, None, None]:\n\"\"\"Called to validate the input of the IcebergType class.\"\"\"\n# one or more validators may be yielded which will be called in the\n# order to validate the input, each validator will receive as an input\n# the value returned from the previous validator\nyield cls.validate\n@classmethod\ndef validate(cls, v: Any) -&gt; IcebergType:\n# When Pydantic is unable to determine the subtype\n# In this case we'll help pydantic a bit by parsing the\n# primitive type ourselves, or pointing it at the correct\n# complex type by looking at the type field\nif isinstance(v, str):\nif v.startswith(\"decimal\"):\nreturn DecimalType.parse(v)\nelif v.startswith(\"fixed\"):\nreturn FixedType.parse(v)\nelse:\nreturn PRIMITIVE_TYPES[v]\nelif isinstance(v, dict):\nif v.get(\"type\") == \"struct\":\nreturn StructType(**v)\nelif v.get(\"type\") == \"list\":\nreturn ListType(**v)\nelif v.get(\"type\") == \"map\":\nreturn MapType(**v)\nelse:\nreturn NestedField(**v)\nelse:\nreturn v\n@property\ndef is_primitive(self) -&gt; bool:\nreturn isinstance(self, PrimitiveType)\n@property\ndef is_struct(self) -&gt; bool:\nreturn isinstance(self, StructType)\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.IcebergType.__get_validators__","title":"<code>__get_validators__()</code>  <code>classmethod</code>","text":"<p>Called to validate the input of the IcebergType class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>@classmethod\ndef __get_validators__(cls) -&gt; Generator[AnyCallable, None, None]:\n\"\"\"Called to validate the input of the IcebergType class.\"\"\"\n# one or more validators may be yielded which will be called in the\n# order to validate the input, each validator will receive as an input\n# the value returned from the previous validator\nyield cls.validate\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.IntegerType","title":"<code>IntegerType</code>","text":"<p>         Bases: <code>PrimitiveType</code></p> <p>An Integer data type in Iceberg can be represented using an instance of this class.</p> <p>Integers in Iceberg are 32-bit signed and can be promoted to Longs.</p> Example <p>column_foo = IntegerType() isinstance(column_foo, IntegerType) True</p> <p>Attributes:</p> Name Type Description <code>max</code> <code>int</code> <p>The maximum allowed value for Integers, inherited from the canonical Iceberg implementation in Java (returns <code>2147483647</code>)</p> <code>min</code> <code>int</code> <p>The minimum allowed value for Integers, inherited from the canonical Iceberg implementation in Java (returns <code>-2147483648</code>)</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class IntegerType(PrimitiveType):\n\"\"\"An Integer data type in Iceberg can be represented using an instance of this class.\n    Integers in Iceberg are 32-bit signed and can be promoted to Longs.\n    Example:\n        &gt;&gt;&gt; column_foo = IntegerType()\n        &gt;&gt;&gt; isinstance(column_foo, IntegerType)\n        True\n    Attributes:\n        max (int): The maximum allowed value for Integers, inherited from the canonical Iceberg implementation\n            in Java (returns `2147483647`)\n        min (int): The minimum allowed value for Integers, inherited from the canonical Iceberg implementation\n            in Java (returns `-2147483648`)\n    \"\"\"\nmax: ClassVar[int] = 2147483647\nmin: ClassVar[int] = -2147483648\n__root__ = \"int\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.ListType","title":"<code>ListType</code>","text":"<p>         Bases: <code>IcebergType</code></p> <p>A list type in Iceberg.</p> Example <p>ListType(element_id=3, element_type=StringType(), element_required=True) ListType(element_id=3, element_type=StringType(), element_required=True)</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class ListType(IcebergType):\n\"\"\"A list type in Iceberg.\n    Example:\n        &gt;&gt;&gt; ListType(element_id=3, element_type=StringType(), element_required=True)\n        ListType(element_id=3, element_type=StringType(), element_required=True)\n    \"\"\"\nclass Config:\nfields = {\"element_field\": {\"exclude\": True}}\ntype: Literal[\"list\"] = \"list\"\nelement_id: int = Field(alias=\"element-id\")\nelement_type: IcebergType = Field(alias=\"element\")\nelement_required: bool = Field(alias=\"element-required\", default=True)\nelement_field: NestedField = Field(init=False, repr=False)\ndef __init__(\nself, element_id: Optional[int] = None, element: Optional[IcebergType] = None, element_required: bool = True, **data: Any\n):\ndata[\"element_id\"] = data[\"element-id\"] if \"element-id\" in data else element_id\ndata[\"element_type\"] = element or data[\"element_type\"]\ndata[\"element_required\"] = data[\"element-required\"] if \"element-required\" in data else element_required\ndata[\"element_field\"] = NestedField(\nname=\"element\",\nrequired=data[\"element_required\"],\nfield_id=data[\"element_id\"],\nfield_type=data[\"element_type\"],\n)\nsuper().__init__(**data)\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the ListType class.\"\"\"\nreturn f\"list&lt;{self.element_type}&gt;\"\ndef __getnewargs__(self) -&gt; Tuple[int, IcebergType, bool]:\n\"\"\"A magic function for pickling the ListType class.\"\"\"\nreturn (self.element_id, self.element_type, self.element_required)\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.ListType.__getnewargs__","title":"<code>__getnewargs__()</code>","text":"<p>A magic function for pickling the ListType class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>def __getnewargs__(self) -&gt; Tuple[int, IcebergType, bool]:\n\"\"\"A magic function for pickling the ListType class.\"\"\"\nreturn (self.element_id, self.element_type, self.element_required)\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.ListType.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the ListType class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the ListType class.\"\"\"\nreturn f\"list&lt;{self.element_type}&gt;\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.LongType","title":"<code>LongType</code>","text":"<p>         Bases: <code>PrimitiveType</code></p> <p>A Long data type in Iceberg can be represented using an instance of this class.</p> <p>Longs in Iceberg are 64-bit signed integers.</p> Example <p>column_foo = LongType() isinstance(column_foo, LongType) True column_foo LongType() str(column_foo) 'long'</p> <p>Attributes:</p> Name Type Description <code>max</code> <code>int</code> <p>The maximum allowed value for Longs, inherited from the canonical Iceberg implementation in Java. (returns <code>9223372036854775807</code>)</p> <code>min</code> <code>int</code> <p>The minimum allowed value for Longs, inherited from the canonical Iceberg implementation in Java (returns <code>-9223372036854775808</code>)</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class LongType(PrimitiveType):\n\"\"\"A Long data type in Iceberg can be represented using an instance of this class.\n    Longs in Iceberg are 64-bit signed integers.\n    Example:\n        &gt;&gt;&gt; column_foo = LongType()\n        &gt;&gt;&gt; isinstance(column_foo, LongType)\n        True\n        &gt;&gt;&gt; column_foo\n        LongType()\n        &gt;&gt;&gt; str(column_foo)\n        'long'\n    Attributes:\n        max (int): The maximum allowed value for Longs, inherited from the canonical Iceberg implementation\n            in Java. (returns `9223372036854775807`)\n        min (int): The minimum allowed value for Longs, inherited from the canonical Iceberg implementation\n            in Java (returns `-9223372036854775808`)\n    \"\"\"\nmax: ClassVar[int] = 9223372036854775807\nmin: ClassVar[int] = -9223372036854775808\n__root__ = \"long\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.MapType","title":"<code>MapType</code>","text":"<p>         Bases: <code>IcebergType</code></p> <p>A map type in Iceberg.</p> Example <p>MapType(key_id=1, key_type=StringType(), value_id=2, value_type=IntegerType(), value_required=True) MapType(key_id=1, key_type=StringType(), value_id=2, value_type=IntegerType(), value_required=True)</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class MapType(IcebergType):\n\"\"\"A map type in Iceberg.\n    Example:\n        &gt;&gt;&gt; MapType(key_id=1, key_type=StringType(), value_id=2, value_type=IntegerType(), value_required=True)\n        MapType(key_id=1, key_type=StringType(), value_id=2, value_type=IntegerType(), value_required=True)\n    \"\"\"\ntype: Literal[\"map\"] = \"map\"\nkey_id: int = Field(alias=\"key-id\")\nkey_type: IcebergType = Field(alias=\"key\")\nvalue_id: int = Field(alias=\"value-id\")\nvalue_type: IcebergType = Field(alias=\"value\")\nvalue_required: bool = Field(alias=\"value-required\", default=True)\nkey_field: NestedField = Field(init=False, repr=False)\nvalue_field: NestedField = Field(init=False, repr=False)\nclass Config:\nfields = {\"key_field\": {\"exclude\": True}, \"value_field\": {\"exclude\": True}}\ndef __init__(\nself,\nkey_id: Optional[int] = None,\nkey_type: Optional[IcebergType] = None,\nvalue_id: Optional[int] = None,\nvalue_type: Optional[IcebergType] = None,\nvalue_required: bool = True,\n**data: Any,\n):\ndata[\"key_id\"] = key_id or data[\"key-id\"]\ndata[\"key_type\"] = key_type or data[\"key\"]\ndata[\"value_id\"] = value_id or data[\"value-id\"]\ndata[\"value_type\"] = value_type or data[\"value\"]\ndata[\"value_required\"] = value_required if value_required is not None else data[\"value_required\"]\ndata[\"key_field\"] = NestedField(name=\"key\", field_id=data[\"key_id\"], field_type=data[\"key_type\"], required=True)\ndata[\"value_field\"] = NestedField(\nname=\"value\", field_id=data[\"value_id\"], field_type=data[\"value_type\"], required=data[\"value_required\"]\n)\nsuper().__init__(**data)\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the MapType class.\"\"\"\nreturn f\"map&lt;{self.key_type}, {self.value_type}&gt;\"\ndef __getnewargs__(self) -&gt; Tuple[int, IcebergType, int, IcebergType, bool]:\n\"\"\"A magic function for pickling the MapType class.\"\"\"\nreturn (self.key_id, self.key_type, self.value_id, self.value_type, self.value_required)\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.MapType.__getnewargs__","title":"<code>__getnewargs__()</code>","text":"<p>A magic function for pickling the MapType class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>def __getnewargs__(self) -&gt; Tuple[int, IcebergType, int, IcebergType, bool]:\n\"\"\"A magic function for pickling the MapType class.\"\"\"\nreturn (self.key_id, self.key_type, self.value_id, self.value_type, self.value_required)\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.MapType.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the MapType class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the MapType class.\"\"\"\nreturn f\"map&lt;{self.key_type}, {self.value_type}&gt;\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.NestedField","title":"<code>NestedField</code>","text":"<p>         Bases: <code>IcebergType</code></p> <p>Represents a field of a struct, a map key, a map value, or a list element.</p> <p>This is where field IDs, names, docs, and nullability are tracked.</p> Example <p>str(NestedField( ...     field_id=1, ...     name='foo', ...     field_type=FixedType(22), ...     required=False, ... )) '1: foo: optional fixed[22]' str(NestedField( ...     field_id=2, ...     name='bar', ...     field_type=LongType(), ...     is_optional=False, ...     doc=\"Just a long\" ... )) '2: bar: required long (Just a long)'</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class NestedField(IcebergType):\n\"\"\"Represents a field of a struct, a map key, a map value, or a list element.\n    This is where field IDs, names, docs, and nullability are tracked.\n    Example:\n        &gt;&gt;&gt; str(NestedField(\n        ...     field_id=1,\n        ...     name='foo',\n        ...     field_type=FixedType(22),\n        ...     required=False,\n        ... ))\n        '1: foo: optional fixed[22]'\n        &gt;&gt;&gt; str(NestedField(\n        ...     field_id=2,\n        ...     name='bar',\n        ...     field_type=LongType(),\n        ...     is_optional=False,\n        ...     doc=\"Just a long\"\n        ... ))\n        '2: bar: required long (Just a long)'\n    \"\"\"\nfield_id: int = Field(alias=\"id\")\nname: str = Field()\nfield_type: IcebergType = Field(alias=\"type\")\nrequired: bool = Field(default=True)\ndoc: Optional[str] = Field(default=None, repr=False)\ninitial_default: Any = Field(alias=\"initial-default\", repr=False)\ndef __init__(\nself,\nfield_id: Optional[int] = None,\nname: Optional[str] = None,\nfield_type: Optional[IcebergType] = None,\nrequired: bool = True,\ndoc: Optional[str] = None,\ninitial_default: Optional[Any] = None,\n**data: Any,\n):\n# We need an init when we want to use positional arguments, but\n# need also to support the aliases.\ndata[\"field_id\"] = data[\"id\"] if \"id\" in data else field_id\ndata[\"name\"] = name\ndata[\"field_type\"] = data[\"type\"] if \"type\" in data else field_type\ndata[\"required\"] = required\ndata[\"doc\"] = doc\ndata[\"initial_default\"] = initial_default\nsuper().__init__(**data)\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the NestedField class.\"\"\"\ndoc = \"\" if not self.doc else f\" ({self.doc})\"\nreq = \"required\" if self.required else \"optional\"\nreturn f\"{self.field_id}: {self.name}: {req} {self.field_type}{doc}\"\ndef __getnewargs__(self) -&gt; Tuple[int, str, IcebergType, bool, Optional[str]]:\n\"\"\"A magic function for pickling the NestedField class.\"\"\"\nreturn (self.field_id, self.name, self.field_type, self.required, self.doc)\n@property\ndef optional(self) -&gt; bool:\nreturn not self.required\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.NestedField.__getnewargs__","title":"<code>__getnewargs__()</code>","text":"<p>A magic function for pickling the NestedField class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>def __getnewargs__(self) -&gt; Tuple[int, str, IcebergType, bool, Optional[str]]:\n\"\"\"A magic function for pickling the NestedField class.\"\"\"\nreturn (self.field_id, self.name, self.field_type, self.required, self.doc)\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.NestedField.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the NestedField class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the NestedField class.\"\"\"\ndoc = \"\" if not self.doc else f\" ({self.doc})\"\nreq = \"required\" if self.required else \"optional\"\nreturn f\"{self.field_id}: {self.name}: {req} {self.field_type}{doc}\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.PrimitiveType","title":"<code>PrimitiveType</code>","text":"<p>         Bases: <code>IcebergType</code></p> <p>Base class for all Iceberg Primitive Types.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class PrimitiveType(IcebergType):\n\"\"\"Base class for all Iceberg Primitive Types.\"\"\"\n__root__: str = Field()\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the PrimitiveType class.\"\"\"\nreturn f\"{type(self).__name__}()\"\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the PrimitiveType class.\"\"\"\nreturn self.__root__\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.PrimitiveType.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the PrimitiveType class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the PrimitiveType class.\"\"\"\nreturn f\"{type(self).__name__}()\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.PrimitiveType.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the PrimitiveType class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the PrimitiveType class.\"\"\"\nreturn self.__root__\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.StringType","title":"<code>StringType</code>","text":"<p>         Bases: <code>PrimitiveType</code></p> <p>A String data type in Iceberg can be represented using an instance of this class.</p> <p>Strings in Iceberg are arbitrary-length character sequences and are encoded with UTF-8.</p> Example <p>column_foo = StringType() isinstance(column_foo, StringType) True column_foo StringType()</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class StringType(PrimitiveType):\n\"\"\"A String data type in Iceberg can be represented using an instance of this class.\n    Strings in Iceberg are arbitrary-length character sequences and are encoded with UTF-8.\n    Example:\n        &gt;&gt;&gt; column_foo = StringType()\n        &gt;&gt;&gt; isinstance(column_foo, StringType)\n        True\n        &gt;&gt;&gt; column_foo\n        StringType()\n    \"\"\"\n__root__ = \"string\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.StructType","title":"<code>StructType</code>","text":"<p>         Bases: <code>IcebergType</code></p> <p>A struct type in Iceberg.</p> Example <p>str(StructType( ...     NestedField(1, \"required_field\", StringType(), True), ...     NestedField(2, \"optional_field\", IntegerType()) ... )) 'struct&lt;1: required_field: optional string, 2: optional_field: optional int&gt;'</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class StructType(IcebergType):\n\"\"\"A struct type in Iceberg.\n    Example:\n        &gt;&gt;&gt; str(StructType(\n        ...     NestedField(1, \"required_field\", StringType(), True),\n        ...     NestedField(2, \"optional_field\", IntegerType())\n        ... ))\n        'struct&lt;1: required_field: optional string, 2: optional_field: optional int&gt;'\n    \"\"\"\ntype: Literal[\"struct\"] = \"struct\"\nfields: Tuple[NestedField, ...] = Field(default_factory=tuple)\ndef __init__(self, *fields: NestedField, **data: Any):\n# In case we use positional arguments, instead of keyword args\nif fields:\ndata[\"fields\"] = fields\nsuper().__init__(**data)\ndef field(self, field_id: int) -&gt; Optional[NestedField]:\nfor field in self.fields:\nif field.field_id == field_id:\nreturn field\nreturn None\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the StructType class.\"\"\"\nreturn f\"struct&lt;{', '.join(map(str, self.fields))}&gt;\"\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the StructType class.\"\"\"\nreturn f\"StructType(fields=({', '.join(map(repr, self.fields))},))\"\ndef __len__(self) -&gt; int:\n\"\"\"Returns the length of an instance of the StructType class.\"\"\"\nreturn len(self.fields)\ndef __getnewargs__(self) -&gt; Tuple[NestedField, ...]:\n\"\"\"A magic function for pickling the StructType class.\"\"\"\nreturn self.fields\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.StructType.__getnewargs__","title":"<code>__getnewargs__()</code>","text":"<p>A magic function for pickling the StructType class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>def __getnewargs__(self) -&gt; Tuple[NestedField, ...]:\n\"\"\"A magic function for pickling the StructType class.\"\"\"\nreturn self.fields\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.StructType.__len__","title":"<code>__len__()</code>","text":"<p>Returns the length of an instance of the StructType class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Returns the length of an instance of the StructType class.\"\"\"\nreturn len(self.fields)\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.StructType.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the StructType class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the StructType class.\"\"\"\nreturn f\"StructType(fields=({', '.join(map(repr, self.fields))},))\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.StructType.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the StructType class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the StructType class.\"\"\"\nreturn f\"struct&lt;{', '.join(map(str, self.fields))}&gt;\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.TimeType","title":"<code>TimeType</code>","text":"<p>         Bases: <code>PrimitiveType</code></p> <p>A Time data type in Iceberg can be represented using an instance of this class.</p> <p>Times in Iceberg have microsecond precision and are a time of day without a date or timezone.</p> Example <p>column_foo = TimeType() isinstance(column_foo, TimeType) True column_foo TimeType()</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class TimeType(PrimitiveType):\n\"\"\"A Time data type in Iceberg can be represented using an instance of this class.\n    Times in Iceberg have microsecond precision and are a time of day without a date or timezone.\n    Example:\n        &gt;&gt;&gt; column_foo = TimeType()\n        &gt;&gt;&gt; isinstance(column_foo, TimeType)\n        True\n        &gt;&gt;&gt; column_foo\n        TimeType()\n    \"\"\"\n__root__ = \"time\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.TimestampType","title":"<code>TimestampType</code>","text":"<p>         Bases: <code>PrimitiveType</code></p> <p>A Timestamp data type in Iceberg can be represented using an instance of this class.</p> <p>Timestamps in Iceberg have microsecond precision and include a date and a time of day without a timezone.</p> Example <p>column_foo = TimestampType() isinstance(column_foo, TimestampType) True column_foo TimestampType()</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class TimestampType(PrimitiveType):\n\"\"\"A Timestamp data type in Iceberg can be represented using an instance of this class.\n    Timestamps in Iceberg have microsecond precision and include a date and a time of day without a timezone.\n    Example:\n        &gt;&gt;&gt; column_foo = TimestampType()\n        &gt;&gt;&gt; isinstance(column_foo, TimestampType)\n        True\n        &gt;&gt;&gt; column_foo\n        TimestampType()\n    \"\"\"\n__root__ = \"timestamp\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.TimestamptzType","title":"<code>TimestamptzType</code>","text":"<p>         Bases: <code>PrimitiveType</code></p> <p>A Timestamptz data type in Iceberg can be represented using an instance of this class.</p> <p>Timestamptzs in Iceberg are stored as UTC and include a date and a time of day with a timezone.</p> Example <p>column_foo = TimestamptzType() isinstance(column_foo, TimestamptzType) True column_foo TimestamptzType()</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class TimestamptzType(PrimitiveType):\n\"\"\"A Timestamptz data type in Iceberg can be represented using an instance of this class.\n    Timestamptzs in Iceberg are stored as UTC and include a date and a time of day with a timezone.\n    Example:\n        &gt;&gt;&gt; column_foo = TimestamptzType()\n        &gt;&gt;&gt; isinstance(column_foo, TimestamptzType)\n        True\n        &gt;&gt;&gt; column_foo\n        TimestamptzType()\n    \"\"\"\n__root__ = \"timestamptz\"\n</code></pre>"},{"location":"reference/pyiceberg/types/#pyiceberg.types.UUIDType","title":"<code>UUIDType</code>","text":"<p>         Bases: <code>PrimitiveType</code></p> <p>A UUID data type in Iceberg can be represented using an instance of this class.</p> <p>UUIDs in Iceberg are universally unique identifiers.</p> Example <p>column_foo = UUIDType() isinstance(column_foo, UUIDType) True column_foo UUIDType()</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/types.py</code> <pre><code>class UUIDType(PrimitiveType):\n\"\"\"A UUID data type in Iceberg can be represented using an instance of this class.\n    UUIDs in Iceberg are universally unique identifiers.\n    Example:\n        &gt;&gt;&gt; column_foo = UUIDType()\n        &gt;&gt;&gt; isinstance(column_foo, UUIDType)\n        True\n        &gt;&gt;&gt; column_foo\n        UUIDType()\n    \"\"\"\n__root__ = \"uuid\"\n</code></pre>"},{"location":"reference/pyiceberg/avro/","title":"avro","text":""},{"location":"reference/pyiceberg/avro/decoder/","title":"decoder","text":""},{"location":"reference/pyiceberg/avro/decoder/#pyiceberg.avro.decoder.BinaryDecoder","title":"<code>BinaryDecoder</code>","text":"<p>Read leaf values.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/decoder.py</code> <pre><code>class BinaryDecoder:\n\"\"\"Read leaf values.\"\"\"\n_input_stream: InputStream\ndef __init__(self, input_stream: InputStream) -&gt; None:\n\"\"\"Reader is a Python object on which we can call read, seek, and tell.\"\"\"\nself._input_stream = input_stream\ndef read(self, n: int) -&gt; bytes:\n\"\"\"Read n bytes.\"\"\"\nif n &lt; 0:\nraise ValueError(f\"Requested {n} bytes to read, expected positive integer.\")\ndata: List[bytes] = []\nn_remaining = n\nwhile n_remaining &gt; 0:\ndata_read = self._input_stream.read(n_remaining)\nread_len = len(data_read)\nif read_len == n:\n# If we read everything, we return directly\n# otherwise we'll continue to fetch the rest\nreturn data_read\nelif read_len &lt;= 0:\nraise EOFError(f\"EOF: read {read_len} bytes\")\ndata.append(data_read)\nn_remaining -= read_len\nreturn b\"\".join(data)\ndef skip(self, n: int) -&gt; None:\nself._input_stream.seek(n, SEEK_CUR)\ndef read_boolean(self) -&gt; bool:\n\"\"\"Reads a value from the stream as a boolean.\n        A boolean is written as a single byte\n        whose value is either 0 (false) or 1 (true).\n        \"\"\"\nreturn ord(self.read(1)) == 1\ndef read_int(self) -&gt; int:\n\"\"\"Reads a value from the stream as an integer.\n        int/long values are written using variable-length, zigzag coding.\n        \"\"\"\nb = ord(self.read(1))\nn = b &amp; 0x7F\nshift = 7\nwhile (b &amp; 0x80) != 0:\nb = ord(self.read(1))\nn |= (b &amp; 0x7F) &lt;&lt; shift\nshift += 7\ndatum = (n &gt;&gt; 1) ^ -(n &amp; 1)\nreturn datum\ndef read_float(self) -&gt; float:\n\"\"\"Reads a value from the stream as a float.\n        A float is written as 4 bytes.\n        The float is converted into a 32-bit integer using a method equivalent to\n        Java's floatToIntBits and then encoded in little-endian format.\n        \"\"\"\nreturn float(STRUCT_FLOAT.unpack(self.read(4))[0])\ndef read_double(self) -&gt; float:\n\"\"\"Reads a value from the stream as a double.\n        A double is written as 8 bytes.\n        The double is converted into a 64-bit integer using a method equivalent to\n        Java's doubleToLongBits and then encoded in little-endian format.\n        \"\"\"\nreturn float(STRUCT_DOUBLE.unpack(self.read(8))[0])\ndef read_decimal_from_bytes(self, precision: int, scale: int) -&gt; decimal.Decimal:\n\"\"\"Reads a value from the stream as a decimal.\n        Decimal bytes are decoded as signed short, int or long depending on the\n        size of bytes.\n        \"\"\"\nsize = self.read_int()\nreturn self.read_decimal_from_fixed(precision, scale, size)\ndef read_decimal_from_fixed(self, _: int, scale: int, size: int) -&gt; decimal.Decimal:\n\"\"\"Reads a value from the stream as a decimal.\n        Decimal is encoded as fixed. Fixed instances are encoded using the\n        number of bytes declared in the schema.\n        \"\"\"\ndata = self.read(size)\nunscaled_datum = int.from_bytes(data, byteorder=\"big\", signed=True)\nreturn unscaled_to_decimal(unscaled_datum, scale)\ndef read_bytes(self) -&gt; bytes:\n\"\"\"Bytes are encoded as a long followed by that many bytes of data.\"\"\"\nnum_bytes = self.read_int()\nreturn self.read(num_bytes) if num_bytes &gt; 0 else b\"\"\ndef read_utf8(self) -&gt; str:\n\"\"\"Reads a utf-8 encoded string from the stream.\n        A string is encoded as a long followed by\n        that many bytes of UTF-8 encoded character data.\n        \"\"\"\nreturn self.read_bytes().decode(\"utf-8\")\ndef read_uuid_from_fixed(self) -&gt; UUID:\n\"\"\"Reads a UUID as a fixed[16].\"\"\"\nreturn UUID(bytes=self.read(16))\ndef read_time_millis(self) -&gt; time:\n\"\"\"Reads a milliseconds granularity time from the stream.\n        Int is decoded as python time object which represents\n        the number of milliseconds after midnight, 00:00:00.000.\n        \"\"\"\nmillis = self.read_int()\nreturn micros_to_time(millis * 1000)\ndef read_time_micros(self) -&gt; time:\n\"\"\"Reads a microseconds granularity time from the stream.\n        Long is decoded as python time object which represents\n        the number of microseconds after midnight, 00:00:00.000000.\n        \"\"\"\nreturn micros_to_time(self.read_int())\ndef read_timestamp_micros(self) -&gt; datetime:\n\"\"\"Reads a microsecond granularity timestamp from the stream.\n        Long is decoded as python datetime object which represents\n        the number of microseconds from the unix epoch, 1 January 1970.\n        \"\"\"\nreturn micros_to_timestamp(self.read_int())\ndef read_timestamptz_micros(self) -&gt; datetime:\n\"\"\"Reads a microsecond granularity timestamptz from the stream.\n        Long is decoded as python datetime object which represents\n        the number of microseconds from the unix epoch, 1 January 1970.\n        Adjusted to UTC.\n        \"\"\"\nreturn micros_to_timestamptz(self.read_int())\ndef skip_boolean(self) -&gt; None:\nself.skip(1)\ndef skip_int(self) -&gt; None:\nb = ord(self.read(1))\nwhile (b &amp; 0x80) != 0:\nb = ord(self.read(1))\ndef skip_float(self) -&gt; None:\nself.skip(4)\ndef skip_double(self) -&gt; None:\nself.skip(8)\ndef skip_bytes(self) -&gt; None:\nself.skip(self.read_int())\ndef skip_utf8(self) -&gt; None:\nself.skip_bytes()\n</code></pre>"},{"location":"reference/pyiceberg/avro/decoder/#pyiceberg.avro.decoder.BinaryDecoder.__init__","title":"<code>__init__(input_stream)</code>","text":"<p>Reader is a Python object on which we can call read, seek, and tell.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/decoder.py</code> <pre><code>def __init__(self, input_stream: InputStream) -&gt; None:\n\"\"\"Reader is a Python object on which we can call read, seek, and tell.\"\"\"\nself._input_stream = input_stream\n</code></pre>"},{"location":"reference/pyiceberg/avro/decoder/#pyiceberg.avro.decoder.BinaryDecoder.read","title":"<code>read(n)</code>","text":"<p>Read n bytes.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/decoder.py</code> <pre><code>def read(self, n: int) -&gt; bytes:\n\"\"\"Read n bytes.\"\"\"\nif n &lt; 0:\nraise ValueError(f\"Requested {n} bytes to read, expected positive integer.\")\ndata: List[bytes] = []\nn_remaining = n\nwhile n_remaining &gt; 0:\ndata_read = self._input_stream.read(n_remaining)\nread_len = len(data_read)\nif read_len == n:\n# If we read everything, we return directly\n# otherwise we'll continue to fetch the rest\nreturn data_read\nelif read_len &lt;= 0:\nraise EOFError(f\"EOF: read {read_len} bytes\")\ndata.append(data_read)\nn_remaining -= read_len\nreturn b\"\".join(data)\n</code></pre>"},{"location":"reference/pyiceberg/avro/decoder/#pyiceberg.avro.decoder.BinaryDecoder.read_boolean","title":"<code>read_boolean()</code>","text":"<p>Reads a value from the stream as a boolean.</p> <p>A boolean is written as a single byte whose value is either 0 (false) or 1 (true).</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/decoder.py</code> <pre><code>def read_boolean(self) -&gt; bool:\n\"\"\"Reads a value from the stream as a boolean.\n    A boolean is written as a single byte\n    whose value is either 0 (false) or 1 (true).\n    \"\"\"\nreturn ord(self.read(1)) == 1\n</code></pre>"},{"location":"reference/pyiceberg/avro/decoder/#pyiceberg.avro.decoder.BinaryDecoder.read_bytes","title":"<code>read_bytes()</code>","text":"<p>Bytes are encoded as a long followed by that many bytes of data.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/decoder.py</code> <pre><code>def read_bytes(self) -&gt; bytes:\n\"\"\"Bytes are encoded as a long followed by that many bytes of data.\"\"\"\nnum_bytes = self.read_int()\nreturn self.read(num_bytes) if num_bytes &gt; 0 else b\"\"\n</code></pre>"},{"location":"reference/pyiceberg/avro/decoder/#pyiceberg.avro.decoder.BinaryDecoder.read_decimal_from_bytes","title":"<code>read_decimal_from_bytes(precision, scale)</code>","text":"<p>Reads a value from the stream as a decimal.</p> <p>Decimal bytes are decoded as signed short, int or long depending on the size of bytes.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/decoder.py</code> <pre><code>def read_decimal_from_bytes(self, precision: int, scale: int) -&gt; decimal.Decimal:\n\"\"\"Reads a value from the stream as a decimal.\n    Decimal bytes are decoded as signed short, int or long depending on the\n    size of bytes.\n    \"\"\"\nsize = self.read_int()\nreturn self.read_decimal_from_fixed(precision, scale, size)\n</code></pre>"},{"location":"reference/pyiceberg/avro/decoder/#pyiceberg.avro.decoder.BinaryDecoder.read_decimal_from_fixed","title":"<code>read_decimal_from_fixed(_, scale, size)</code>","text":"<p>Reads a value from the stream as a decimal.</p> <p>Decimal is encoded as fixed. Fixed instances are encoded using the number of bytes declared in the schema.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/decoder.py</code> <pre><code>def read_decimal_from_fixed(self, _: int, scale: int, size: int) -&gt; decimal.Decimal:\n\"\"\"Reads a value from the stream as a decimal.\n    Decimal is encoded as fixed. Fixed instances are encoded using the\n    number of bytes declared in the schema.\n    \"\"\"\ndata = self.read(size)\nunscaled_datum = int.from_bytes(data, byteorder=\"big\", signed=True)\nreturn unscaled_to_decimal(unscaled_datum, scale)\n</code></pre>"},{"location":"reference/pyiceberg/avro/decoder/#pyiceberg.avro.decoder.BinaryDecoder.read_double","title":"<code>read_double()</code>","text":"<p>Reads a value from the stream as a double.</p> <p>A double is written as 8 bytes. The double is converted into a 64-bit integer using a method equivalent to Java's doubleToLongBits and then encoded in little-endian format.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/decoder.py</code> <pre><code>def read_double(self) -&gt; float:\n\"\"\"Reads a value from the stream as a double.\n    A double is written as 8 bytes.\n    The double is converted into a 64-bit integer using a method equivalent to\n    Java's doubleToLongBits and then encoded in little-endian format.\n    \"\"\"\nreturn float(STRUCT_DOUBLE.unpack(self.read(8))[0])\n</code></pre>"},{"location":"reference/pyiceberg/avro/decoder/#pyiceberg.avro.decoder.BinaryDecoder.read_float","title":"<code>read_float()</code>","text":"<p>Reads a value from the stream as a float.</p> <p>A float is written as 4 bytes. The float is converted into a 32-bit integer using a method equivalent to Java's floatToIntBits and then encoded in little-endian format.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/decoder.py</code> <pre><code>def read_float(self) -&gt; float:\n\"\"\"Reads a value from the stream as a float.\n    A float is written as 4 bytes.\n    The float is converted into a 32-bit integer using a method equivalent to\n    Java's floatToIntBits and then encoded in little-endian format.\n    \"\"\"\nreturn float(STRUCT_FLOAT.unpack(self.read(4))[0])\n</code></pre>"},{"location":"reference/pyiceberg/avro/decoder/#pyiceberg.avro.decoder.BinaryDecoder.read_int","title":"<code>read_int()</code>","text":"<p>Reads a value from the stream as an integer.</p> <p>int/long values are written using variable-length, zigzag coding.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/decoder.py</code> <pre><code>def read_int(self) -&gt; int:\n\"\"\"Reads a value from the stream as an integer.\n    int/long values are written using variable-length, zigzag coding.\n    \"\"\"\nb = ord(self.read(1))\nn = b &amp; 0x7F\nshift = 7\nwhile (b &amp; 0x80) != 0:\nb = ord(self.read(1))\nn |= (b &amp; 0x7F) &lt;&lt; shift\nshift += 7\ndatum = (n &gt;&gt; 1) ^ -(n &amp; 1)\nreturn datum\n</code></pre>"},{"location":"reference/pyiceberg/avro/decoder/#pyiceberg.avro.decoder.BinaryDecoder.read_time_micros","title":"<code>read_time_micros()</code>","text":"<p>Reads a microseconds granularity time from the stream.</p> <p>Long is decoded as python time object which represents the number of microseconds after midnight, 00:00:00.000000.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/decoder.py</code> <pre><code>def read_time_micros(self) -&gt; time:\n\"\"\"Reads a microseconds granularity time from the stream.\n    Long is decoded as python time object which represents\n    the number of microseconds after midnight, 00:00:00.000000.\n    \"\"\"\nreturn micros_to_time(self.read_int())\n</code></pre>"},{"location":"reference/pyiceberg/avro/decoder/#pyiceberg.avro.decoder.BinaryDecoder.read_time_millis","title":"<code>read_time_millis()</code>","text":"<p>Reads a milliseconds granularity time from the stream.</p> <p>Int is decoded as python time object which represents the number of milliseconds after midnight, 00:00:00.000.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/decoder.py</code> <pre><code>def read_time_millis(self) -&gt; time:\n\"\"\"Reads a milliseconds granularity time from the stream.\n    Int is decoded as python time object which represents\n    the number of milliseconds after midnight, 00:00:00.000.\n    \"\"\"\nmillis = self.read_int()\nreturn micros_to_time(millis * 1000)\n</code></pre>"},{"location":"reference/pyiceberg/avro/decoder/#pyiceberg.avro.decoder.BinaryDecoder.read_timestamp_micros","title":"<code>read_timestamp_micros()</code>","text":"<p>Reads a microsecond granularity timestamp from the stream.</p> <p>Long is decoded as python datetime object which represents the number of microseconds from the unix epoch, 1 January 1970.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/decoder.py</code> <pre><code>def read_timestamp_micros(self) -&gt; datetime:\n\"\"\"Reads a microsecond granularity timestamp from the stream.\n    Long is decoded as python datetime object which represents\n    the number of microseconds from the unix epoch, 1 January 1970.\n    \"\"\"\nreturn micros_to_timestamp(self.read_int())\n</code></pre>"},{"location":"reference/pyiceberg/avro/decoder/#pyiceberg.avro.decoder.BinaryDecoder.read_timestamptz_micros","title":"<code>read_timestamptz_micros()</code>","text":"<p>Reads a microsecond granularity timestamptz from the stream.</p> <p>Long is decoded as python datetime object which represents the number of microseconds from the unix epoch, 1 January 1970.</p> <p>Adjusted to UTC.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/decoder.py</code> <pre><code>def read_timestamptz_micros(self) -&gt; datetime:\n\"\"\"Reads a microsecond granularity timestamptz from the stream.\n    Long is decoded as python datetime object which represents\n    the number of microseconds from the unix epoch, 1 January 1970.\n    Adjusted to UTC.\n    \"\"\"\nreturn micros_to_timestamptz(self.read_int())\n</code></pre>"},{"location":"reference/pyiceberg/avro/decoder/#pyiceberg.avro.decoder.BinaryDecoder.read_utf8","title":"<code>read_utf8()</code>","text":"<p>Reads a utf-8 encoded string from the stream.</p> <p>A string is encoded as a long followed by that many bytes of UTF-8 encoded character data.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/decoder.py</code> <pre><code>def read_utf8(self) -&gt; str:\n\"\"\"Reads a utf-8 encoded string from the stream.\n    A string is encoded as a long followed by\n    that many bytes of UTF-8 encoded character data.\n    \"\"\"\nreturn self.read_bytes().decode(\"utf-8\")\n</code></pre>"},{"location":"reference/pyiceberg/avro/decoder/#pyiceberg.avro.decoder.BinaryDecoder.read_uuid_from_fixed","title":"<code>read_uuid_from_fixed()</code>","text":"<p>Reads a UUID as a fixed[16].</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/decoder.py</code> <pre><code>def read_uuid_from_fixed(self) -&gt; UUID:\n\"\"\"Reads a UUID as a fixed[16].\"\"\"\nreturn UUID(bytes=self.read(16))\n</code></pre>"},{"location":"reference/pyiceberg/avro/file/","title":"file","text":"<p>Avro reader for reading Avro files.</p>"},{"location":"reference/pyiceberg/avro/file/#pyiceberg.avro.file.AvroFile","title":"<code>AvroFile</code>","text":"<p>         Bases: <code>Generic[D]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/file.py</code> <pre><code>class AvroFile(Generic[D]):\ninput_file: InputFile\nread_schema: Optional[Schema]\nread_types: Dict[int, Callable[..., StructProtocol]]\nread_enums: Dict[int, Callable[..., Enum]]\ninput_stream: InputStream\nheader: AvroFileHeader\nschema: Schema\nreader: Reader\ndecoder: BinaryDecoder\nblock: Optional[Block[D]] = None\ndef __init__(\nself,\ninput_file: InputFile,\nread_schema: Optional[Schema] = None,\nread_types: Dict[int, Callable[..., StructProtocol]] = EMPTY_DICT,\nread_enums: Dict[int, Callable[..., Enum]] = EMPTY_DICT,\n) -&gt; None:\nself.input_file = input_file\nself.read_schema = read_schema\nself.read_types = read_types\nself.read_enums = read_enums\ndef __enter__(self) -&gt; AvroFile[D]:\n\"\"\"Generates a reader tree for the payload within an avro file.\n        Returns:\n            A generator returning the AvroStructs\n        \"\"\"\nself.input_stream = self.input_file.open(seekable=False)\nself.decoder = BinaryDecoder(self.input_stream)\nself.header = self._read_header()\nself.schema = self.header.get_schema()\nif not self.read_schema:\nself.read_schema = self.schema\nself.reader = resolve(self.schema, self.read_schema, self.read_types, self.read_enums)\nreturn self\ndef __exit__(\nself, exctype: Optional[Type[BaseException]], excinst: Optional[BaseException], exctb: Optional[TracebackType]\n) -&gt; None:\n\"\"\"Performs cleanup when exiting the scope of a 'with' statement.\"\"\"\nself.input_stream.close()\ndef __iter__(self) -&gt; AvroFile[D]:\n\"\"\"Returns an iterator for the AvroFile class.\"\"\"\nreturn self\ndef _read_block(self) -&gt; int:\n# If there is already a block, we'll have the sync bytes\nif self.block:\nsync_marker = self.decoder.read(SYNC_SIZE)\nif sync_marker != self.header.sync:\nraise ValueError(f\"Expected sync bytes {self.header.sync!r}, but got {sync_marker!r}\")\nblock_records = self.decoder.read_int()\nblock_bytes_len = self.decoder.read_int()\nblock_bytes = self.decoder.read(block_bytes_len)\nif codec := self.header.compression_codec():\nblock_bytes = codec.decompress(block_bytes)\nself.block = Block(\nreader=self.reader, block_records=block_records, block_decoder=BinaryDecoder(MemoryInputStream(block_bytes))\n)\nreturn block_records\ndef __next__(self) -&gt; D:\n\"\"\"Returns the next item when iterating over the AvroFile class.\"\"\"\nif self.block and self.block.has_next():\nreturn next(self.block)\ntry:\nnew_block = self._read_block()\nexcept EOFError as exc:\nraise StopIteration from exc\nif new_block &gt; 0:\nreturn self.__next__()\nraise StopIteration\ndef _read_header(self) -&gt; AvroFileHeader:\nreturn construct_reader(META_SCHEMA, {-1: AvroFileHeader}).read(self.decoder)\n</code></pre>"},{"location":"reference/pyiceberg/avro/file/#pyiceberg.avro.file.AvroFile.__enter__","title":"<code>__enter__()</code>","text":"<p>Generates a reader tree for the payload within an avro file.</p> <p>Returns:</p> Type Description <code>AvroFile[D]</code> <p>A generator returning the AvroStructs</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/file.py</code> <pre><code>def __enter__(self) -&gt; AvroFile[D]:\n\"\"\"Generates a reader tree for the payload within an avro file.\n    Returns:\n        A generator returning the AvroStructs\n    \"\"\"\nself.input_stream = self.input_file.open(seekable=False)\nself.decoder = BinaryDecoder(self.input_stream)\nself.header = self._read_header()\nself.schema = self.header.get_schema()\nif not self.read_schema:\nself.read_schema = self.schema\nself.reader = resolve(self.schema, self.read_schema, self.read_types, self.read_enums)\nreturn self\n</code></pre>"},{"location":"reference/pyiceberg/avro/file/#pyiceberg.avro.file.AvroFile.__exit__","title":"<code>__exit__(exctype, excinst, exctb)</code>","text":"<p>Performs cleanup when exiting the scope of a 'with' statement.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/file.py</code> <pre><code>def __exit__(\nself, exctype: Optional[Type[BaseException]], excinst: Optional[BaseException], exctb: Optional[TracebackType]\n) -&gt; None:\n\"\"\"Performs cleanup when exiting the scope of a 'with' statement.\"\"\"\nself.input_stream.close()\n</code></pre>"},{"location":"reference/pyiceberg/avro/file/#pyiceberg.avro.file.AvroFile.__iter__","title":"<code>__iter__()</code>","text":"<p>Returns an iterator for the AvroFile class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/file.py</code> <pre><code>def __iter__(self) -&gt; AvroFile[D]:\n\"\"\"Returns an iterator for the AvroFile class.\"\"\"\nreturn self\n</code></pre>"},{"location":"reference/pyiceberg/avro/file/#pyiceberg.avro.file.AvroFile.__next__","title":"<code>__next__()</code>","text":"<p>Returns the next item when iterating over the AvroFile class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/file.py</code> <pre><code>def __next__(self) -&gt; D:\n\"\"\"Returns the next item when iterating over the AvroFile class.\"\"\"\nif self.block and self.block.has_next():\nreturn next(self.block)\ntry:\nnew_block = self._read_block()\nexcept EOFError as exc:\nraise StopIteration from exc\nif new_block &gt; 0:\nreturn self.__next__()\nraise StopIteration\n</code></pre>"},{"location":"reference/pyiceberg/avro/file/#pyiceberg.avro.file.AvroFileHeader","title":"<code>AvroFileHeader</code>","text":"<p>         Bases: <code>Record</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/file.py</code> <pre><code>class AvroFileHeader(Record):\nmagic: bytes\nmeta: Dict[str, str]\nsync: bytes\ndef compression_codec(self) -&gt; Optional[Type[Codec]]:\n\"\"\"Get the file's compression codec algorithm from the file's metadata.\n        In the case of a null codec, we return a None indicating that we\n        don't need to compress/decompress.\n        \"\"\"\ncodec_name = self.meta.get(_CODEC_KEY, \"null\")\nif codec_name not in KNOWN_CODECS:\nraise ValueError(f\"Unsupported codec: {codec_name}\")\nreturn KNOWN_CODECS[codec_name]\ndef get_schema(self) -&gt; Schema:\nif _SCHEMA_KEY in self.meta:\navro_schema_string = self.meta[_SCHEMA_KEY]\navro_schema = json.loads(avro_schema_string)\nreturn AvroSchemaConversion().avro_to_iceberg(avro_schema)\nelse:\nraise ValueError(\"No schema found in Avro file headers\")\n</code></pre>"},{"location":"reference/pyiceberg/avro/file/#pyiceberg.avro.file.AvroFileHeader.compression_codec","title":"<code>compression_codec()</code>","text":"<p>Get the file's compression codec algorithm from the file's metadata.</p> <p>In the case of a null codec, we return a None indicating that we don't need to compress/decompress.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/file.py</code> <pre><code>def compression_codec(self) -&gt; Optional[Type[Codec]]:\n\"\"\"Get the file's compression codec algorithm from the file's metadata.\n    In the case of a null codec, we return a None indicating that we\n    don't need to compress/decompress.\n    \"\"\"\ncodec_name = self.meta.get(_CODEC_KEY, \"null\")\nif codec_name not in KNOWN_CODECS:\nraise ValueError(f\"Unsupported codec: {codec_name}\")\nreturn KNOWN_CODECS[codec_name]\n</code></pre>"},{"location":"reference/pyiceberg/avro/file/#pyiceberg.avro.file.Block","title":"<code>Block</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Generic[D]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/file.py</code> <pre><code>@dataclass\nclass Block(Generic[D]):\nreader: Reader\nblock_records: int\nblock_decoder: BinaryDecoder\nposition: int = 0\ndef __iter__(self) -&gt; Block[D]:\n\"\"\"Returns an iterator for the Block class.\"\"\"\nreturn self\ndef has_next(self) -&gt; bool:\nreturn self.position &lt; self.block_records\ndef __next__(self) -&gt; D:\n\"\"\"Returns the next item when iterating over the Block class.\"\"\"\nif self.has_next():\nself.position += 1\nreturn self.reader.read(self.block_decoder)\nraise StopIteration\n</code></pre>"},{"location":"reference/pyiceberg/avro/file/#pyiceberg.avro.file.Block.__iter__","title":"<code>__iter__()</code>","text":"<p>Returns an iterator for the Block class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/file.py</code> <pre><code>def __iter__(self) -&gt; Block[D]:\n\"\"\"Returns an iterator for the Block class.\"\"\"\nreturn self\n</code></pre>"},{"location":"reference/pyiceberg/avro/file/#pyiceberg.avro.file.Block.__next__","title":"<code>__next__()</code>","text":"<p>Returns the next item when iterating over the Block class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/file.py</code> <pre><code>def __next__(self) -&gt; D:\n\"\"\"Returns the next item when iterating over the Block class.\"\"\"\nif self.has_next():\nself.position += 1\nreturn self.reader.read(self.block_decoder)\nraise StopIteration\n</code></pre>"},{"location":"reference/pyiceberg/avro/reader/","title":"reader","text":"<p>Classes for building the Reader tree.</p> <p>Constructing a reader tree from the schema makes it easy to decouple the reader implementation from the schema.</p> <p>The reader tree can be changed in such a way that the read schema is different, while respecting the read schema.</p>"},{"location":"reference/pyiceberg/avro/reader/#pyiceberg.avro.reader.DecimalReader","title":"<code>DecimalReader</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Reader</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/reader.py</code> <pre><code>@dataclass(frozen=True)\nclass DecimalReader(Reader):\nprecision: int = dataclassfield()\nscale: int = dataclassfield()\ndef read(self, decoder: BinaryDecoder) -&gt; Decimal:\nreturn decoder.read_decimal_from_bytes(self.precision, self.scale)\ndef skip(self, decoder: BinaryDecoder) -&gt; None:\ndecoder.skip_bytes()\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the DecimalReader class.\"\"\"\nreturn f\"DecimalReader({self.precision}, {self.scale})\"\n</code></pre>"},{"location":"reference/pyiceberg/avro/reader/#pyiceberg.avro.reader.DecimalReader.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the DecimalReader class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/reader.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the DecimalReader class.\"\"\"\nreturn f\"DecimalReader({self.precision}, {self.scale})\"\n</code></pre>"},{"location":"reference/pyiceberg/avro/reader/#pyiceberg.avro.reader.FixedReader","title":"<code>FixedReader</code>  <code>dataclass</code>","text":"<p>         Bases: <code>Reader</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/reader.py</code> <pre><code>@dataclass(frozen=True)\nclass FixedReader(Reader):\n_len: int = dataclassfield()\ndef read(self, decoder: BinaryDecoder) -&gt; bytes:\nreturn decoder.read(len(self))\ndef skip(self, decoder: BinaryDecoder) -&gt; None:\ndecoder.skip(len(self))\ndef __len__(self) -&gt; int:\n\"\"\"Returns the length of an instance of the FixedReader class.\"\"\"\nreturn self._len\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the FixedReader class.\"\"\"\nreturn f\"FixedReader({self._len})\"\n</code></pre>"},{"location":"reference/pyiceberg/avro/reader/#pyiceberg.avro.reader.FixedReader.__len__","title":"<code>__len__()</code>","text":"<p>Returns the length of an instance of the FixedReader class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/reader.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Returns the length of an instance of the FixedReader class.\"\"\"\nreturn self._len\n</code></pre>"},{"location":"reference/pyiceberg/avro/reader/#pyiceberg.avro.reader.FixedReader.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the FixedReader class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/reader.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the FixedReader class.\"\"\"\nreturn f\"FixedReader({self._len})\"\n</code></pre>"},{"location":"reference/pyiceberg/avro/reader/#pyiceberg.avro.reader.IntegerReader","title":"<code>IntegerReader</code>","text":"<p>         Bases: <code>Reader</code></p> <p>Longs and ints are encoded the same way, and there is no long in Python.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/reader.py</code> <pre><code>class IntegerReader(Reader):\n\"\"\"Longs and ints are encoded the same way, and there is no long in Python.\"\"\"\ndef read(self, decoder: BinaryDecoder) -&gt; int:\nreturn decoder.read_int()\ndef skip(self, decoder: BinaryDecoder) -&gt; None:\ndecoder.skip_int()\n</code></pre>"},{"location":"reference/pyiceberg/avro/reader/#pyiceberg.avro.reader.Reader","title":"<code>Reader</code>","text":"<p>         Bases: <code>Singleton</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/reader.py</code> <pre><code>class Reader(Singleton):\n@abstractmethod\ndef read(self, decoder: BinaryDecoder) -&gt; Any:\n...\n@abstractmethod\ndef skip(self, decoder: BinaryDecoder) -&gt; None:\n...\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Reader class.\"\"\"\nreturn f\"{self.__class__.__name__}()\"\n</code></pre>"},{"location":"reference/pyiceberg/avro/reader/#pyiceberg.avro.reader.Reader.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the Reader class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/reader.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Reader class.\"\"\"\nreturn f\"{self.__class__.__name__}()\"\n</code></pre>"},{"location":"reference/pyiceberg/avro/reader/#pyiceberg.avro.reader.StructReader","title":"<code>StructReader</code>","text":"<p>         Bases: <code>Reader</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/reader.py</code> <pre><code>class StructReader(Reader):\nfield_readers: Tuple[Tuple[Optional[int], Reader], ...]\ncreate_struct: Callable[..., StructProtocol]\nstruct: StructType\ndef __init__(\nself,\nfield_readers: Tuple[Tuple[Optional[int], Reader], ...],\ncreate_struct: Callable[..., StructProtocol],\nstruct: StructType,\n) -&gt; None:\nself.field_readers = field_readers\nself.create_struct = create_struct\nself.struct = struct\ndef read(self, decoder: BinaryDecoder) -&gt; StructProtocol:\ntry:\n# Try initializing the struct, first with the struct keyword argument\nstruct = self.create_struct(struct=self.struct)\nexcept TypeError as e:\nif \"'struct' is an invalid keyword argument for\" in str(e):\nstruct = self.create_struct()\nelse:\nraise ValueError(f\"Unable to initialize struct: {self.create_struct}\") from e\nif not isinstance(struct, StructProtocol):\nraise ValueError(f\"Incompatible with StructProtocol: {self.create_struct}\")\nfor pos, field in self.field_readers:\nif pos is not None:\nstruct[pos] = field.read(decoder)  # later: pass reuse in here\nelse:\nfield.skip(decoder)\nreturn struct\ndef skip(self, decoder: BinaryDecoder) -&gt; None:\nfor _, field in self.field_readers:\nfield.skip(decoder)\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the StructReader class.\"\"\"\nreturn (\nself.field_readers == other.field_readers and self.create_struct == other.create_struct\nif isinstance(other, StructReader)\nelse False\n)\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the StructReader class.\"\"\"\nreturn f\"StructReader(({','.join(repr(field) for field in self.field_readers)}), {repr(self.create_struct)})\"\ndef __hash__(self) -&gt; int:\n\"\"\"Returns a hashed representation of the StructReader class.\"\"\"\nreturn hash(self.field_readers)\n</code></pre>"},{"location":"reference/pyiceberg/avro/reader/#pyiceberg.avro.reader.StructReader.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the StructReader class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/reader.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the StructReader class.\"\"\"\nreturn (\nself.field_readers == other.field_readers and self.create_struct == other.create_struct\nif isinstance(other, StructReader)\nelse False\n)\n</code></pre>"},{"location":"reference/pyiceberg/avro/reader/#pyiceberg.avro.reader.StructReader.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns a hashed representation of the StructReader class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/reader.py</code> <pre><code>def __hash__(self) -&gt; int:\n\"\"\"Returns a hashed representation of the StructReader class.\"\"\"\nreturn hash(self.field_readers)\n</code></pre>"},{"location":"reference/pyiceberg/avro/reader/#pyiceberg.avro.reader.StructReader.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the StructReader class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/reader.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the StructReader class.\"\"\"\nreturn f\"StructReader(({','.join(repr(field) for field in self.field_readers)}), {repr(self.create_struct)})\"\n</code></pre>"},{"location":"reference/pyiceberg/avro/resolver/","title":"resolver","text":""},{"location":"reference/pyiceberg/avro/resolver/#pyiceberg.avro.resolver.EnumReader","title":"<code>EnumReader</code>","text":"<p>         Bases: <code>Reader</code></p> <p>An Enum reader to wrap primitive values into an Enum.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/resolver.py</code> <pre><code>class EnumReader(Reader):\n\"\"\"An Enum reader to wrap primitive values into an Enum.\"\"\"\nenum: Callable[..., Enum]\nreader: Reader\ndef __init__(self, enum: Callable[..., Enum], reader: Reader) -&gt; None:\nself.enum = enum\nself.reader = reader\ndef read(self, decoder: BinaryDecoder) -&gt; Enum:\nreturn self.enum(self.reader.read(decoder))\ndef skip(self, decoder: BinaryDecoder) -&gt; None:\npass\n</code></pre>"},{"location":"reference/pyiceberg/avro/resolver/#pyiceberg.avro.resolver.construct_reader","title":"<code>construct_reader(file_schema, read_types=EMPTY_DICT)</code>","text":"<p>Constructs a reader from a file schema.</p> <p>Parameters:</p> Name Type Description Default <code>file_schema</code> <code>Schema | IcebergType</code> <p>The schema of the Avro file.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If attempting to resolve an unrecognized object type.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/resolver.py</code> <pre><code>def construct_reader(\nfile_schema: Union[Schema, IcebergType], read_types: Dict[int, Callable[..., StructProtocol]] = EMPTY_DICT\n) -&gt; Reader:\n\"\"\"Constructs a reader from a file schema.\n    Args:\n        file_schema (Schema | IcebergType): The schema of the Avro file.\n    Raises:\n        NotImplementedError: If attempting to resolve an unrecognized object type.\n    \"\"\"\nreturn resolve(file_schema, file_schema, read_types)\n</code></pre>"},{"location":"reference/pyiceberg/avro/resolver/#pyiceberg.avro.resolver.resolve","title":"<code>resolve(file_schema, read_schema, read_types=EMPTY_DICT, read_enums=EMPTY_DICT)</code>","text":"<p>Resolves the file and read schema to produce a reader.</p> <p>Parameters:</p> Name Type Description Default <code>file_schema</code> <code>Schema | IcebergType</code> <p>The schema of the Avro file</p> required <code>read_schema</code> <code>Schema | IcebergType</code> <p>The requested read schema which is equal, subset or superset of the file schema.</p> required <code>read_types</code> <code>Dict[int, Callable[..., StructProtocol]]</code> <p>A dict of types to use for struct data.</p> <code>EMPTY_DICT</code> <code>read_enums</code> <code>Dict[int, Callable[..., Enum]]</code> <p>A dict of fields that have to be converted to an enum.</p> <code>EMPTY_DICT</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If attempting to resolve an unrecognized object type.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/resolver.py</code> <pre><code>def resolve(\nfile_schema: Union[Schema, IcebergType],\nread_schema: Union[Schema, IcebergType],\nread_types: Dict[int, Callable[..., StructProtocol]] = EMPTY_DICT,\nread_enums: Dict[int, Callable[..., Enum]] = EMPTY_DICT,\n) -&gt; Reader:\n\"\"\"Resolves the file and read schema to produce a reader.\n    Args:\n        file_schema (Schema | IcebergType): The schema of the Avro file\n        read_schema (Schema | IcebergType): The requested read schema which is equal, subset or superset of the file schema.\n        read_types (Dict[int, Callable[..., StructProtocol]]): A dict of types to use for struct data.\n        read_enums (Dict[int, Callable[..., Enum]]): A dict of fields that have to be converted to an enum.\n    Raises:\n        NotImplementedError: If attempting to resolve an unrecognized object type.\n    \"\"\"\nreturn visit_with_partner(\nfile_schema, read_schema, SchemaResolver(read_types, read_enums), SchemaPartnerAccessor()\n)  # type: ignore\n</code></pre>"},{"location":"reference/pyiceberg/avro/codecs/","title":"codecs","text":"<p>Contains Codecs for Python Avro.</p> <p>Note that the word \"codecs\" means \"compression/decompression algorithms\" in the Avro world (https://avro.apache.org/docs/current/spec.html#Object+Container+Files), so don't confuse it with the Python's \"codecs\", which is a package mainly for converting character sets (https://docs.python.org/3/library/codecs.html).</p>"},{"location":"reference/pyiceberg/avro/codecs/bzip2/","title":"bzip2","text":""},{"location":"reference/pyiceberg/avro/codecs/codec/","title":"codec","text":""},{"location":"reference/pyiceberg/avro/codecs/codec/#pyiceberg.avro.codecs.codec.Codec","title":"<code>Codec</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Abstract base class for all Avro codec classes.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/avro/codecs/codec.py</code> <pre><code>class Codec(ABC):\n\"\"\"Abstract base class for all Avro codec classes.\"\"\"\n@staticmethod\n@abstractmethod\ndef compress(data: bytes) -&gt; tuple[bytes, int]:\n...\n@staticmethod\n@abstractmethod\ndef decompress(data: bytes) -&gt; bytes:\n...\n</code></pre>"},{"location":"reference/pyiceberg/avro/codecs/deflate/","title":"deflate","text":""},{"location":"reference/pyiceberg/avro/codecs/snappy_codec/","title":"snappy_codec","text":""},{"location":"reference/pyiceberg/avro/codecs/zstandard_codec/","title":"zstandard_codec","text":""},{"location":"reference/pyiceberg/catalog/","title":"catalog","text":""},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.Catalog","title":"<code>Catalog</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Base Catalog for table operations like - create, drop, load, list and others.</p> <p>The catalog table APIs accept a table identifier, which is fully classified table name. The identifier can be a string or tuple of strings. If the identifier is a string, it is split into a tuple on '.'. If it is a tuple, it is used as-is.</p> <p>The catalog namespace APIs follow a similar convention wherein they also accept a namespace identifier that can be a string or tuple of strings.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the catalog.</p> <code>properties</code> <code>Properties</code> <p>Catalog properties.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>class Catalog(ABC):\n\"\"\"Base Catalog for table operations like - create, drop, load, list and others.\n    The catalog table APIs accept a table identifier, which is fully classified table name. The identifier can be a string or\n    tuple of strings. If the identifier is a string, it is split into a tuple on '.'. If it is a tuple, it is used as-is.\n    The catalog namespace APIs follow a similar convention wherein they also accept a namespace identifier that can be a string\n    or tuple of strings.\n    Attributes:\n        name (str): Name of the catalog.\n        properties (Properties): Catalog properties.\n    \"\"\"\nname: str\nproperties: Properties\ndef __init__(self, name: str, **properties: str):\nself.name = name\nself.properties = properties\ndef _load_file_io(self, properties: Properties = EMPTY_DICT, location: Optional[str] = None) -&gt; FileIO:\nreturn load_file_io({**self.properties, **properties}, location)\n@abstractmethod\ndef create_table(\nself,\nidentifier: Union[str, Identifier],\nschema: Schema,\nlocation: Optional[str] = None,\npartition_spec: PartitionSpec = UNPARTITIONED_PARTITION_SPEC,\nsort_order: SortOrder = UNSORTED_SORT_ORDER,\nproperties: Properties = EMPTY_DICT,\n) -&gt; Table:\n\"\"\"Create a table.\n        Args:\n            identifier (str | Identifier): Table identifier.\n            schema (Schema): Table's schema.\n            location (str | None): Location for the table. Optional Argument.\n            partition_spec (PartitionSpec): PartitionSpec for the table.\n            sort_order (SortOrder): SortOrder for the table.\n            properties (Properties): Table properties that can be a string based dictionary.\n        Returns:\n            Table: the created table instance.\n        Raises:\n            TableAlreadyExistsError: If a table with the name already exists.\n        \"\"\"\n@abstractmethod\ndef load_table(self, identifier: Union[str, Identifier]) -&gt; Table:\n\"\"\"Loads the table's metadata and returns the table instance.\n        You can also use this method to check for table existence using 'try catalog.table() except NoSuchTableError'.\n        Note: This method doesn't scan data stored in the table.\n        Args:\n            identifier (str | Identifier): Table identifier.\n        Returns:\n            Table: the table instance with its metadata.\n        Raises:\n            NoSuchTableError: If a table with the name does not exist.\n        \"\"\"\n@abstractmethod\ndef drop_table(self, identifier: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a table.\n        Args:\n            identifier (str | Identifier): Table identifier.\n        Raises:\n            NoSuchTableError: If a table with the name does not exist.\n        \"\"\"\n@abstractmethod\ndef rename_table(self, from_identifier: Union[str, Identifier], to_identifier: Union[str, Identifier]) -&gt; Table:\n\"\"\"Rename a fully classified table name.\n        Args:\n            from_identifier (str | Identifier): Existing table identifier.\n            to_identifier (str | Identifier): New table identifier.\n        Returns:\n            Table: the updated table instance with its metadata.\n        Raises:\n            NoSuchTableError: If a table with the name does not exist.\n        \"\"\"\n@abstractmethod\ndef _commit_table(self, table_request: CommitTableRequest) -&gt; CommitTableResponse:\n\"\"\"Updates one or more tables.\n        Args:\n            table_request (CommitTableRequest): The table requests to be carried out.\n        Returns:\n            CommitTableResponse: The updated metadata.\n        Raises:\n            NoSuchTableError: If a table with the given identifier does not exist.\n        \"\"\"\n@abstractmethod\ndef create_namespace(self, namespace: Union[str, Identifier], properties: Properties = EMPTY_DICT) -&gt; None:\n\"\"\"Create a namespace in the catalog.\n        Args:\n            namespace (str | Identifier): Namespace identifier.\n            properties (Properties): A string dictionary of properties for the given namespace.\n        Raises:\n            NamespaceAlreadyExistsError: If a namespace with the given name already exists.\n        \"\"\"\n@abstractmethod\ndef drop_namespace(self, namespace: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a namespace.\n        Args:\n            namespace (str | Identifier): Namespace identifier.\n        Raises:\n            NoSuchNamespaceError: If a namespace with the given name does not exist.\n            NamespaceNotEmptyError: If the namespace is not empty.\n        \"\"\"\n@abstractmethod\ndef list_tables(self, namespace: Union[str, Identifier]) -&gt; List[Identifier]:\n\"\"\"List tables under the given namespace in the catalog.\n        If namespace not provided, will list all tables in the catalog.\n        Args:\n            namespace (str | Identifier): Namespace identifier to search.\n        Returns:\n            List[Identifier]: list of table identifiers.\n        Raises:\n            NoSuchNamespaceError: If a namespace with the given name does not exist.\n        \"\"\"\n@abstractmethod\ndef list_namespaces(self, namespace: Union[str, Identifier] = ()) -&gt; List[Identifier]:\n\"\"\"List namespaces from the given namespace. If not given, list top-level namespaces from the catalog.\n        Args:\n            namespace (str | Identifier): Namespace identifier to search.\n        Returns:\n            List[Identifier]: a List of namespace identifiers.\n        Raises:\n            NoSuchNamespaceError: If a namespace with the given name does not exist.\n        \"\"\"\n@abstractmethod\ndef load_namespace_properties(self, namespace: Union[str, Identifier]) -&gt; Properties:\n\"\"\"Get properties for a namespace.\n        Args:\n            namespace (str | Identifier): Namespace identifier.\n        Returns:\n            Properties: Properties for the given namespace.\n        Raises:\n            NoSuchNamespaceError: If a namespace with the given name does not exist.\n        \"\"\"\n@abstractmethod\ndef update_namespace_properties(\nself, namespace: Union[str, Identifier], removals: Optional[Set[str]] = None, updates: Properties = EMPTY_DICT\n) -&gt; PropertiesUpdateSummary:\n\"\"\"Removes provided property keys and updates properties for a namespace.\n        Args:\n            namespace (str | Identifier): Namespace identifier.\n            removals (Set[str]): Set of property keys that need to be removed. Optional Argument.\n            updates (Properties): Properties to be updated for the given namespace.\n        Raises:\n            NoSuchNamespaceError: If a namespace with the given name does not exist.\n            ValueError: If removals and updates have overlapping keys.\n        \"\"\"\n@staticmethod\ndef identifier_to_tuple(identifier: Union[str, Identifier]) -&gt; Identifier:\n\"\"\"Parses an identifier to a tuple.\n        If the identifier is a string, it is split into a tuple on '.'. If it is a tuple, it is used as-is.\n        Args:\n            identifier (str | Identifier: an identifier, either a string or tuple of strings.\n        Returns:\n            Identifier: a tuple of strings.\n        \"\"\"\nreturn identifier if isinstance(identifier, tuple) else tuple(str.split(identifier, \".\"))\n@staticmethod\ndef table_name_from(identifier: Union[str, Identifier]) -&gt; str:\n\"\"\"Extracts table name from a table identifier.\n        Args:\n            identifier (str | Identifier: a table identifier.\n        Returns:\n            str: Table name.\n        \"\"\"\nreturn Catalog.identifier_to_tuple(identifier)[-1]\n@staticmethod\ndef namespace_from(identifier: Union[str, Identifier]) -&gt; Identifier:\n\"\"\"Extracts table namespace from a table identifier.\n        Args:\n            identifier (Union[str, Identifier]): a table identifier.\n        Returns:\n            Identifier: Namespace identifier.\n        \"\"\"\nreturn Catalog.identifier_to_tuple(identifier)[:-1]\n@staticmethod\ndef _check_for_overlap(removals: Optional[Set[str]], updates: Properties) -&gt; None:\nif updates and removals:\noverlap = set(removals) &amp; set(updates.keys())\nif overlap:\nraise ValueError(f\"Updates and deletes have an overlap: {overlap}\")\ndef _resolve_table_location(self, location: Optional[str], database_name: str, table_name: str) -&gt; str:\nif not location:\nreturn self._get_default_warehouse_location(database_name, table_name)\nreturn location\ndef _get_default_warehouse_location(self, database_name: str, table_name: str) -&gt; str:\ndatabase_properties = self.load_namespace_properties(database_name)\nif database_location := database_properties.get(LOCATION):\ndatabase_location = database_location.rstrip(\"/\")\nreturn f\"{database_location}/{table_name}\"\nif warehouse_path := self.properties.get(WAREHOUSE_LOCATION):\nwarehouse_path = warehouse_path.rstrip(\"/\")\nreturn f\"{warehouse_path}/{database_name}.db/{table_name}\"\nraise ValueError(\"No default path is set, please specify a location when creating a table\")\n@staticmethod\ndef identifier_to_database(\nidentifier: Union[str, Identifier], err: Union[Type[ValueError], Type[NoSuchNamespaceError]] = ValueError\n) -&gt; str:\ntuple_identifier = Catalog.identifier_to_tuple(identifier)\nif len(tuple_identifier) != 1:\nraise err(f\"Invalid database, hierarchical namespaces are not supported: {identifier}\")\nreturn tuple_identifier[0]\n@staticmethod\ndef identifier_to_database_and_table(\nidentifier: Union[str, Identifier],\nerr: Union[Type[ValueError], Type[NoSuchTableError], Type[NoSuchNamespaceError]] = ValueError,\n) -&gt; Tuple[str, str]:\ntuple_identifier = Catalog.identifier_to_tuple(identifier)\nif len(tuple_identifier) != 2:\nraise err(f\"Invalid path, hierarchical namespaces are not supported: {identifier}\")\nreturn tuple_identifier[0], tuple_identifier[1]\ndef purge_table(self, identifier: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a table and purge all data and metadata files.\n        Note: This method only logs warning rather than raise exception when encountering file deletion failure.\n        Args:\n            identifier (str | Identifier): Table identifier.\n        Raises:\n            NoSuchTableError: If a table with the name does not exist, or the identifier is invalid.\n        \"\"\"\ntable = self.load_table(identifier)\nself.drop_table(identifier)\nio = load_file_io(self.properties, table.metadata_location)\nmetadata = table.metadata\nmanifest_lists_to_delete = set()\nmanifests_to_delete = []\nfor snapshot in metadata.snapshots:\nmanifests_to_delete += snapshot.manifests(io)\nif snapshot.manifest_list is not None:\nmanifest_lists_to_delete.add(snapshot.manifest_list)\nmanifest_paths_to_delete = {manifest.manifest_path for manifest in manifests_to_delete}\nprev_metadata_files = {log.metadata_file for log in metadata.metadata_log}\ndelete_data_files(io, manifests_to_delete)\ndelete_files(io, manifest_paths_to_delete, MANIFEST)\ndelete_files(io, manifest_lists_to_delete, MANIFEST_LIST)\ndelete_files(io, prev_metadata_files, PREVIOUS_METADATA)\ndelete_files(io, {table.metadata_location}, METADATA)\n@staticmethod\ndef _write_metadata(metadata: TableMetadata, io: FileIO, metadata_path: str) -&gt; None:\nToOutputFile.table_metadata(metadata, io.new_output(metadata_path))\n@staticmethod\ndef _get_metadata_location(location: str) -&gt; str:\nreturn f\"{location}/metadata/00000-{uuid.uuid4()}.metadata.json\"\ndef _get_updated_props_and_update_summary(\nself, current_properties: Properties, removals: Optional[Set[str]], updates: Properties\n) -&gt; Tuple[PropertiesUpdateSummary, Properties]:\nself._check_for_overlap(updates=updates, removals=removals)\nupdated_properties = dict(current_properties)\nremoved: Set[str] = set()\nupdated: Set[str] = set()\nif removals:\nfor key in removals:\nif key in updated_properties:\nupdated_properties.pop(key)\nremoved.add(key)\nif updates:\nfor key, value in updates.items():\nupdated_properties[key] = value\nupdated.add(key)\nexpected_to_change = (removals or set()).difference(removed)\nproperties_update_summary = PropertiesUpdateSummary(\nremoved=list(removed or []), updated=list(updated or []), missing=list(expected_to_change)\n)\nreturn properties_update_summary, updated_properties\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.Catalog.create_namespace","title":"<code>create_namespace(namespace, properties=EMPTY_DICT)</code>  <code>abstractmethod</code>","text":"<p>Create a namespace in the catalog.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str | Identifier</code> <p>Namespace identifier.</p> required <code>properties</code> <code>Properties</code> <p>A string dictionary of properties for the given namespace.</p> <code>EMPTY_DICT</code> <p>Raises:</p> Type Description <code>NamespaceAlreadyExistsError</code> <p>If a namespace with the given name already exists.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>@abstractmethod\ndef create_namespace(self, namespace: Union[str, Identifier], properties: Properties = EMPTY_DICT) -&gt; None:\n\"\"\"Create a namespace in the catalog.\n    Args:\n        namespace (str | Identifier): Namespace identifier.\n        properties (Properties): A string dictionary of properties for the given namespace.\n    Raises:\n        NamespaceAlreadyExistsError: If a namespace with the given name already exists.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.Catalog.create_table","title":"<code>create_table(identifier, schema, location=None, partition_spec=UNPARTITIONED_PARTITION_SPEC, sort_order=UNSORTED_SORT_ORDER, properties=EMPTY_DICT)</code>  <code>abstractmethod</code>","text":"<p>Create a table.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str | Identifier</code> <p>Table identifier.</p> required <code>schema</code> <code>Schema</code> <p>Table's schema.</p> required <code>location</code> <code>str | None</code> <p>Location for the table. Optional Argument.</p> <code>None</code> <code>partition_spec</code> <code>PartitionSpec</code> <p>PartitionSpec for the table.</p> <code>UNPARTITIONED_PARTITION_SPEC</code> <code>sort_order</code> <code>SortOrder</code> <p>SortOrder for the table.</p> <code>UNSORTED_SORT_ORDER</code> <code>properties</code> <code>Properties</code> <p>Table properties that can be a string based dictionary.</p> <code>EMPTY_DICT</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>the created table instance.</p> <p>Raises:</p> Type Description <code>TableAlreadyExistsError</code> <p>If a table with the name already exists.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>@abstractmethod\ndef create_table(\nself,\nidentifier: Union[str, Identifier],\nschema: Schema,\nlocation: Optional[str] = None,\npartition_spec: PartitionSpec = UNPARTITIONED_PARTITION_SPEC,\nsort_order: SortOrder = UNSORTED_SORT_ORDER,\nproperties: Properties = EMPTY_DICT,\n) -&gt; Table:\n\"\"\"Create a table.\n    Args:\n        identifier (str | Identifier): Table identifier.\n        schema (Schema): Table's schema.\n        location (str | None): Location for the table. Optional Argument.\n        partition_spec (PartitionSpec): PartitionSpec for the table.\n        sort_order (SortOrder): SortOrder for the table.\n        properties (Properties): Table properties that can be a string based dictionary.\n    Returns:\n        Table: the created table instance.\n    Raises:\n        TableAlreadyExistsError: If a table with the name already exists.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.Catalog.drop_namespace","title":"<code>drop_namespace(namespace)</code>  <code>abstractmethod</code>","text":"<p>Drop a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str | Identifier</code> <p>Namespace identifier.</p> required <p>Raises:</p> Type Description <code>NoSuchNamespaceError</code> <p>If a namespace with the given name does not exist.</p> <code>NamespaceNotEmptyError</code> <p>If the namespace is not empty.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>@abstractmethod\ndef drop_namespace(self, namespace: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a namespace.\n    Args:\n        namespace (str | Identifier): Namespace identifier.\n    Raises:\n        NoSuchNamespaceError: If a namespace with the given name does not exist.\n        NamespaceNotEmptyError: If the namespace is not empty.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.Catalog.drop_table","title":"<code>drop_table(identifier)</code>  <code>abstractmethod</code>","text":"<p>Drop a table.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str | Identifier</code> <p>Table identifier.</p> required <p>Raises:</p> Type Description <code>NoSuchTableError</code> <p>If a table with the name does not exist.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>@abstractmethod\ndef drop_table(self, identifier: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a table.\n    Args:\n        identifier (str | Identifier): Table identifier.\n    Raises:\n        NoSuchTableError: If a table with the name does not exist.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.Catalog.identifier_to_tuple","title":"<code>identifier_to_tuple(identifier)</code>  <code>staticmethod</code>","text":"<p>Parses an identifier to a tuple.</p> <p>If the identifier is a string, it is split into a tuple on '.'. If it is a tuple, it is used as-is.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str | Identifier</code> <p>an identifier, either a string or tuple of strings.</p> required <p>Returns:</p> Name Type Description <code>Identifier</code> <code>Identifier</code> <p>a tuple of strings.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>@staticmethod\ndef identifier_to_tuple(identifier: Union[str, Identifier]) -&gt; Identifier:\n\"\"\"Parses an identifier to a tuple.\n    If the identifier is a string, it is split into a tuple on '.'. If it is a tuple, it is used as-is.\n    Args:\n        identifier (str | Identifier: an identifier, either a string or tuple of strings.\n    Returns:\n        Identifier: a tuple of strings.\n    \"\"\"\nreturn identifier if isinstance(identifier, tuple) else tuple(str.split(identifier, \".\"))\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.Catalog.list_namespaces","title":"<code>list_namespaces(namespace=())</code>  <code>abstractmethod</code>","text":"<p>List namespaces from the given namespace. If not given, list top-level namespaces from the catalog.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str | Identifier</code> <p>Namespace identifier to search.</p> <code>()</code> <p>Returns:</p> Type Description <code>List[Identifier]</code> <p>List[Identifier]: a List of namespace identifiers.</p> <p>Raises:</p> Type Description <code>NoSuchNamespaceError</code> <p>If a namespace with the given name does not exist.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>@abstractmethod\ndef list_namespaces(self, namespace: Union[str, Identifier] = ()) -&gt; List[Identifier]:\n\"\"\"List namespaces from the given namespace. If not given, list top-level namespaces from the catalog.\n    Args:\n        namespace (str | Identifier): Namespace identifier to search.\n    Returns:\n        List[Identifier]: a List of namespace identifiers.\n    Raises:\n        NoSuchNamespaceError: If a namespace with the given name does not exist.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.Catalog.list_tables","title":"<code>list_tables(namespace)</code>  <code>abstractmethod</code>","text":"<p>List tables under the given namespace in the catalog.</p> <p>If namespace not provided, will list all tables in the catalog.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str | Identifier</code> <p>Namespace identifier to search.</p> required <p>Returns:</p> Type Description <code>List[Identifier]</code> <p>List[Identifier]: list of table identifiers.</p> <p>Raises:</p> Type Description <code>NoSuchNamespaceError</code> <p>If a namespace with the given name does not exist.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>@abstractmethod\ndef list_tables(self, namespace: Union[str, Identifier]) -&gt; List[Identifier]:\n\"\"\"List tables under the given namespace in the catalog.\n    If namespace not provided, will list all tables in the catalog.\n    Args:\n        namespace (str | Identifier): Namespace identifier to search.\n    Returns:\n        List[Identifier]: list of table identifiers.\n    Raises:\n        NoSuchNamespaceError: If a namespace with the given name does not exist.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.Catalog.load_namespace_properties","title":"<code>load_namespace_properties(namespace)</code>  <code>abstractmethod</code>","text":"<p>Get properties for a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str | Identifier</code> <p>Namespace identifier.</p> required <p>Returns:</p> Name Type Description <code>Properties</code> <code>Properties</code> <p>Properties for the given namespace.</p> <p>Raises:</p> Type Description <code>NoSuchNamespaceError</code> <p>If a namespace with the given name does not exist.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>@abstractmethod\ndef load_namespace_properties(self, namespace: Union[str, Identifier]) -&gt; Properties:\n\"\"\"Get properties for a namespace.\n    Args:\n        namespace (str | Identifier): Namespace identifier.\n    Returns:\n        Properties: Properties for the given namespace.\n    Raises:\n        NoSuchNamespaceError: If a namespace with the given name does not exist.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.Catalog.load_table","title":"<code>load_table(identifier)</code>  <code>abstractmethod</code>","text":"<p>Loads the table's metadata and returns the table instance.</p> <p>You can also use this method to check for table existence using 'try catalog.table() except NoSuchTableError'. Note: This method doesn't scan data stored in the table.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str | Identifier</code> <p>Table identifier.</p> required <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>the table instance with its metadata.</p> <p>Raises:</p> Type Description <code>NoSuchTableError</code> <p>If a table with the name does not exist.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>@abstractmethod\ndef load_table(self, identifier: Union[str, Identifier]) -&gt; Table:\n\"\"\"Loads the table's metadata and returns the table instance.\n    You can also use this method to check for table existence using 'try catalog.table() except NoSuchTableError'.\n    Note: This method doesn't scan data stored in the table.\n    Args:\n        identifier (str | Identifier): Table identifier.\n    Returns:\n        Table: the table instance with its metadata.\n    Raises:\n        NoSuchTableError: If a table with the name does not exist.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.Catalog.namespace_from","title":"<code>namespace_from(identifier)</code>  <code>staticmethod</code>","text":"<p>Extracts table namespace from a table identifier.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Union[str, Identifier]</code> <p>a table identifier.</p> required <p>Returns:</p> Name Type Description <code>Identifier</code> <code>Identifier</code> <p>Namespace identifier.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>@staticmethod\ndef namespace_from(identifier: Union[str, Identifier]) -&gt; Identifier:\n\"\"\"Extracts table namespace from a table identifier.\n    Args:\n        identifier (Union[str, Identifier]): a table identifier.\n    Returns:\n        Identifier: Namespace identifier.\n    \"\"\"\nreturn Catalog.identifier_to_tuple(identifier)[:-1]\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.Catalog.purge_table","title":"<code>purge_table(identifier)</code>","text":"<p>Drop a table and purge all data and metadata files.</p> <p>Note: This method only logs warning rather than raise exception when encountering file deletion failure.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str | Identifier</code> <p>Table identifier.</p> required <p>Raises:</p> Type Description <code>NoSuchTableError</code> <p>If a table with the name does not exist, or the identifier is invalid.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>def purge_table(self, identifier: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a table and purge all data and metadata files.\n    Note: This method only logs warning rather than raise exception when encountering file deletion failure.\n    Args:\n        identifier (str | Identifier): Table identifier.\n    Raises:\n        NoSuchTableError: If a table with the name does not exist, or the identifier is invalid.\n    \"\"\"\ntable = self.load_table(identifier)\nself.drop_table(identifier)\nio = load_file_io(self.properties, table.metadata_location)\nmetadata = table.metadata\nmanifest_lists_to_delete = set()\nmanifests_to_delete = []\nfor snapshot in metadata.snapshots:\nmanifests_to_delete += snapshot.manifests(io)\nif snapshot.manifest_list is not None:\nmanifest_lists_to_delete.add(snapshot.manifest_list)\nmanifest_paths_to_delete = {manifest.manifest_path for manifest in manifests_to_delete}\nprev_metadata_files = {log.metadata_file for log in metadata.metadata_log}\ndelete_data_files(io, manifests_to_delete)\ndelete_files(io, manifest_paths_to_delete, MANIFEST)\ndelete_files(io, manifest_lists_to_delete, MANIFEST_LIST)\ndelete_files(io, prev_metadata_files, PREVIOUS_METADATA)\ndelete_files(io, {table.metadata_location}, METADATA)\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.Catalog.rename_table","title":"<code>rename_table(from_identifier, to_identifier)</code>  <code>abstractmethod</code>","text":"<p>Rename a fully classified table name.</p> <p>Parameters:</p> Name Type Description Default <code>from_identifier</code> <code>str | Identifier</code> <p>Existing table identifier.</p> required <code>to_identifier</code> <code>str | Identifier</code> <p>New table identifier.</p> required <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>the updated table instance with its metadata.</p> <p>Raises:</p> Type Description <code>NoSuchTableError</code> <p>If a table with the name does not exist.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>@abstractmethod\ndef rename_table(self, from_identifier: Union[str, Identifier], to_identifier: Union[str, Identifier]) -&gt; Table:\n\"\"\"Rename a fully classified table name.\n    Args:\n        from_identifier (str | Identifier): Existing table identifier.\n        to_identifier (str | Identifier): New table identifier.\n    Returns:\n        Table: the updated table instance with its metadata.\n    Raises:\n        NoSuchTableError: If a table with the name does not exist.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.Catalog.table_name_from","title":"<code>table_name_from(identifier)</code>  <code>staticmethod</code>","text":"<p>Extracts table name from a table identifier.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str | Identifier</code> <p>a table identifier.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Table name.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>@staticmethod\ndef table_name_from(identifier: Union[str, Identifier]) -&gt; str:\n\"\"\"Extracts table name from a table identifier.\n    Args:\n        identifier (str | Identifier: a table identifier.\n    Returns:\n        str: Table name.\n    \"\"\"\nreturn Catalog.identifier_to_tuple(identifier)[-1]\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.Catalog.update_namespace_properties","title":"<code>update_namespace_properties(namespace, removals=None, updates=EMPTY_DICT)</code>  <code>abstractmethod</code>","text":"<p>Removes provided property keys and updates properties for a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str | Identifier</code> <p>Namespace identifier.</p> required <code>removals</code> <code>Set[str]</code> <p>Set of property keys that need to be removed. Optional Argument.</p> <code>None</code> <code>updates</code> <code>Properties</code> <p>Properties to be updated for the given namespace.</p> <code>EMPTY_DICT</code> <p>Raises:</p> Type Description <code>NoSuchNamespaceError</code> <p>If a namespace with the given name does not exist.</p> <code>ValueError</code> <p>If removals and updates have overlapping keys.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>@abstractmethod\ndef update_namespace_properties(\nself, namespace: Union[str, Identifier], removals: Optional[Set[str]] = None, updates: Properties = EMPTY_DICT\n) -&gt; PropertiesUpdateSummary:\n\"\"\"Removes provided property keys and updates properties for a namespace.\n    Args:\n        namespace (str | Identifier): Namespace identifier.\n        removals (Set[str]): Set of property keys that need to be removed. Optional Argument.\n        updates (Properties): Properties to be updated for the given namespace.\n    Raises:\n        NoSuchNamespaceError: If a namespace with the given name does not exist.\n        ValueError: If removals and updates have overlapping keys.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.delete_data_files","title":"<code>delete_data_files(io, manifests_to_delete)</code>","text":"<p>Helper to delete data files linked to given manifests.</p> <p>Log warnings if failing to delete any file.</p> <p>Parameters:</p> Name Type Description Default <code>io</code> <code>FileIO</code> <p>The FileIO used to delete the object.</p> required <code>manifests_to_delete</code> <code>List[ManifestFile]</code> <p>A list of manifest contains paths of data files to be deleted.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>def delete_data_files(io: FileIO, manifests_to_delete: List[ManifestFile]) -&gt; None:\n\"\"\"Helper to delete data files linked to given manifests.\n    Log warnings if failing to delete any file.\n    Args:\n        io: The FileIO used to delete the object.\n        manifests_to_delete: A list of manifest contains paths of data files to be deleted.\n    \"\"\"\ndeleted_files: dict[str, bool] = {}\nfor manifest_file in manifests_to_delete:\nfor entry in manifest_file.fetch_manifest_entry(io, discard_deleted=False):\npath = entry.data_file.file_path\nif not deleted_files.get(path, False):\ntry:\nio.delete(path)\nexcept OSError as exc:\nlogger.warning(msg=f\"Failed to delete data file {path}\", exc_info=exc)\ndeleted_files[path] = True\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.delete_files","title":"<code>delete_files(io, files_to_delete, file_type)</code>","text":"<p>Helper to delete files.</p> <p>Log warnings if failing to delete any file.</p> <p>Parameters:</p> Name Type Description Default <code>io</code> <code>FileIO</code> <p>The FileIO used to delete the object.</p> required <code>files_to_delete</code> <code>Set[str]</code> <p>A set of file paths to be deleted.</p> required <code>file_type</code> <code>str</code> <p>The type of the file.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>def delete_files(io: FileIO, files_to_delete: Set[str], file_type: str) -&gt; None:\n\"\"\"Helper to delete files.\n    Log warnings if failing to delete any file.\n    Args:\n        io: The FileIO used to delete the object.\n        files_to_delete: A set of file paths to be deleted.\n        file_type: The type of the file.\n    \"\"\"\nfor file in files_to_delete:\ntry:\nio.delete(file)\nexcept OSError as exc:\nlogger.warning(msg=f\"Failed to delete {file_type} file {file}\", exc_info=exc)\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.infer_catalog_type","title":"<code>infer_catalog_type(name, catalog_properties)</code>","text":"<p>Tries to infer the type based on the dict.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the catalog.</p> required <code>catalog_properties</code> <code>RecursiveDict</code> <p>Catalog properties.</p> required <p>Returns:</p> Type Description <code>Optional[CatalogType]</code> <p>The inferred type based on the provided properties.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Raises a ValueError in case properties are missing, or the wrong type.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>def infer_catalog_type(name: str, catalog_properties: RecursiveDict) -&gt; Optional[CatalogType]:\n\"\"\"Tries to infer the type based on the dict.\n    Args:\n        name: Name of the catalog.\n        catalog_properties: Catalog properties.\n    Returns:\n        The inferred type based on the provided properties.\n    Raises:\n        ValueError: Raises a ValueError in case properties are missing, or the wrong type.\n    \"\"\"\nif uri := catalog_properties.get(\"uri\"):\nif isinstance(uri, str):\nif uri.startswith(\"http\"):\nreturn CatalogType.REST\nelif uri.startswith(\"thrift\"):\nreturn CatalogType.HIVE\nelse:\nraise ValueError(f\"Could not infer the catalog type from the uri: {uri}\")\nelse:\nraise ValueError(f\"Expects the URI to be a string, got: {type(uri)}\")\nraise ValueError(\nf\"URI missing, please provide using --uri, the config or environment variable PYICEBERG_CATALOG__{name.upper()}__URI\"\n)\n</code></pre>"},{"location":"reference/pyiceberg/catalog/#pyiceberg.catalog.load_catalog","title":"<code>load_catalog(name, **properties)</code>","text":"<p>Load the catalog based on the properties.</p> <p>Will look up the properties from the config, based on the name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the catalog.</p> required <code>properties</code> <code>Optional[str]</code> <p>The properties that are used next to the configuration.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Catalog</code> <p>An initialized Catalog.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Raises a ValueError in case properties are missing or malformed, or if it could not determine the catalog based on the properties.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/__init__.py</code> <pre><code>def load_catalog(name: Optional[str], **properties: Optional[str]) -&gt; Catalog:\n\"\"\"Load the catalog based on the properties.\n    Will look up the properties from the config, based on the name.\n    Args:\n        name: The name of the catalog.\n        properties: The properties that are used next to the configuration.\n    Returns:\n        An initialized Catalog.\n    Raises:\n        ValueError: Raises a ValueError in case properties are missing or malformed,\n            or if it could not determine the catalog based on the properties.\n    \"\"\"\nif name is None:\nname = _ENV_CONFIG.get_default_catalog_name()\nenv = _ENV_CONFIG.get_catalog_config(name)\nconf: RecursiveDict = merge_config(env or {}, cast(RecursiveDict, properties))\ncatalog_type: Optional[CatalogType]\nprovided_catalog_type = conf.get(TYPE)\ncatalog_type = None\nif provided_catalog_type and isinstance(provided_catalog_type, str):\ncatalog_type = CatalogType[provided_catalog_type.upper()]\nelif not provided_catalog_type:\ncatalog_type = infer_catalog_type(name, conf)\nif catalog_type:\nreturn AVAILABLE_CATALOGS[catalog_type](name, cast(Dict[str, str], conf))\nraise ValueError(f\"Could not initialize catalog with the following properties: {properties}\")\n</code></pre>"},{"location":"reference/pyiceberg/catalog/dynamodb/","title":"dynamodb","text":""},{"location":"reference/pyiceberg/catalog/dynamodb/#pyiceberg.catalog.dynamodb.DynamoDbCatalog","title":"<code>DynamoDbCatalog</code>","text":"<p>         Bases: <code>Catalog</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/dynamodb.py</code> <pre><code>class DynamoDbCatalog(Catalog):\ndef __init__(self, name: str, **properties: str):\nsuper().__init__(name, **properties)\nself.dynamodb = boto3.client(DYNAMODB_CLIENT)\nself.dynamodb_table_name = self.properties.get(DYNAMODB_TABLE_NAME, DYNAMODB_TABLE_NAME_DEFAULT)\nself._ensure_catalog_table_exists_or_create()\ndef _ensure_catalog_table_exists_or_create(self) -&gt; None:\nif self._dynamodb_table_exists():\nreturn None\ntry:\nself.dynamodb.create_table(\nTableName=self.dynamodb_table_name,\nAttributeDefinitions=CREATE_CATALOG_ATTRIBUTE_DEFINITIONS,\nKeySchema=CREATE_CATALOG_KEY_SCHEMA,\nGlobalSecondaryIndexes=CREATE_CATALOG_GLOBAL_SECONDARY_INDEXES,\nBillingMode=DYNAMODB_PAY_PER_REQUEST,\n)\nexcept (\nself.dynamodb.exceptions.ResourceInUseException,\nself.dynamodb.exceptions.LimitExceededException,\nself.dynamodb.exceptions.InternalServerError,\n) as e:\nraise GenericDynamoDbError(e.message) from e\ndef _dynamodb_table_exists(self) -&gt; bool:\ntry:\nresponse = self.dynamodb.describe_table(TableName=self.dynamodb_table_name)\nexcept self.dynamodb.exceptions.ResourceNotFoundException:\nreturn False\nexcept self.dynamodb.exceptions.InternalServerError as e:\nraise GenericDynamoDbError(e.message) from e\nif response[\"Table\"][\"TableStatus\"] != ACTIVE:\nraise GenericDynamoDbError(f\"DynamoDB table for catalog {self.dynamodb_table_name} is not {ACTIVE}\")\nelse:\nreturn True\ndef create_table(\nself,\nidentifier: Union[str, Identifier],\nschema: Schema,\nlocation: Optional[str] = None,\npartition_spec: PartitionSpec = UNPARTITIONED_PARTITION_SPEC,\nsort_order: SortOrder = UNSORTED_SORT_ORDER,\nproperties: Properties = EMPTY_DICT,\n) -&gt; Table:\n\"\"\"\n        Create an Iceberg table.\n        Args:\n            identifier: Table identifier.\n            schema: Table's schema.\n            location: Location for the table. Optional Argument.\n            partition_spec: PartitionSpec for the table.\n            sort_order: SortOrder for the table.\n            properties: Table properties that can be a string based dictionary.\n        Returns:\n            Table: the created table instance.\n        Raises:\n            AlreadyExistsError: If a table with the name already exists.\n            ValueError: If the identifier is invalid, or no path is given to store metadata.\n        \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier)\nlocation = self._resolve_table_location(location, database_name, table_name)\nmetadata_location = self._get_metadata_location(location=location)\nmetadata = new_table_metadata(\nlocation=location, schema=schema, partition_spec=partition_spec, sort_order=sort_order, properties=properties\n)\nio = load_file_io(properties=self.properties, location=metadata_location)\nself._write_metadata(metadata, io, metadata_location)\nself._ensure_namespace_exists(database_name=database_name)\ntry:\nself._put_dynamo_item(\nitem=_get_create_table_item(\ndatabase_name=database_name, table_name=table_name, properties=properties, metadata_location=metadata_location\n),\ncondition_expression=f\"attribute_not_exists({DYNAMODB_COL_IDENTIFIER})\",\n)\nexcept ConditionalCheckFailedException as e:\nraise TableAlreadyExistsError(f\"Table {database_name}.{table_name} already exists\") from e\nreturn self.load_table(identifier=identifier)\ndef _commit_table(self, table_request: CommitTableRequest) -&gt; CommitTableResponse:\n\"\"\"Updates the table.\n        Args:\n            table_request (CommitTableRequest): The table requests to be carried out.\n        Returns:\n            CommitTableResponse: The updated metadata.\n        Raises:\n            NoSuchTableError: If a table with the given identifier does not exist.\n        \"\"\"\nraise NotImplementedError\ndef load_table(self, identifier: Union[str, Identifier]) -&gt; Table:\n\"\"\"\n        Loads the table's metadata and returns the table instance.\n        You can also use this method to check for table existence using 'try catalog.table() except TableNotFoundError'.\n        Note: This method doesn't scan data stored in the table.\n        Args:\n            identifier: Table identifier.\n        Returns:\n            Table: the table instance with its metadata.\n        Raises:\n            NoSuchTableError: If a table with the name does not exist, or the identifier is invalid.\n        \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier, NoSuchTableError)\ndynamo_table_item = self._get_iceberg_table_item(database_name=database_name, table_name=table_name)\nreturn self._convert_dynamo_table_item_to_iceberg_table(dynamo_table_item=dynamo_table_item)\ndef drop_table(self, identifier: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a table.\n        Args:\n            identifier: Table identifier.\n        Raises:\n            NoSuchTableError: If a table with the name does not exist, or the identifier is invalid.\n        \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier, NoSuchTableError)\ntry:\nself._delete_dynamo_item(\nnamespace=database_name,\nidentifier=f\"{database_name}.{table_name}\",\ncondition_expression=f\"attribute_exists({DYNAMODB_COL_IDENTIFIER})\",\n)\nexcept ConditionalCheckFailedException as e:\nraise NoSuchTableError(f\"Table does not exist: {database_name}.{table_name}\") from e\ndef rename_table(self, from_identifier: Union[str, Identifier], to_identifier: Union[str, Identifier]) -&gt; Table:\n\"\"\"Rename a fully classified table name.\n        This method can only rename Iceberg tables in AWS Glue.\n        Args:\n            from_identifier: Existing table identifier.\n            to_identifier: New table identifier.\n        Returns:\n            Table: the updated table instance with its metadata.\n        Raises:\n            ValueError: When from table identifier is invalid.\n            NoSuchTableError: When a table with the name does not exist.\n            NoSuchIcebergTableError: When from table is not a valid iceberg table.\n            NoSuchPropertyException: When from table miss some required properties.\n            NoSuchNamespaceError: When the destination namespace doesn't exist.\n        \"\"\"\nfrom_database_name, from_table_name = self.identifier_to_database_and_table(from_identifier, NoSuchTableError)\nto_database_name, to_table_name = self.identifier_to_database_and_table(to_identifier)\nfrom_table_item = self._get_iceberg_table_item(database_name=from_database_name, table_name=from_table_name)\ntry:\n# Verify that from_identifier is a valid iceberg table\nself._convert_dynamo_table_item_to_iceberg_table(dynamo_table_item=from_table_item)\nexcept NoSuchPropertyException as e:\nraise NoSuchPropertyException(\nf\"Failed to rename table {from_database_name}.{from_table_name} since it is missing required properties\"\n) from e\nexcept NoSuchIcebergTableError as e:\nraise NoSuchIcebergTableError(\nf\"Failed to rename table {from_database_name}.{from_table_name} since it is not a valid iceberg table\"\n) from e\nself._ensure_namespace_exists(database_name=from_database_name)\nself._ensure_namespace_exists(database_name=to_database_name)\ntry:\nself._put_dynamo_item(\nitem=_get_rename_table_item(\nfrom_dynamo_table_item=from_table_item, to_database_name=to_database_name, to_table_name=to_table_name\n),\ncondition_expression=f\"attribute_not_exists({DYNAMODB_COL_IDENTIFIER})\",\n)\nexcept ConditionalCheckFailedException as e:\nraise TableAlreadyExistsError(f\"Table {to_database_name}.{to_table_name} already exists\") from e\ntry:\nself.drop_table(from_identifier)\nexcept (NoSuchTableError, GenericDynamoDbError) as e:\nlog_message = f\"Failed to drop old table {from_database_name}.{from_table_name}. \"\ntry:\nself.drop_table(to_identifier)\nlog_message += f\"Rolled back table creation for {to_database_name}.{to_table_name}.\"\nexcept (NoSuchTableError, GenericDynamoDbError):\nlog_message += (\nf\"Failed to roll back table creation for {to_database_name}.{to_table_name}. \" f\"Please clean up manually\"\n)\nraise ValueError(log_message) from e\nreturn self.load_table(to_identifier)\ndef create_namespace(self, namespace: Union[str, Identifier], properties: Properties = EMPTY_DICT) -&gt; None:\n\"\"\"Create a namespace in the catalog.\n        Args:\n            namespace: Namespace identifier.\n            properties: A string dictionary of properties for the given namespace.\n        Raises:\n            ValueError: If the identifier is invalid.\n            AlreadyExistsError: If a namespace with the given name already exists.\n        \"\"\"\ndatabase_name = self.identifier_to_database(namespace)\ntry:\nself._put_dynamo_item(\nitem=_get_create_database_item(database_name=database_name, properties=properties),\ncondition_expression=f\"attribute_not_exists({DYNAMODB_COL_NAMESPACE})\",\n)\nexcept ConditionalCheckFailedException as e:\nraise NamespaceAlreadyExistsError(f\"Database {database_name} already exists\") from e\ndef drop_namespace(self, namespace: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a namespace.\n        A Glue namespace can only be dropped if it is empty.\n        Args:\n            namespace: Namespace identifier.\n        Raises:\n            NoSuchNamespaceError: If a namespace with the given name does not exist, or the identifier is invalid.\n            NamespaceNotEmptyError: If the namespace is not empty.\n        \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\ntable_identifiers = self.list_tables(namespace=database_name)\nif len(table_identifiers) &gt; 0:\nraise NamespaceNotEmptyError(f\"Database {database_name} is not empty\")\ntry:\nself._delete_dynamo_item(\nnamespace=database_name,\nidentifier=DYNAMODB_NAMESPACE,\ncondition_expression=f\"attribute_exists({DYNAMODB_COL_IDENTIFIER})\",\n)\nexcept ConditionalCheckFailedException as e:\nraise NoSuchNamespaceError(f\"Database does not exist: {database_name}\") from e\ndef list_tables(self, namespace: Union[str, Identifier]) -&gt; List[Identifier]:\n\"\"\"List tables under the given namespace in the catalog (including non-Iceberg tables).\n        Args:\n            namespace (str | Identifier): Namespace identifier to search.\n        Returns:\n            List[Identifier]: list of table identifiers.\n        \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\npaginator = self.dynamodb.get_paginator(\"query\")\ntry:\npage_iterator = paginator.paginate(\nTableName=self.dynamodb_table_name,\nIndexName=DYNAMODB_NAMESPACE_GSI,\nKeyConditionExpression=f\"{DYNAMODB_COL_NAMESPACE} = :namespace \",\nExpressionAttributeValues={\n\":namespace\": {\n\"S\": database_name,\n}\n},\n)\nexcept (\nself.dynamodb.exceptions.ProvisionedThroughputExceededException,\nself.dynamodb.exceptions.RequestLimitExceeded,\nself.dynamodb.exceptions.InternalServerError,\nself.dynamodb.exceptions.ResourceNotFoundException,\n) as e:\nraise GenericDynamoDbError(e.message) from e\ntable_identifiers = []\nfor page in page_iterator:\nfor item in page[\"Items\"]:\n_dict = _convert_dynamo_item_to_regular_dict(item)\nidentifier_col = _dict[DYNAMODB_COL_IDENTIFIER]\nif identifier_col == DYNAMODB_NAMESPACE:\ncontinue\ntable_identifiers.append(self.identifier_to_tuple(identifier_col))\nreturn table_identifiers\ndef list_namespaces(self, namespace: Union[str, Identifier] = ()) -&gt; List[Identifier]:\n\"\"\"List top-level namespaces from the catalog.\n        We do not support hierarchical namespace.\n        Returns:\n            List[Identifier]: a List of namespace identifiers.\n        \"\"\"\n# Hierarchical namespace is not supported. Return an empty list\nif namespace:\nreturn []\npaginator = self.dynamodb.get_paginator(\"query\")\ntry:\npage_iterator = paginator.paginate(\nTableName=self.dynamodb_table_name,\nConsistentRead=True,\nKeyConditionExpression=f\"{DYNAMODB_COL_IDENTIFIER} = :identifier\",\nExpressionAttributeValues={\n\":identifier\": {\n\"S\": DYNAMODB_NAMESPACE,\n}\n},\n)\nexcept (\nself.dynamodb.exceptions.ProvisionedThroughputExceededException,\nself.dynamodb.exceptions.RequestLimitExceeded,\nself.dynamodb.exceptions.InternalServerError,\nself.dynamodb.exceptions.ResourceNotFoundException,\n) as e:\nraise GenericDynamoDbError(e.message) from e\ndatabase_identifiers = []\nfor page in page_iterator:\nfor item in page[\"Items\"]:\n_dict = _convert_dynamo_item_to_regular_dict(item)\nnamespace_col = _dict[DYNAMODB_COL_NAMESPACE]\ndatabase_identifiers.append(self.identifier_to_tuple(namespace_col))\nreturn database_identifiers\ndef load_namespace_properties(self, namespace: Union[str, Identifier]) -&gt; Properties:\n\"\"\"\n        Get properties for a namespace.\n        Args:\n            namespace: Namespace identifier.\n        Returns:\n            Properties: Properties for the given namespace.\n        Raises:\n            NoSuchNamespaceError: If a namespace with the given name does not exist, or identifier is invalid.\n        \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\nnamespace_item = self._get_iceberg_namespace_item(database_name=database_name)\nnamespace_dict = _convert_dynamo_item_to_regular_dict(namespace_item)\nreturn _get_namespace_properties(namespace_dict=namespace_dict)\ndef update_namespace_properties(\nself, namespace: Union[str, Identifier], removals: Optional[Set[str]] = None, updates: Properties = EMPTY_DICT\n) -&gt; PropertiesUpdateSummary:\n\"\"\"\n        Removes or updates provided property keys for a namespace.\n        Args:\n            namespace: Namespace identifier\n            removals: Set of property keys that need to be removed. Optional Argument.\n            updates: Properties to be updated for the given namespace.\n        Raises:\n            NoSuchNamespaceError: If a namespace with the given name does not exist\uff0c or identifier is invalid.\n            ValueError: If removals and updates have overlapping keys.\n        \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\nnamespace_item = self._get_iceberg_namespace_item(database_name=database_name)\nnamespace_dict = _convert_dynamo_item_to_regular_dict(namespace_item)\ncurrent_properties = _get_namespace_properties(namespace_dict=namespace_dict)\nproperties_update_summary, updated_properties = self._get_updated_props_and_update_summary(\ncurrent_properties=current_properties, removals=removals, updates=updates\n)\ntry:\nself._put_dynamo_item(\nitem=_get_update_database_item(\nnamespace_item=namespace_item,\nupdated_properties=updated_properties,\n),\ncondition_expression=f\"attribute_exists({DYNAMODB_COL_NAMESPACE})\",\n)\nexcept ConditionalCheckFailedException as e:\nraise NoSuchNamespaceError(f\"Database {database_name} does not exist\") from e\nreturn properties_update_summary\ndef _get_iceberg_table_item(self, database_name: str, table_name: str) -&gt; Dict[str, Any]:\ntry:\nreturn self._get_dynamo_item(identifier=f\"{database_name}.{table_name}\", namespace=database_name)\nexcept ValueError as e:\nraise NoSuchTableError(f\"Table does not exist: {database_name}.{table_name}\") from e\ndef _get_iceberg_namespace_item(self, database_name: str) -&gt; Dict[str, Any]:\ntry:\nreturn self._get_dynamo_item(identifier=DYNAMODB_NAMESPACE, namespace=database_name)\nexcept ValueError as e:\nraise NoSuchNamespaceError(f\"Namespace does not exist: {database_name}\") from e\ndef _ensure_namespace_exists(self, database_name: str) -&gt; Dict[str, Any]:\nreturn self._get_iceberg_namespace_item(database_name)\ndef _get_dynamo_item(self, identifier: str, namespace: str) -&gt; Dict[str, Any]:\ntry:\nresponse = self.dynamodb.get_item(\nTableName=self.dynamodb_table_name,\nConsistentRead=True,\nKey={\nDYNAMODB_COL_IDENTIFIER: {\n\"S\": identifier,\n},\nDYNAMODB_COL_NAMESPACE: {\n\"S\": namespace,\n},\n},\n)\nif ITEM in response:\nreturn response[ITEM]\nelse:\nraise ValueError(f\"Item not found. identifier: {identifier} - namespace: {namespace}\")\nexcept self.dynamodb.exceptions.ResourceNotFoundException as e:\nraise ValueError(f\"Item not found. identifier: {identifier} - namespace: {namespace}\") from e\nexcept (\nself.dynamodb.exceptions.ProvisionedThroughputExceededException,\nself.dynamodb.exceptions.RequestLimitExceeded,\nself.dynamodb.exceptions.InternalServerError,\n) as e:\nraise GenericDynamoDbError(e.message) from e\ndef _put_dynamo_item(self, item: Dict[str, Any], condition_expression: str) -&gt; None:\ntry:\nself.dynamodb.put_item(TableName=self.dynamodb_table_name, Item=item, ConditionExpression=condition_expression)\nexcept self.dynamodb.exceptions.ConditionalCheckFailedException as e:\nraise ConditionalCheckFailedException(f\"Condition expression check failed: {condition_expression} - {item}\") from e\nexcept (\nself.dynamodb.exceptions.ProvisionedThroughputExceededException,\nself.dynamodb.exceptions.RequestLimitExceeded,\nself.dynamodb.exceptions.InternalServerError,\nself.dynamodb.exceptions.ResourceNotFoundException,\nself.dynamodb.exceptions.ItemCollectionSizeLimitExceededException,\nself.dynamodb.exceptions.TransactionConflictException,\n) as e:\nraise GenericDynamoDbError(e.message) from e\ndef _delete_dynamo_item(self, namespace: str, identifier: str, condition_expression: str) -&gt; None:\ntry:\nself.dynamodb.delete_item(\nTableName=self.dynamodb_table_name,\nKey={\nDYNAMODB_COL_IDENTIFIER: {\n\"S\": identifier,\n},\nDYNAMODB_COL_NAMESPACE: {\n\"S\": namespace,\n},\n},\nConditionExpression=condition_expression,\n)\nexcept self.dynamodb.exceptions.ConditionalCheckFailedException as e:\nraise ConditionalCheckFailedException(\nf\"Condition expression check failed: {condition_expression} - {identifier}\"\n) from e\nexcept (\nself.dynamodb.exceptions.ProvisionedThroughputExceededException,\nself.dynamodb.exceptions.RequestLimitExceeded,\nself.dynamodb.exceptions.InternalServerError,\nself.dynamodb.exceptions.ResourceNotFoundException,\nself.dynamodb.exceptions.ItemCollectionSizeLimitExceededException,\nself.dynamodb.exceptions.TransactionConflictException,\n) as e:\nraise GenericDynamoDbError(e.message) from e\ndef _convert_dynamo_table_item_to_iceberg_table(self, dynamo_table_item: Dict[str, Any]) -&gt; Table:\ntable_dict = _convert_dynamo_item_to_regular_dict(dynamo_table_item)\nfor prop in [_add_property_prefix(prop) for prop in (TABLE_TYPE, METADATA_LOCATION)] + [\nDYNAMODB_COL_IDENTIFIER,\nDYNAMODB_COL_NAMESPACE,\nDYNAMODB_COL_CREATED_AT,\n]:\nif prop not in table_dict.keys():\nraise NoSuchPropertyException(f\"Iceberg required property {prop} is missing: {dynamo_table_item}\")\ntable_type = table_dict[_add_property_prefix(TABLE_TYPE)]\nidentifier = table_dict[DYNAMODB_COL_IDENTIFIER]\nmetadata_location = table_dict[_add_property_prefix(METADATA_LOCATION)]\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier, NoSuchTableError)\nif table_type.lower() != ICEBERG:\nraise NoSuchIcebergTableError(\nf\"Property table_type is {table_type}, expected {ICEBERG}: \" f\"{database_name}.{table_name}\"\n)\nio = load_file_io(properties=self.properties, location=metadata_location)\nfile = io.new_input(metadata_location)\nmetadata = FromInputFile.table_metadata(file)\nreturn Table(\nidentifier=(self.name, database_name, table_name),\nmetadata=metadata,\nmetadata_location=metadata_location,\nio=self._load_file_io(metadata.properties, metadata_location),\ncatalog=self,\n)\n</code></pre>"},{"location":"reference/pyiceberg/catalog/dynamodb/#pyiceberg.catalog.dynamodb.DynamoDbCatalog.create_namespace","title":"<code>create_namespace(namespace, properties=EMPTY_DICT)</code>","text":"<p>Create a namespace in the catalog.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>Union[str, Identifier]</code> <p>Namespace identifier.</p> required <code>properties</code> <code>Properties</code> <p>A string dictionary of properties for the given namespace.</p> <code>EMPTY_DICT</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the identifier is invalid.</p> <code>AlreadyExistsError</code> <p>If a namespace with the given name already exists.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/dynamodb.py</code> <pre><code>def create_namespace(self, namespace: Union[str, Identifier], properties: Properties = EMPTY_DICT) -&gt; None:\n\"\"\"Create a namespace in the catalog.\n    Args:\n        namespace: Namespace identifier.\n        properties: A string dictionary of properties for the given namespace.\n    Raises:\n        ValueError: If the identifier is invalid.\n        AlreadyExistsError: If a namespace with the given name already exists.\n    \"\"\"\ndatabase_name = self.identifier_to_database(namespace)\ntry:\nself._put_dynamo_item(\nitem=_get_create_database_item(database_name=database_name, properties=properties),\ncondition_expression=f\"attribute_not_exists({DYNAMODB_COL_NAMESPACE})\",\n)\nexcept ConditionalCheckFailedException as e:\nraise NamespaceAlreadyExistsError(f\"Database {database_name} already exists\") from e\n</code></pre>"},{"location":"reference/pyiceberg/catalog/dynamodb/#pyiceberg.catalog.dynamodb.DynamoDbCatalog.create_table","title":"<code>create_table(identifier, schema, location=None, partition_spec=UNPARTITIONED_PARTITION_SPEC, sort_order=UNSORTED_SORT_ORDER, properties=EMPTY_DICT)</code>","text":"<p>Create an Iceberg table.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Union[str, Identifier]</code> <p>Table identifier.</p> required <code>schema</code> <code>Schema</code> <p>Table's schema.</p> required <code>location</code> <code>Optional[str]</code> <p>Location for the table. Optional Argument.</p> <code>None</code> <code>partition_spec</code> <code>PartitionSpec</code> <p>PartitionSpec for the table.</p> <code>UNPARTITIONED_PARTITION_SPEC</code> <code>sort_order</code> <code>SortOrder</code> <p>SortOrder for the table.</p> <code>UNSORTED_SORT_ORDER</code> <code>properties</code> <code>Properties</code> <p>Table properties that can be a string based dictionary.</p> <code>EMPTY_DICT</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>the created table instance.</p> <p>Raises:</p> Type Description <code>AlreadyExistsError</code> <p>If a table with the name already exists.</p> <code>ValueError</code> <p>If the identifier is invalid, or no path is given to store metadata.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/dynamodb.py</code> <pre><code>def create_table(\nself,\nidentifier: Union[str, Identifier],\nschema: Schema,\nlocation: Optional[str] = None,\npartition_spec: PartitionSpec = UNPARTITIONED_PARTITION_SPEC,\nsort_order: SortOrder = UNSORTED_SORT_ORDER,\nproperties: Properties = EMPTY_DICT,\n) -&gt; Table:\n\"\"\"\n    Create an Iceberg table.\n    Args:\n        identifier: Table identifier.\n        schema: Table's schema.\n        location: Location for the table. Optional Argument.\n        partition_spec: PartitionSpec for the table.\n        sort_order: SortOrder for the table.\n        properties: Table properties that can be a string based dictionary.\n    Returns:\n        Table: the created table instance.\n    Raises:\n        AlreadyExistsError: If a table with the name already exists.\n        ValueError: If the identifier is invalid, or no path is given to store metadata.\n    \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier)\nlocation = self._resolve_table_location(location, database_name, table_name)\nmetadata_location = self._get_metadata_location(location=location)\nmetadata = new_table_metadata(\nlocation=location, schema=schema, partition_spec=partition_spec, sort_order=sort_order, properties=properties\n)\nio = load_file_io(properties=self.properties, location=metadata_location)\nself._write_metadata(metadata, io, metadata_location)\nself._ensure_namespace_exists(database_name=database_name)\ntry:\nself._put_dynamo_item(\nitem=_get_create_table_item(\ndatabase_name=database_name, table_name=table_name, properties=properties, metadata_location=metadata_location\n),\ncondition_expression=f\"attribute_not_exists({DYNAMODB_COL_IDENTIFIER})\",\n)\nexcept ConditionalCheckFailedException as e:\nraise TableAlreadyExistsError(f\"Table {database_name}.{table_name} already exists\") from e\nreturn self.load_table(identifier=identifier)\n</code></pre>"},{"location":"reference/pyiceberg/catalog/dynamodb/#pyiceberg.catalog.dynamodb.DynamoDbCatalog.drop_namespace","title":"<code>drop_namespace(namespace)</code>","text":"<p>Drop a namespace.</p> <p>A Glue namespace can only be dropped if it is empty.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>Union[str, Identifier]</code> <p>Namespace identifier.</p> required <p>Raises:</p> Type Description <code>NoSuchNamespaceError</code> <p>If a namespace with the given name does not exist, or the identifier is invalid.</p> <code>NamespaceNotEmptyError</code> <p>If the namespace is not empty.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/dynamodb.py</code> <pre><code>def drop_namespace(self, namespace: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a namespace.\n    A Glue namespace can only be dropped if it is empty.\n    Args:\n        namespace: Namespace identifier.\n    Raises:\n        NoSuchNamespaceError: If a namespace with the given name does not exist, or the identifier is invalid.\n        NamespaceNotEmptyError: If the namespace is not empty.\n    \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\ntable_identifiers = self.list_tables(namespace=database_name)\nif len(table_identifiers) &gt; 0:\nraise NamespaceNotEmptyError(f\"Database {database_name} is not empty\")\ntry:\nself._delete_dynamo_item(\nnamespace=database_name,\nidentifier=DYNAMODB_NAMESPACE,\ncondition_expression=f\"attribute_exists({DYNAMODB_COL_IDENTIFIER})\",\n)\nexcept ConditionalCheckFailedException as e:\nraise NoSuchNamespaceError(f\"Database does not exist: {database_name}\") from e\n</code></pre>"},{"location":"reference/pyiceberg/catalog/dynamodb/#pyiceberg.catalog.dynamodb.DynamoDbCatalog.drop_table","title":"<code>drop_table(identifier)</code>","text":"<p>Drop a table.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Union[str, Identifier]</code> <p>Table identifier.</p> required <p>Raises:</p> Type Description <code>NoSuchTableError</code> <p>If a table with the name does not exist, or the identifier is invalid.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/dynamodb.py</code> <pre><code>def drop_table(self, identifier: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a table.\n    Args:\n        identifier: Table identifier.\n    Raises:\n        NoSuchTableError: If a table with the name does not exist, or the identifier is invalid.\n    \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier, NoSuchTableError)\ntry:\nself._delete_dynamo_item(\nnamespace=database_name,\nidentifier=f\"{database_name}.{table_name}\",\ncondition_expression=f\"attribute_exists({DYNAMODB_COL_IDENTIFIER})\",\n)\nexcept ConditionalCheckFailedException as e:\nraise NoSuchTableError(f\"Table does not exist: {database_name}.{table_name}\") from e\n</code></pre>"},{"location":"reference/pyiceberg/catalog/dynamodb/#pyiceberg.catalog.dynamodb.DynamoDbCatalog.list_namespaces","title":"<code>list_namespaces(namespace=())</code>","text":"<p>List top-level namespaces from the catalog.</p> <p>We do not support hierarchical namespace.</p> <p>Returns:</p> Type Description <code>List[Identifier]</code> <p>List[Identifier]: a List of namespace identifiers.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/dynamodb.py</code> <pre><code>def list_namespaces(self, namespace: Union[str, Identifier] = ()) -&gt; List[Identifier]:\n\"\"\"List top-level namespaces from the catalog.\n    We do not support hierarchical namespace.\n    Returns:\n        List[Identifier]: a List of namespace identifiers.\n    \"\"\"\n# Hierarchical namespace is not supported. Return an empty list\nif namespace:\nreturn []\npaginator = self.dynamodb.get_paginator(\"query\")\ntry:\npage_iterator = paginator.paginate(\nTableName=self.dynamodb_table_name,\nConsistentRead=True,\nKeyConditionExpression=f\"{DYNAMODB_COL_IDENTIFIER} = :identifier\",\nExpressionAttributeValues={\n\":identifier\": {\n\"S\": DYNAMODB_NAMESPACE,\n}\n},\n)\nexcept (\nself.dynamodb.exceptions.ProvisionedThroughputExceededException,\nself.dynamodb.exceptions.RequestLimitExceeded,\nself.dynamodb.exceptions.InternalServerError,\nself.dynamodb.exceptions.ResourceNotFoundException,\n) as e:\nraise GenericDynamoDbError(e.message) from e\ndatabase_identifiers = []\nfor page in page_iterator:\nfor item in page[\"Items\"]:\n_dict = _convert_dynamo_item_to_regular_dict(item)\nnamespace_col = _dict[DYNAMODB_COL_NAMESPACE]\ndatabase_identifiers.append(self.identifier_to_tuple(namespace_col))\nreturn database_identifiers\n</code></pre>"},{"location":"reference/pyiceberg/catalog/dynamodb/#pyiceberg.catalog.dynamodb.DynamoDbCatalog.list_tables","title":"<code>list_tables(namespace)</code>","text":"<p>List tables under the given namespace in the catalog (including non-Iceberg tables).</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str | Identifier</code> <p>Namespace identifier to search.</p> required <p>Returns:</p> Type Description <code>List[Identifier]</code> <p>List[Identifier]: list of table identifiers.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/dynamodb.py</code> <pre><code>def list_tables(self, namespace: Union[str, Identifier]) -&gt; List[Identifier]:\n\"\"\"List tables under the given namespace in the catalog (including non-Iceberg tables).\n    Args:\n        namespace (str | Identifier): Namespace identifier to search.\n    Returns:\n        List[Identifier]: list of table identifiers.\n    \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\npaginator = self.dynamodb.get_paginator(\"query\")\ntry:\npage_iterator = paginator.paginate(\nTableName=self.dynamodb_table_name,\nIndexName=DYNAMODB_NAMESPACE_GSI,\nKeyConditionExpression=f\"{DYNAMODB_COL_NAMESPACE} = :namespace \",\nExpressionAttributeValues={\n\":namespace\": {\n\"S\": database_name,\n}\n},\n)\nexcept (\nself.dynamodb.exceptions.ProvisionedThroughputExceededException,\nself.dynamodb.exceptions.RequestLimitExceeded,\nself.dynamodb.exceptions.InternalServerError,\nself.dynamodb.exceptions.ResourceNotFoundException,\n) as e:\nraise GenericDynamoDbError(e.message) from e\ntable_identifiers = []\nfor page in page_iterator:\nfor item in page[\"Items\"]:\n_dict = _convert_dynamo_item_to_regular_dict(item)\nidentifier_col = _dict[DYNAMODB_COL_IDENTIFIER]\nif identifier_col == DYNAMODB_NAMESPACE:\ncontinue\ntable_identifiers.append(self.identifier_to_tuple(identifier_col))\nreturn table_identifiers\n</code></pre>"},{"location":"reference/pyiceberg/catalog/dynamodb/#pyiceberg.catalog.dynamodb.DynamoDbCatalog.load_namespace_properties","title":"<code>load_namespace_properties(namespace)</code>","text":"<p>Get properties for a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>Union[str, Identifier]</code> <p>Namespace identifier.</p> required <p>Returns:</p> Name Type Description <code>Properties</code> <code>Properties</code> <p>Properties for the given namespace.</p> <p>Raises:</p> Type Description <code>NoSuchNamespaceError</code> <p>If a namespace with the given name does not exist, or identifier is invalid.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/dynamodb.py</code> <pre><code>def load_namespace_properties(self, namespace: Union[str, Identifier]) -&gt; Properties:\n\"\"\"\n    Get properties for a namespace.\n    Args:\n        namespace: Namespace identifier.\n    Returns:\n        Properties: Properties for the given namespace.\n    Raises:\n        NoSuchNamespaceError: If a namespace with the given name does not exist, or identifier is invalid.\n    \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\nnamespace_item = self._get_iceberg_namespace_item(database_name=database_name)\nnamespace_dict = _convert_dynamo_item_to_regular_dict(namespace_item)\nreturn _get_namespace_properties(namespace_dict=namespace_dict)\n</code></pre>"},{"location":"reference/pyiceberg/catalog/dynamodb/#pyiceberg.catalog.dynamodb.DynamoDbCatalog.load_table","title":"<code>load_table(identifier)</code>","text":"<p>Loads the table's metadata and returns the table instance.</p> <p>You can also use this method to check for table existence using 'try catalog.table() except TableNotFoundError'. Note: This method doesn't scan data stored in the table.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Union[str, Identifier]</code> <p>Table identifier.</p> required <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>the table instance with its metadata.</p> <p>Raises:</p> Type Description <code>NoSuchTableError</code> <p>If a table with the name does not exist, or the identifier is invalid.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/dynamodb.py</code> <pre><code>def load_table(self, identifier: Union[str, Identifier]) -&gt; Table:\n\"\"\"\n    Loads the table's metadata and returns the table instance.\n    You can also use this method to check for table existence using 'try catalog.table() except TableNotFoundError'.\n    Note: This method doesn't scan data stored in the table.\n    Args:\n        identifier: Table identifier.\n    Returns:\n        Table: the table instance with its metadata.\n    Raises:\n        NoSuchTableError: If a table with the name does not exist, or the identifier is invalid.\n    \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier, NoSuchTableError)\ndynamo_table_item = self._get_iceberg_table_item(database_name=database_name, table_name=table_name)\nreturn self._convert_dynamo_table_item_to_iceberg_table(dynamo_table_item=dynamo_table_item)\n</code></pre>"},{"location":"reference/pyiceberg/catalog/dynamodb/#pyiceberg.catalog.dynamodb.DynamoDbCatalog.rename_table","title":"<code>rename_table(from_identifier, to_identifier)</code>","text":"<p>Rename a fully classified table name.</p> <p>This method can only rename Iceberg tables in AWS Glue.</p> <p>Parameters:</p> Name Type Description Default <code>from_identifier</code> <code>Union[str, Identifier]</code> <p>Existing table identifier.</p> required <code>to_identifier</code> <code>Union[str, Identifier]</code> <p>New table identifier.</p> required <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>the updated table instance with its metadata.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When from table identifier is invalid.</p> <code>NoSuchTableError</code> <p>When a table with the name does not exist.</p> <code>NoSuchIcebergTableError</code> <p>When from table is not a valid iceberg table.</p> <code>NoSuchPropertyException</code> <p>When from table miss some required properties.</p> <code>NoSuchNamespaceError</code> <p>When the destination namespace doesn't exist.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/dynamodb.py</code> <pre><code>def rename_table(self, from_identifier: Union[str, Identifier], to_identifier: Union[str, Identifier]) -&gt; Table:\n\"\"\"Rename a fully classified table name.\n    This method can only rename Iceberg tables in AWS Glue.\n    Args:\n        from_identifier: Existing table identifier.\n        to_identifier: New table identifier.\n    Returns:\n        Table: the updated table instance with its metadata.\n    Raises:\n        ValueError: When from table identifier is invalid.\n        NoSuchTableError: When a table with the name does not exist.\n        NoSuchIcebergTableError: When from table is not a valid iceberg table.\n        NoSuchPropertyException: When from table miss some required properties.\n        NoSuchNamespaceError: When the destination namespace doesn't exist.\n    \"\"\"\nfrom_database_name, from_table_name = self.identifier_to_database_and_table(from_identifier, NoSuchTableError)\nto_database_name, to_table_name = self.identifier_to_database_and_table(to_identifier)\nfrom_table_item = self._get_iceberg_table_item(database_name=from_database_name, table_name=from_table_name)\ntry:\n# Verify that from_identifier is a valid iceberg table\nself._convert_dynamo_table_item_to_iceberg_table(dynamo_table_item=from_table_item)\nexcept NoSuchPropertyException as e:\nraise NoSuchPropertyException(\nf\"Failed to rename table {from_database_name}.{from_table_name} since it is missing required properties\"\n) from e\nexcept NoSuchIcebergTableError as e:\nraise NoSuchIcebergTableError(\nf\"Failed to rename table {from_database_name}.{from_table_name} since it is not a valid iceberg table\"\n) from e\nself._ensure_namespace_exists(database_name=from_database_name)\nself._ensure_namespace_exists(database_name=to_database_name)\ntry:\nself._put_dynamo_item(\nitem=_get_rename_table_item(\nfrom_dynamo_table_item=from_table_item, to_database_name=to_database_name, to_table_name=to_table_name\n),\ncondition_expression=f\"attribute_not_exists({DYNAMODB_COL_IDENTIFIER})\",\n)\nexcept ConditionalCheckFailedException as e:\nraise TableAlreadyExistsError(f\"Table {to_database_name}.{to_table_name} already exists\") from e\ntry:\nself.drop_table(from_identifier)\nexcept (NoSuchTableError, GenericDynamoDbError) as e:\nlog_message = f\"Failed to drop old table {from_database_name}.{from_table_name}. \"\ntry:\nself.drop_table(to_identifier)\nlog_message += f\"Rolled back table creation for {to_database_name}.{to_table_name}.\"\nexcept (NoSuchTableError, GenericDynamoDbError):\nlog_message += (\nf\"Failed to roll back table creation for {to_database_name}.{to_table_name}. \" f\"Please clean up manually\"\n)\nraise ValueError(log_message) from e\nreturn self.load_table(to_identifier)\n</code></pre>"},{"location":"reference/pyiceberg/catalog/dynamodb/#pyiceberg.catalog.dynamodb.DynamoDbCatalog.update_namespace_properties","title":"<code>update_namespace_properties(namespace, removals=None, updates=EMPTY_DICT)</code>","text":"<p>Removes or updates provided property keys for a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>Union[str, Identifier]</code> <p>Namespace identifier</p> required <code>removals</code> <code>Optional[Set[str]]</code> <p>Set of property keys that need to be removed. Optional Argument.</p> <code>None</code> <code>updates</code> <code>Properties</code> <p>Properties to be updated for the given namespace.</p> <code>EMPTY_DICT</code> <p>Raises:</p> Type Description <code>NoSuchNamespaceError</code> <p>If a namespace with the given name does not exist\uff0c or identifier is invalid.</p> <code>ValueError</code> <p>If removals and updates have overlapping keys.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/dynamodb.py</code> <pre><code>def update_namespace_properties(\nself, namespace: Union[str, Identifier], removals: Optional[Set[str]] = None, updates: Properties = EMPTY_DICT\n) -&gt; PropertiesUpdateSummary:\n\"\"\"\n    Removes or updates provided property keys for a namespace.\n    Args:\n        namespace: Namespace identifier\n        removals: Set of property keys that need to be removed. Optional Argument.\n        updates: Properties to be updated for the given namespace.\n    Raises:\n        NoSuchNamespaceError: If a namespace with the given name does not exist\uff0c or identifier is invalid.\n        ValueError: If removals and updates have overlapping keys.\n    \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\nnamespace_item = self._get_iceberg_namespace_item(database_name=database_name)\nnamespace_dict = _convert_dynamo_item_to_regular_dict(namespace_item)\ncurrent_properties = _get_namespace_properties(namespace_dict=namespace_dict)\nproperties_update_summary, updated_properties = self._get_updated_props_and_update_summary(\ncurrent_properties=current_properties, removals=removals, updates=updates\n)\ntry:\nself._put_dynamo_item(\nitem=_get_update_database_item(\nnamespace_item=namespace_item,\nupdated_properties=updated_properties,\n),\ncondition_expression=f\"attribute_exists({DYNAMODB_COL_NAMESPACE})\",\n)\nexcept ConditionalCheckFailedException as e:\nraise NoSuchNamespaceError(f\"Database {database_name} does not exist\") from e\nreturn properties_update_summary\n</code></pre>"},{"location":"reference/pyiceberg/catalog/glue/","title":"glue","text":""},{"location":"reference/pyiceberg/catalog/glue/#pyiceberg.catalog.glue.GlueCatalog","title":"<code>GlueCatalog</code>","text":"<p>         Bases: <code>Catalog</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/glue.py</code> <pre><code>class GlueCatalog(Catalog):\ndef __init__(self, name: str, **properties: str):\nsuper().__init__(name, **properties)\nsession_config = {k: v for k, v in properties.items() if k in BOTO_SESSION_CONFIG_KEYS}\nsession = boto3.Session(**session_config)\nself.glue = session.client(GLUE_CLIENT)\ndef _convert_glue_to_iceberg(self, glue_table: Dict[str, Any]) -&gt; Table:\nproperties: Properties = glue_table.get(PROP_GLUE_TABLE_PARAMETERS, {})\nif TABLE_TYPE not in properties:\nraise NoSuchPropertyException(\nf\"Property {TABLE_TYPE} missing, could not determine type: \"\nf\"{glue_table[PROP_GLUE_TABLE_DATABASE_NAME]}.{glue_table[PROP_GLUE_TABLE_NAME]}\"\n)\nglue_table_type = properties[TABLE_TYPE]\nif glue_table_type.lower() != ICEBERG:\nraise NoSuchIcebergTableError(\nf\"Property table_type is {glue_table_type}, expected {ICEBERG}: \"\nf\"{glue_table[PROP_GLUE_TABLE_DATABASE_NAME]}.{glue_table[PROP_GLUE_TABLE_NAME]}\"\n)\nif METADATA_LOCATION not in properties:\nraise NoSuchPropertyException(\nf\"Table property {METADATA_LOCATION} is missing, cannot find metadata for: \"\nf\"{glue_table[PROP_GLUE_TABLE_DATABASE_NAME]}.{glue_table[PROP_GLUE_TABLE_NAME]}\"\n)\nmetadata_location = properties[METADATA_LOCATION]\nio = load_file_io(properties=self.properties, location=metadata_location)\nfile = io.new_input(metadata_location)\nmetadata = FromInputFile.table_metadata(file)\nreturn Table(\nidentifier=(glue_table[PROP_GLUE_TABLE_DATABASE_NAME], glue_table[PROP_GLUE_TABLE_NAME]),\nmetadata=metadata,\nmetadata_location=metadata_location,\nio=self._load_file_io(metadata.properties, metadata_location),\ncatalog=self,\n)\ndef _create_glue_table(self, database_name: str, table_name: str, table_input: Dict[str, Any]) -&gt; None:\ntry:\nself.glue.create_table(DatabaseName=database_name, TableInput=table_input)\nexcept self.glue.exceptions.AlreadyExistsException as e:\nraise TableAlreadyExistsError(f\"Table {database_name}.{table_name} already exists\") from e\nexcept self.glue.exceptions.EntityNotFoundException as e:\nraise NoSuchNamespaceError(f\"Database {database_name} does not exist\") from e\ndef create_table(\nself,\nidentifier: Union[str, Identifier],\nschema: Schema,\nlocation: Optional[str] = None,\npartition_spec: PartitionSpec = UNPARTITIONED_PARTITION_SPEC,\nsort_order: SortOrder = UNSORTED_SORT_ORDER,\nproperties: Properties = EMPTY_DICT,\n) -&gt; Table:\n\"\"\"\n        Create an Iceberg table.\n        Args:\n            identifier: Table identifier.\n            schema: Table's schema.\n            location: Location for the table. Optional Argument.\n            partition_spec: PartitionSpec for the table.\n            sort_order: SortOrder for the table.\n            properties: Table properties that can be a string based dictionary.\n        Returns:\n            Table: the created table instance.\n        Raises:\n            AlreadyExistsError: If a table with the name already exists.\n            ValueError: If the identifier is invalid, or no path is given to store metadata.\n        \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier)\nlocation = self._resolve_table_location(location, database_name, table_name)\nmetadata_location = self._get_metadata_location(location=location)\nmetadata = new_table_metadata(\nlocation=location, schema=schema, partition_spec=partition_spec, sort_order=sort_order, properties=properties\n)\nio = load_file_io(properties=self.properties, location=metadata_location)\nself._write_metadata(metadata, io, metadata_location)\ntable_input = _construct_create_table_input(table_name, metadata_location, properties)\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier)\nself._create_glue_table(database_name=database_name, table_name=table_name, table_input=table_input)\nreturn self.load_table(identifier=identifier)\ndef _commit_table(self, table_request: CommitTableRequest) -&gt; CommitTableResponse:\n\"\"\"Updates the table.\n        Args:\n            table_request (CommitTableRequest): The table requests to be carried out.\n        Returns:\n            CommitTableResponse: The updated metadata.\n        Raises:\n            NoSuchTableError: If a table with the given identifier does not exist.\n        \"\"\"\nraise NotImplementedError\ndef load_table(self, identifier: Union[str, Identifier]) -&gt; Table:\n\"\"\"Loads the table's metadata and returns the table instance.\n        You can also use this method to check for table existence using 'try catalog.table() except TableNotFoundError'.\n        Note: This method doesn't scan data stored in the table.\n        Args:\n            identifier: Table identifier.\n        Returns:\n            Table: the table instance with its metadata.\n        Raises:\n            NoSuchTableError: If a table with the name does not exist, or the identifier is invalid.\n        \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier, NoSuchTableError)\ntry:\nload_table_response = self.glue.get_table(DatabaseName=database_name, Name=table_name)\nexcept self.glue.exceptions.EntityNotFoundException as e:\nraise NoSuchTableError(f\"Table does not exist: {database_name}.{table_name}\") from e\nreturn self._convert_glue_to_iceberg(load_table_response.get(PROP_GLUE_TABLE, {}))\ndef drop_table(self, identifier: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a table.\n        Args:\n            identifier: Table identifier.\n        Raises:\n            NoSuchTableError: If a table with the name does not exist, or the identifier is invalid.\n        \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier, NoSuchTableError)\ntry:\nself.glue.delete_table(DatabaseName=database_name, Name=table_name)\nexcept self.glue.exceptions.EntityNotFoundException as e:\nraise NoSuchTableError(f\"Table does not exist: {database_name}.{table_name}\") from e\ndef rename_table(self, from_identifier: Union[str, Identifier], to_identifier: Union[str, Identifier]) -&gt; Table:\n\"\"\"Rename a fully classified table name.\n        This method can only rename Iceberg tables in AWS Glue.\n        Args:\n            from_identifier: Existing table identifier.\n            to_identifier: New table identifier.\n        Returns:\n            Table: the updated table instance with its metadata.\n        Raises:\n            ValueError: When from table identifier is invalid.\n            NoSuchTableError: When a table with the name does not exist.\n            NoSuchIcebergTableError: When from table is not a valid iceberg table.\n            NoSuchPropertyException: When from table miss some required properties.\n            NoSuchNamespaceError: When the destination namespace doesn't exist.\n        \"\"\"\nfrom_database_name, from_table_name = self.identifier_to_database_and_table(from_identifier, NoSuchTableError)\nto_database_name, to_table_name = self.identifier_to_database_and_table(to_identifier)\ntry:\nget_table_response = self.glue.get_table(DatabaseName=from_database_name, Name=from_table_name)\nexcept self.glue.exceptions.EntityNotFoundException as e:\nraise NoSuchTableError(f\"Table does not exist: {from_database_name}.{from_table_name}\") from e\nglue_table = get_table_response[PROP_GLUE_TABLE]\ntry:\n# verify that from_identifier is a valid iceberg table\nself._convert_glue_to_iceberg(glue_table=glue_table)\nexcept NoSuchPropertyException as e:\nraise NoSuchPropertyException(\nf\"Failed to rename table {from_database_name}.{from_table_name} since it is missing required properties\"\n) from e\nexcept NoSuchIcebergTableError as e:\nraise NoSuchIcebergTableError(\nf\"Failed to rename table {from_database_name}.{from_table_name} since it is not a valid iceberg table\"\n) from e\nrename_table_input = _construct_rename_table_input(to_table_name=to_table_name, glue_table=glue_table)\nself._create_glue_table(database_name=to_database_name, table_name=to_table_name, table_input=rename_table_input)\ntry:\nself.drop_table(from_identifier)\nexcept Exception as e:\nlog_message = f\"Failed to drop old table {from_database_name}.{from_table_name}. \"\ntry:\nself.drop_table(to_identifier)\nlog_message += f\"Rolled back table creation for {to_database_name}.{to_table_name}.\"\nexcept NoSuchTableError:\nlog_message += (\nf\"Failed to roll back table creation for {to_database_name}.{to_table_name}. \" f\"Please clean up manually\"\n)\nraise ValueError(log_message) from e\nreturn self.load_table(to_identifier)\ndef create_namespace(self, namespace: Union[str, Identifier], properties: Properties = EMPTY_DICT) -&gt; None:\n\"\"\"Create a namespace in the catalog.\n        Args:\n            namespace: Namespace identifier.\n            properties: A string dictionary of properties for the given namespace.\n        Raises:\n            ValueError: If the identifier is invalid.\n            AlreadyExistsError: If a namespace with the given name already exists.\n        \"\"\"\ndatabase_name = self.identifier_to_database(namespace)\ntry:\nself.glue.create_database(DatabaseInput=_construct_database_input(database_name, properties))\nexcept self.glue.exceptions.AlreadyExistsException as e:\nraise NamespaceAlreadyExistsError(f\"Database {database_name} already exists\") from e\ndef drop_namespace(self, namespace: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a namespace.\n        A Glue namespace can only be dropped if it is empty.\n        Args:\n            namespace: Namespace identifier.\n        Raises:\n            NoSuchNamespaceError: If a namespace with the given name does not exist, or the identifier is invalid.\n            NamespaceNotEmptyError: If the namespace is not empty.\n        \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\ntry:\ntable_list = self.list_tables(namespace=database_name)\nexcept NoSuchNamespaceError as e:\nraise NoSuchNamespaceError(f\"Database does not exist: {database_name}\") from e\nif len(table_list) &gt; 0:\nraise NamespaceNotEmptyError(f\"Database {database_name} is not empty\")\nself.glue.delete_database(Name=database_name)\ndef list_tables(self, namespace: Union[str, Identifier]) -&gt; List[Identifier]:\n\"\"\"List tables under the given namespace in the catalog (including non-Iceberg tables).\n        Args:\n            namespace (str | Identifier): Namespace identifier to search.\n        Returns:\n            List[Identifier]: list of table identifiers.\n        Raises:\n            NoSuchNamespaceError: If a namespace with the given name does not exist, or the identifier is invalid.\n        \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\ntable_list = []\ntry:\ntable_list_response = self.glue.get_tables(DatabaseName=database_name)\nnext_token = table_list_response.get(PROP_GLUE_NEXT_TOKEN)\ntable_list += table_list_response.get(PROP_GLUE_TABLELIST, [])\nwhile next_token:\ntable_list_response = self.glue.get_tables(DatabaseName=database_name, NextToken=next_token)\nnext_token = table_list_response.get(PROP_GLUE_NEXT_TOKEN)\ntable_list += table_list_response.get(PROP_GLUE_TABLELIST, [])\nexcept self.glue.exceptions.EntityNotFoundException as e:\nraise NoSuchNamespaceError(f\"Database does not exist: {database_name}\") from e\nreturn [(database_name, table.get(PROP_GLUE_TABLE_NAME)) for table in table_list]\ndef list_namespaces(self, namespace: Union[str, Identifier] = ()) -&gt; List[Identifier]:\n\"\"\"List namespaces from the given namespace. If not given, list top-level namespaces from the catalog.\n        Returns:\n            List[Identifier]: a List of namespace identifiers.\n        \"\"\"\n# Hierarchical namespace is not supported. Return an empty list\nif namespace:\nreturn []\ndatabase_list = []\ndatabases_response = self.glue.get_databases()\nnext_token = databases_response.get(PROP_GLUE_NEXT_TOKEN)\ndatabase_list += databases_response.get(PROP_GLUE_DATABASE_LIST, [])\nwhile next_token:\ndatabases_response = self.glue.get_databases(NextToken=next_token)\nnext_token = databases_response.get(PROP_GLUE_NEXT_TOKEN)\ndatabase_list += databases_response.get(PROP_GLUE_DATABASE_LIST, [])\nreturn [self.identifier_to_tuple(database.get(PROP_GLUE_DATABASE_NAME)) for database in database_list]\ndef load_namespace_properties(self, namespace: Union[str, Identifier]) -&gt; Properties:\n\"\"\"Get properties for a namespace.\n        Args:\n            namespace: Namespace identifier.\n        Returns:\n            Properties: Properties for the given namespace.\n        Raises:\n            NoSuchNamespaceError: If a namespace with the given name does not exist, or identifier is invalid.\n        \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\ntry:\ndatabase_response = self.glue.get_database(Name=database_name)\nexcept self.glue.exceptions.EntityNotFoundException as e:\nraise NoSuchNamespaceError(f\"Database does not exist: {database_name}\") from e\nexcept self.glue.exceptions.InvalidInputException as e:\nraise NoSuchNamespaceError(f\"Invalid input for namespace {database_name}\") from e\ndatabase = database_response[PROP_GLUE_DATABASE]\nif PROP_GLUE_DATABASE_PARAMETERS not in database:\nreturn {}\nproperties = dict(database[PROP_GLUE_DATABASE_PARAMETERS])\nif database_location := database.get(PROP_GLUE_DATABASE_LOCATION):\nproperties[LOCATION] = database_location\nif database_description := database.get(PROP_GLUE_DATABASE_DESCRIPTION):\nproperties[GLUE_DESCRIPTION_KEY] = database_description\nreturn properties\ndef update_namespace_properties(\nself, namespace: Union[str, Identifier], removals: Optional[Set[str]] = None, updates: Properties = EMPTY_DICT\n) -&gt; PropertiesUpdateSummary:\n\"\"\"Removes provided property keys and updates properties for a namespace.\n        Args:\n            namespace: Namespace identifier.\n            removals: Set of property keys that need to be removed. Optional Argument.\n            updates: Properties to be updated for the given namespace.\n        Raises:\n            NoSuchNamespaceError: If a namespace with the given name does not exist\uff0c or identifier is invalid.\n            ValueError: If removals and updates have overlapping keys.\n        \"\"\"\ncurrent_properties = self.load_namespace_properties(namespace=namespace)\nproperties_update_summary, updated_properties = self._get_updated_props_and_update_summary(\ncurrent_properties=current_properties, removals=removals, updates=updates\n)\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\nself.glue.update_database(Name=database_name, DatabaseInput=_construct_database_input(database_name, updated_properties))\nreturn properties_update_summary\n</code></pre>"},{"location":"reference/pyiceberg/catalog/glue/#pyiceberg.catalog.glue.GlueCatalog.create_namespace","title":"<code>create_namespace(namespace, properties=EMPTY_DICT)</code>","text":"<p>Create a namespace in the catalog.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>Union[str, Identifier]</code> <p>Namespace identifier.</p> required <code>properties</code> <code>Properties</code> <p>A string dictionary of properties for the given namespace.</p> <code>EMPTY_DICT</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the identifier is invalid.</p> <code>AlreadyExistsError</code> <p>If a namespace with the given name already exists.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/glue.py</code> <pre><code>def create_namespace(self, namespace: Union[str, Identifier], properties: Properties = EMPTY_DICT) -&gt; None:\n\"\"\"Create a namespace in the catalog.\n    Args:\n        namespace: Namespace identifier.\n        properties: A string dictionary of properties for the given namespace.\n    Raises:\n        ValueError: If the identifier is invalid.\n        AlreadyExistsError: If a namespace with the given name already exists.\n    \"\"\"\ndatabase_name = self.identifier_to_database(namespace)\ntry:\nself.glue.create_database(DatabaseInput=_construct_database_input(database_name, properties))\nexcept self.glue.exceptions.AlreadyExistsException as e:\nraise NamespaceAlreadyExistsError(f\"Database {database_name} already exists\") from e\n</code></pre>"},{"location":"reference/pyiceberg/catalog/glue/#pyiceberg.catalog.glue.GlueCatalog.create_table","title":"<code>create_table(identifier, schema, location=None, partition_spec=UNPARTITIONED_PARTITION_SPEC, sort_order=UNSORTED_SORT_ORDER, properties=EMPTY_DICT)</code>","text":"<p>Create an Iceberg table.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Union[str, Identifier]</code> <p>Table identifier.</p> required <code>schema</code> <code>Schema</code> <p>Table's schema.</p> required <code>location</code> <code>Optional[str]</code> <p>Location for the table. Optional Argument.</p> <code>None</code> <code>partition_spec</code> <code>PartitionSpec</code> <p>PartitionSpec for the table.</p> <code>UNPARTITIONED_PARTITION_SPEC</code> <code>sort_order</code> <code>SortOrder</code> <p>SortOrder for the table.</p> <code>UNSORTED_SORT_ORDER</code> <code>properties</code> <code>Properties</code> <p>Table properties that can be a string based dictionary.</p> <code>EMPTY_DICT</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>the created table instance.</p> <p>Raises:</p> Type Description <code>AlreadyExistsError</code> <p>If a table with the name already exists.</p> <code>ValueError</code> <p>If the identifier is invalid, or no path is given to store metadata.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/glue.py</code> <pre><code>def create_table(\nself,\nidentifier: Union[str, Identifier],\nschema: Schema,\nlocation: Optional[str] = None,\npartition_spec: PartitionSpec = UNPARTITIONED_PARTITION_SPEC,\nsort_order: SortOrder = UNSORTED_SORT_ORDER,\nproperties: Properties = EMPTY_DICT,\n) -&gt; Table:\n\"\"\"\n    Create an Iceberg table.\n    Args:\n        identifier: Table identifier.\n        schema: Table's schema.\n        location: Location for the table. Optional Argument.\n        partition_spec: PartitionSpec for the table.\n        sort_order: SortOrder for the table.\n        properties: Table properties that can be a string based dictionary.\n    Returns:\n        Table: the created table instance.\n    Raises:\n        AlreadyExistsError: If a table with the name already exists.\n        ValueError: If the identifier is invalid, or no path is given to store metadata.\n    \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier)\nlocation = self._resolve_table_location(location, database_name, table_name)\nmetadata_location = self._get_metadata_location(location=location)\nmetadata = new_table_metadata(\nlocation=location, schema=schema, partition_spec=partition_spec, sort_order=sort_order, properties=properties\n)\nio = load_file_io(properties=self.properties, location=metadata_location)\nself._write_metadata(metadata, io, metadata_location)\ntable_input = _construct_create_table_input(table_name, metadata_location, properties)\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier)\nself._create_glue_table(database_name=database_name, table_name=table_name, table_input=table_input)\nreturn self.load_table(identifier=identifier)\n</code></pre>"},{"location":"reference/pyiceberg/catalog/glue/#pyiceberg.catalog.glue.GlueCatalog.drop_namespace","title":"<code>drop_namespace(namespace)</code>","text":"<p>Drop a namespace.</p> <p>A Glue namespace can only be dropped if it is empty.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>Union[str, Identifier]</code> <p>Namespace identifier.</p> required <p>Raises:</p> Type Description <code>NoSuchNamespaceError</code> <p>If a namespace with the given name does not exist, or the identifier is invalid.</p> <code>NamespaceNotEmptyError</code> <p>If the namespace is not empty.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/glue.py</code> <pre><code>def drop_namespace(self, namespace: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a namespace.\n    A Glue namespace can only be dropped if it is empty.\n    Args:\n        namespace: Namespace identifier.\n    Raises:\n        NoSuchNamespaceError: If a namespace with the given name does not exist, or the identifier is invalid.\n        NamespaceNotEmptyError: If the namespace is not empty.\n    \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\ntry:\ntable_list = self.list_tables(namespace=database_name)\nexcept NoSuchNamespaceError as e:\nraise NoSuchNamespaceError(f\"Database does not exist: {database_name}\") from e\nif len(table_list) &gt; 0:\nraise NamespaceNotEmptyError(f\"Database {database_name} is not empty\")\nself.glue.delete_database(Name=database_name)\n</code></pre>"},{"location":"reference/pyiceberg/catalog/glue/#pyiceberg.catalog.glue.GlueCatalog.drop_table","title":"<code>drop_table(identifier)</code>","text":"<p>Drop a table.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Union[str, Identifier]</code> <p>Table identifier.</p> required <p>Raises:</p> Type Description <code>NoSuchTableError</code> <p>If a table with the name does not exist, or the identifier is invalid.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/glue.py</code> <pre><code>def drop_table(self, identifier: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a table.\n    Args:\n        identifier: Table identifier.\n    Raises:\n        NoSuchTableError: If a table with the name does not exist, or the identifier is invalid.\n    \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier, NoSuchTableError)\ntry:\nself.glue.delete_table(DatabaseName=database_name, Name=table_name)\nexcept self.glue.exceptions.EntityNotFoundException as e:\nraise NoSuchTableError(f\"Table does not exist: {database_name}.{table_name}\") from e\n</code></pre>"},{"location":"reference/pyiceberg/catalog/glue/#pyiceberg.catalog.glue.GlueCatalog.list_namespaces","title":"<code>list_namespaces(namespace=())</code>","text":"<p>List namespaces from the given namespace. If not given, list top-level namespaces from the catalog.</p> <p>Returns:</p> Type Description <code>List[Identifier]</code> <p>List[Identifier]: a List of namespace identifiers.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/glue.py</code> <pre><code>def list_namespaces(self, namespace: Union[str, Identifier] = ()) -&gt; List[Identifier]:\n\"\"\"List namespaces from the given namespace. If not given, list top-level namespaces from the catalog.\n    Returns:\n        List[Identifier]: a List of namespace identifiers.\n    \"\"\"\n# Hierarchical namespace is not supported. Return an empty list\nif namespace:\nreturn []\ndatabase_list = []\ndatabases_response = self.glue.get_databases()\nnext_token = databases_response.get(PROP_GLUE_NEXT_TOKEN)\ndatabase_list += databases_response.get(PROP_GLUE_DATABASE_LIST, [])\nwhile next_token:\ndatabases_response = self.glue.get_databases(NextToken=next_token)\nnext_token = databases_response.get(PROP_GLUE_NEXT_TOKEN)\ndatabase_list += databases_response.get(PROP_GLUE_DATABASE_LIST, [])\nreturn [self.identifier_to_tuple(database.get(PROP_GLUE_DATABASE_NAME)) for database in database_list]\n</code></pre>"},{"location":"reference/pyiceberg/catalog/glue/#pyiceberg.catalog.glue.GlueCatalog.list_tables","title":"<code>list_tables(namespace)</code>","text":"<p>List tables under the given namespace in the catalog (including non-Iceberg tables).</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str | Identifier</code> <p>Namespace identifier to search.</p> required <p>Returns:</p> Type Description <code>List[Identifier]</code> <p>List[Identifier]: list of table identifiers.</p> <p>Raises:</p> Type Description <code>NoSuchNamespaceError</code> <p>If a namespace with the given name does not exist, or the identifier is invalid.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/glue.py</code> <pre><code>def list_tables(self, namespace: Union[str, Identifier]) -&gt; List[Identifier]:\n\"\"\"List tables under the given namespace in the catalog (including non-Iceberg tables).\n    Args:\n        namespace (str | Identifier): Namespace identifier to search.\n    Returns:\n        List[Identifier]: list of table identifiers.\n    Raises:\n        NoSuchNamespaceError: If a namespace with the given name does not exist, or the identifier is invalid.\n    \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\ntable_list = []\ntry:\ntable_list_response = self.glue.get_tables(DatabaseName=database_name)\nnext_token = table_list_response.get(PROP_GLUE_NEXT_TOKEN)\ntable_list += table_list_response.get(PROP_GLUE_TABLELIST, [])\nwhile next_token:\ntable_list_response = self.glue.get_tables(DatabaseName=database_name, NextToken=next_token)\nnext_token = table_list_response.get(PROP_GLUE_NEXT_TOKEN)\ntable_list += table_list_response.get(PROP_GLUE_TABLELIST, [])\nexcept self.glue.exceptions.EntityNotFoundException as e:\nraise NoSuchNamespaceError(f\"Database does not exist: {database_name}\") from e\nreturn [(database_name, table.get(PROP_GLUE_TABLE_NAME)) for table in table_list]\n</code></pre>"},{"location":"reference/pyiceberg/catalog/glue/#pyiceberg.catalog.glue.GlueCatalog.load_namespace_properties","title":"<code>load_namespace_properties(namespace)</code>","text":"<p>Get properties for a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>Union[str, Identifier]</code> <p>Namespace identifier.</p> required <p>Returns:</p> Name Type Description <code>Properties</code> <code>Properties</code> <p>Properties for the given namespace.</p> <p>Raises:</p> Type Description <code>NoSuchNamespaceError</code> <p>If a namespace with the given name does not exist, or identifier is invalid.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/glue.py</code> <pre><code>def load_namespace_properties(self, namespace: Union[str, Identifier]) -&gt; Properties:\n\"\"\"Get properties for a namespace.\n    Args:\n        namespace: Namespace identifier.\n    Returns:\n        Properties: Properties for the given namespace.\n    Raises:\n        NoSuchNamespaceError: If a namespace with the given name does not exist, or identifier is invalid.\n    \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\ntry:\ndatabase_response = self.glue.get_database(Name=database_name)\nexcept self.glue.exceptions.EntityNotFoundException as e:\nraise NoSuchNamespaceError(f\"Database does not exist: {database_name}\") from e\nexcept self.glue.exceptions.InvalidInputException as e:\nraise NoSuchNamespaceError(f\"Invalid input for namespace {database_name}\") from e\ndatabase = database_response[PROP_GLUE_DATABASE]\nif PROP_GLUE_DATABASE_PARAMETERS not in database:\nreturn {}\nproperties = dict(database[PROP_GLUE_DATABASE_PARAMETERS])\nif database_location := database.get(PROP_GLUE_DATABASE_LOCATION):\nproperties[LOCATION] = database_location\nif database_description := database.get(PROP_GLUE_DATABASE_DESCRIPTION):\nproperties[GLUE_DESCRIPTION_KEY] = database_description\nreturn properties\n</code></pre>"},{"location":"reference/pyiceberg/catalog/glue/#pyiceberg.catalog.glue.GlueCatalog.load_table","title":"<code>load_table(identifier)</code>","text":"<p>Loads the table's metadata and returns the table instance.</p> <p>You can also use this method to check for table existence using 'try catalog.table() except TableNotFoundError'. Note: This method doesn't scan data stored in the table.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Union[str, Identifier]</code> <p>Table identifier.</p> required <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>the table instance with its metadata.</p> <p>Raises:</p> Type Description <code>NoSuchTableError</code> <p>If a table with the name does not exist, or the identifier is invalid.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/glue.py</code> <pre><code>def load_table(self, identifier: Union[str, Identifier]) -&gt; Table:\n\"\"\"Loads the table's metadata and returns the table instance.\n    You can also use this method to check for table existence using 'try catalog.table() except TableNotFoundError'.\n    Note: This method doesn't scan data stored in the table.\n    Args:\n        identifier: Table identifier.\n    Returns:\n        Table: the table instance with its metadata.\n    Raises:\n        NoSuchTableError: If a table with the name does not exist, or the identifier is invalid.\n    \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier, NoSuchTableError)\ntry:\nload_table_response = self.glue.get_table(DatabaseName=database_name, Name=table_name)\nexcept self.glue.exceptions.EntityNotFoundException as e:\nraise NoSuchTableError(f\"Table does not exist: {database_name}.{table_name}\") from e\nreturn self._convert_glue_to_iceberg(load_table_response.get(PROP_GLUE_TABLE, {}))\n</code></pre>"},{"location":"reference/pyiceberg/catalog/glue/#pyiceberg.catalog.glue.GlueCatalog.rename_table","title":"<code>rename_table(from_identifier, to_identifier)</code>","text":"<p>Rename a fully classified table name.</p> <p>This method can only rename Iceberg tables in AWS Glue.</p> <p>Parameters:</p> Name Type Description Default <code>from_identifier</code> <code>Union[str, Identifier]</code> <p>Existing table identifier.</p> required <code>to_identifier</code> <code>Union[str, Identifier]</code> <p>New table identifier.</p> required <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>the updated table instance with its metadata.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When from table identifier is invalid.</p> <code>NoSuchTableError</code> <p>When a table with the name does not exist.</p> <code>NoSuchIcebergTableError</code> <p>When from table is not a valid iceberg table.</p> <code>NoSuchPropertyException</code> <p>When from table miss some required properties.</p> <code>NoSuchNamespaceError</code> <p>When the destination namespace doesn't exist.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/glue.py</code> <pre><code>def rename_table(self, from_identifier: Union[str, Identifier], to_identifier: Union[str, Identifier]) -&gt; Table:\n\"\"\"Rename a fully classified table name.\n    This method can only rename Iceberg tables in AWS Glue.\n    Args:\n        from_identifier: Existing table identifier.\n        to_identifier: New table identifier.\n    Returns:\n        Table: the updated table instance with its metadata.\n    Raises:\n        ValueError: When from table identifier is invalid.\n        NoSuchTableError: When a table with the name does not exist.\n        NoSuchIcebergTableError: When from table is not a valid iceberg table.\n        NoSuchPropertyException: When from table miss some required properties.\n        NoSuchNamespaceError: When the destination namespace doesn't exist.\n    \"\"\"\nfrom_database_name, from_table_name = self.identifier_to_database_and_table(from_identifier, NoSuchTableError)\nto_database_name, to_table_name = self.identifier_to_database_and_table(to_identifier)\ntry:\nget_table_response = self.glue.get_table(DatabaseName=from_database_name, Name=from_table_name)\nexcept self.glue.exceptions.EntityNotFoundException as e:\nraise NoSuchTableError(f\"Table does not exist: {from_database_name}.{from_table_name}\") from e\nglue_table = get_table_response[PROP_GLUE_TABLE]\ntry:\n# verify that from_identifier is a valid iceberg table\nself._convert_glue_to_iceberg(glue_table=glue_table)\nexcept NoSuchPropertyException as e:\nraise NoSuchPropertyException(\nf\"Failed to rename table {from_database_name}.{from_table_name} since it is missing required properties\"\n) from e\nexcept NoSuchIcebergTableError as e:\nraise NoSuchIcebergTableError(\nf\"Failed to rename table {from_database_name}.{from_table_name} since it is not a valid iceberg table\"\n) from e\nrename_table_input = _construct_rename_table_input(to_table_name=to_table_name, glue_table=glue_table)\nself._create_glue_table(database_name=to_database_name, table_name=to_table_name, table_input=rename_table_input)\ntry:\nself.drop_table(from_identifier)\nexcept Exception as e:\nlog_message = f\"Failed to drop old table {from_database_name}.{from_table_name}. \"\ntry:\nself.drop_table(to_identifier)\nlog_message += f\"Rolled back table creation for {to_database_name}.{to_table_name}.\"\nexcept NoSuchTableError:\nlog_message += (\nf\"Failed to roll back table creation for {to_database_name}.{to_table_name}. \" f\"Please clean up manually\"\n)\nraise ValueError(log_message) from e\nreturn self.load_table(to_identifier)\n</code></pre>"},{"location":"reference/pyiceberg/catalog/glue/#pyiceberg.catalog.glue.GlueCatalog.update_namespace_properties","title":"<code>update_namespace_properties(namespace, removals=None, updates=EMPTY_DICT)</code>","text":"<p>Removes provided property keys and updates properties for a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>Union[str, Identifier]</code> <p>Namespace identifier.</p> required <code>removals</code> <code>Optional[Set[str]]</code> <p>Set of property keys that need to be removed. Optional Argument.</p> <code>None</code> <code>updates</code> <code>Properties</code> <p>Properties to be updated for the given namespace.</p> <code>EMPTY_DICT</code> <p>Raises:</p> Type Description <code>NoSuchNamespaceError</code> <p>If a namespace with the given name does not exist\uff0c or identifier is invalid.</p> <code>ValueError</code> <p>If removals and updates have overlapping keys.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/glue.py</code> <pre><code>def update_namespace_properties(\nself, namespace: Union[str, Identifier], removals: Optional[Set[str]] = None, updates: Properties = EMPTY_DICT\n) -&gt; PropertiesUpdateSummary:\n\"\"\"Removes provided property keys and updates properties for a namespace.\n    Args:\n        namespace: Namespace identifier.\n        removals: Set of property keys that need to be removed. Optional Argument.\n        updates: Properties to be updated for the given namespace.\n    Raises:\n        NoSuchNamespaceError: If a namespace with the given name does not exist\uff0c or identifier is invalid.\n        ValueError: If removals and updates have overlapping keys.\n    \"\"\"\ncurrent_properties = self.load_namespace_properties(namespace=namespace)\nproperties_update_summary, updated_properties = self._get_updated_props_and_update_summary(\ncurrent_properties=current_properties, removals=removals, updates=updates\n)\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\nself.glue.update_database(Name=database_name, DatabaseInput=_construct_database_input(database_name, updated_properties))\nreturn properties_update_summary\n</code></pre>"},{"location":"reference/pyiceberg/catalog/hive/","title":"hive","text":""},{"location":"reference/pyiceberg/catalog/hive/#pyiceberg.catalog.hive.HiveCatalog","title":"<code>HiveCatalog</code>","text":"<p>         Bases: <code>Catalog</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/hive.py</code> <pre><code>class HiveCatalog(Catalog):\n_client: _HiveClient\ndef __init__(self, name: str, **properties: str):\nsuper().__init__(name, **properties)\nself._client = _HiveClient(properties[\"uri\"])\ndef _convert_hive_into_iceberg(self, table: HiveTable, io: FileIO) -&gt; Table:\nproperties: Dict[str, str] = table.parameters\nif TABLE_TYPE not in properties:\nraise NoSuchTableError(f\"Property table_type missing, could not determine type: {table.dbName}.{table.tableName}\")\ntable_type = properties[TABLE_TYPE]\nif table_type.lower() != ICEBERG:\nraise NoSuchIcebergTableError(\nf\"Property table_type is {table_type}, expected {ICEBERG}: {table.dbName}.{table.tableName}\"\n)\nif prop_metadata_location := properties.get(METADATA_LOCATION):\nmetadata_location = prop_metadata_location\nelse:\nraise NoSuchTableError(f\"Table property {METADATA_LOCATION} is missing\")\nfile = io.new_input(metadata_location)\nmetadata = FromInputFile.table_metadata(file)\nreturn Table(\nidentifier=(table.dbName, table.tableName),\nmetadata=metadata,\nmetadata_location=metadata_location,\nio=self._load_file_io(metadata.properties, metadata_location),\ncatalog=self,\n)\ndef create_table(\nself,\nidentifier: Union[str, Identifier],\nschema: Schema,\nlocation: Optional[str] = None,\npartition_spec: PartitionSpec = UNPARTITIONED_PARTITION_SPEC,\nsort_order: SortOrder = UNSORTED_SORT_ORDER,\nproperties: Properties = EMPTY_DICT,\n) -&gt; Table:\n\"\"\"Create a table.\n        Args:\n            identifier: Table identifier.\n            schema: Table's schema.\n            location: Location for the table. Optional Argument.\n            partition_spec: PartitionSpec for the table.\n            sort_order: SortOrder for the table.\n            properties: Table properties that can be a string based dictionary.\n        Returns:\n            Table: the created table instance.\n        Raises:\n            AlreadyExistsError: If a table with the name already exists.\n            ValueError: If the identifier is invalid.\n        \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier)\ncurrent_time_millis = int(time.time() * 1000)\nlocation = self._resolve_table_location(location, database_name, table_name)\nmetadata_location = self._get_metadata_location(location=location)\nmetadata = new_table_metadata(\nlocation=location, schema=schema, partition_spec=partition_spec, sort_order=sort_order, properties=properties\n)\nio = load_file_io({**self.properties, **properties}, location=location)\nself._write_metadata(metadata, io, metadata_location)\ntbl = HiveTable(\ndbName=database_name,\ntableName=table_name,\nowner=properties[OWNER] if properties and OWNER in properties else getpass.getuser(),\ncreateTime=current_time_millis // 1000,\nlastAccessTime=current_time_millis // 1000,\nsd=_construct_hive_storage_descriptor(schema, location),\ntableType=EXTERNAL_TABLE,\nparameters=_construct_parameters(metadata_location),\n)\ntry:\nwith self._client as open_client:\nopen_client.create_table(tbl)\nhive_table = open_client.get_table(dbname=database_name, tbl_name=table_name)\nexcept AlreadyExistsException as e:\nraise TableAlreadyExistsError(f\"Table {database_name}.{table_name} already exists\") from e\nreturn self._convert_hive_into_iceberg(hive_table, io)\ndef _commit_table(self, table_request: CommitTableRequest) -&gt; CommitTableResponse:\n\"\"\"Updates the table.\n        Args:\n            table_request (CommitTableRequest): The table requests to be carried out.\n        Returns:\n            CommitTableResponse: The updated metadata.\n        Raises:\n            NoSuchTableError: If a table with the given identifier does not exist.\n        \"\"\"\nraise NotImplementedError\ndef load_table(self, identifier: Union[str, Identifier]) -&gt; Table:\n\"\"\"Loads the table's metadata and returns the table instance.\n        You can also use this method to check for table existence using 'try catalog.table() except TableNotFoundError'.\n        Note: This method doesn't scan data stored in the table.\n        Args:\n            identifier: Table identifier.\n        Returns:\n            Table: the table instance with its metadata.\n        Raises:\n            NoSuchTableError: If a table with the name does not exist, or the identifier is invalid.\n        \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier, NoSuchTableError)\ntry:\nwith self._client as open_client:\nhive_table = open_client.get_table(dbname=database_name, tbl_name=table_name)\nexcept NoSuchObjectException as e:\nraise NoSuchTableError(f\"Table does not exists: {table_name}\") from e\nio = load_file_io({**self.properties, **hive_table.parameters}, hive_table.sd.location)\nreturn self._convert_hive_into_iceberg(hive_table, io)\ndef drop_table(self, identifier: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a table.\n        Args:\n            identifier: Table identifier.\n        Raises:\n            NoSuchTableError: If a table with the name does not exist, or the identifier is invalid.\n        \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier, NoSuchTableError)\ntry:\nwith self._client as open_client:\nopen_client.drop_table(dbname=database_name, name=table_name, deleteData=False)\nexcept NoSuchObjectException as e:\n# When the namespace doesn't exist, it throws the same error\nraise NoSuchTableError(f\"Table does not exists: {table_name}\") from e\ndef purge_table(self, identifier: Union[str, Identifier]) -&gt; None:\n# This requires to traverse the reachability set, and drop all the data files.\nraise NotImplementedError(\"Not yet implemented\")\ndef rename_table(self, from_identifier: Union[str, Identifier], to_identifier: Union[str, Identifier]) -&gt; Table:\n\"\"\"Rename a fully classified table name.\n        Args:\n            from_identifier: Existing table identifier.\n            to_identifier: New table identifier.\n        Returns:\n            Table: the updated table instance with its metadata.\n        Raises:\n            ValueError: When from table identifier is invalid.\n            NoSuchTableError: When a table with the name does not exist.\n            NoSuchNamespaceError: When the destination namespace doesn't exist.\n        \"\"\"\nfrom_database_name, from_table_name = self.identifier_to_database_and_table(from_identifier, NoSuchTableError)\nto_database_name, to_table_name = self.identifier_to_database_and_table(to_identifier)\ntry:\nwith self._client as open_client:\ntbl = open_client.get_table(dbname=from_database_name, tbl_name=from_table_name)\ntbl.dbName = to_database_name\ntbl.tableName = to_table_name\nopen_client.alter_table(dbname=from_database_name, tbl_name=from_table_name, new_tbl=tbl)\nexcept NoSuchObjectException as e:\nraise NoSuchTableError(f\"Table does not exist: {from_table_name}\") from e\nexcept InvalidOperationException as e:\nraise NoSuchNamespaceError(f\"Database does not exists: {to_database_name}\") from e\nreturn self.load_table(to_identifier)\ndef create_namespace(self, namespace: Union[str, Identifier], properties: Properties = EMPTY_DICT) -&gt; None:\n\"\"\"Create a namespace in the catalog.\n        Args:\n            namespace: Namespace identifier.\n            properties: A string dictionary of properties for the given namespace.\n        Raises:\n            ValueError: If the identifier is invalid.\n            AlreadyExistsError: If a namespace with the given name already exists.\n        \"\"\"\ndatabase_name = self.identifier_to_database(namespace)\nhive_database = HiveDatabase(name=database_name, parameters=properties)\ntry:\nwith self._client as open_client:\nopen_client.create_database(_annotate_namespace(hive_database, properties))\nexcept AlreadyExistsException as e:\nraise NamespaceAlreadyExistsError(f\"Database {database_name} already exists\") from e\ndef drop_namespace(self, namespace: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a namespace.\n        Args:\n            namespace: Namespace identifier.\n        Raises:\n            NoSuchNamespaceError: If a namespace with the given name does not exist, or the identifier is invalid.\n            NamespaceNotEmptyError: If the namespace is not empty.\n        \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\ntry:\nwith self._client as open_client:\nopen_client.drop_database(database_name, deleteData=False, cascade=False)\nexcept InvalidOperationException as e:\nraise NamespaceNotEmptyError(f\"Database {database_name} is not empty\") from e\nexcept MetaException as e:\nraise NoSuchNamespaceError(f\"Database does not exists: {database_name}\") from e\ndef list_tables(self, namespace: Union[str, Identifier]) -&gt; List[Identifier]:\n\"\"\"List tables under the given namespace in the catalog (including non-Iceberg tables).\n        When the database doesn't exist, it will just return an empty list.\n        Args:\n            namespace: Database to list.\n        Returns:\n            List[Identifier]: list of table identifiers.\n        Raises:\n            NoSuchNamespaceError: If a namespace with the given name does not exist, or the identifier is invalid.\n        \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\nwith self._client as open_client:\nreturn [(database_name, table_name) for table_name in open_client.get_all_tables(db_name=database_name)]\ndef list_namespaces(self, namespace: Union[str, Identifier] = ()) -&gt; List[Identifier]:\n\"\"\"List namespaces from the given namespace. If not given, list top-level namespaces from the catalog.\n        Returns:\n            List[Identifier]: a List of namespace identifiers.\n        \"\"\"\n# Hierarchical namespace is not supported. Return an empty list\nif namespace:\nreturn []\nwith self._client as open_client:\nreturn list(map(self.identifier_to_tuple, open_client.get_all_databases()))\ndef load_namespace_properties(self, namespace: Union[str, Identifier]) -&gt; Properties:\n\"\"\"Get properties for a namespace.\n        Args:\n            namespace: Namespace identifier.\n        Returns:\n            Properties: Properties for the given namespace.\n        Raises:\n            NoSuchNamespaceError: If a namespace with the given name does not exist, or identifier is invalid.\n        \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\ntry:\nwith self._client as open_client:\ndatabase = open_client.get_database(name=database_name)\nproperties = database.parameters\nproperties[LOCATION] = database.locationUri\nif comment := database.description:\nproperties[COMMENT] = comment\nreturn properties\nexcept NoSuchObjectException as e:\nraise NoSuchNamespaceError(f\"Database does not exists: {database_name}\") from e\ndef update_namespace_properties(\nself, namespace: Union[str, Identifier], removals: Optional[Set[str]] = None, updates: Properties = EMPTY_DICT\n) -&gt; PropertiesUpdateSummary:\n\"\"\"Removes provided property keys and updates properties for a namespace.\n        Args:\n            namespace: Namespace identifier.\n            removals: Set of property keys that need to be removed. Optional Argument.\n            updates: Properties to be updated for the given namespace.\n        Raises:\n            NoSuchNamespaceError: If a namespace with the given name does not exist\n            ValueError: If removals and updates have overlapping keys.\n        \"\"\"\nself._check_for_overlap(updates=updates, removals=removals)\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\nwith self._client as open_client:\ntry:\ndatabase = open_client.get_database(database_name)\nparameters = database.parameters\nexcept NoSuchObjectException as e:\nraise NoSuchNamespaceError(f\"Database does not exists: {database_name}\") from e\nremoved: Set[str] = set()\nupdated: Set[str] = set()\nif removals:\nfor key in removals:\nif key in parameters:\nparameters[key] = None\nremoved.add(key)\nif updates:\nfor key, value in updates.items():\nparameters[key] = value\nupdated.add(key)\nopen_client.alter_database(database_name, _annotate_namespace(database, parameters))\nexpected_to_change = (removals or set()).difference(removed)\nreturn PropertiesUpdateSummary(removed=list(removed or []), updated=list(updated or []), missing=list(expected_to_change))\n</code></pre>"},{"location":"reference/pyiceberg/catalog/hive/#pyiceberg.catalog.hive.HiveCatalog.create_namespace","title":"<code>create_namespace(namespace, properties=EMPTY_DICT)</code>","text":"<p>Create a namespace in the catalog.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>Union[str, Identifier]</code> <p>Namespace identifier.</p> required <code>properties</code> <code>Properties</code> <p>A string dictionary of properties for the given namespace.</p> <code>EMPTY_DICT</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the identifier is invalid.</p> <code>AlreadyExistsError</code> <p>If a namespace with the given name already exists.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/hive.py</code> <pre><code>def create_namespace(self, namespace: Union[str, Identifier], properties: Properties = EMPTY_DICT) -&gt; None:\n\"\"\"Create a namespace in the catalog.\n    Args:\n        namespace: Namespace identifier.\n        properties: A string dictionary of properties for the given namespace.\n    Raises:\n        ValueError: If the identifier is invalid.\n        AlreadyExistsError: If a namespace with the given name already exists.\n    \"\"\"\ndatabase_name = self.identifier_to_database(namespace)\nhive_database = HiveDatabase(name=database_name, parameters=properties)\ntry:\nwith self._client as open_client:\nopen_client.create_database(_annotate_namespace(hive_database, properties))\nexcept AlreadyExistsException as e:\nraise NamespaceAlreadyExistsError(f\"Database {database_name} already exists\") from e\n</code></pre>"},{"location":"reference/pyiceberg/catalog/hive/#pyiceberg.catalog.hive.HiveCatalog.create_table","title":"<code>create_table(identifier, schema, location=None, partition_spec=UNPARTITIONED_PARTITION_SPEC, sort_order=UNSORTED_SORT_ORDER, properties=EMPTY_DICT)</code>","text":"<p>Create a table.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Union[str, Identifier]</code> <p>Table identifier.</p> required <code>schema</code> <code>Schema</code> <p>Table's schema.</p> required <code>location</code> <code>Optional[str]</code> <p>Location for the table. Optional Argument.</p> <code>None</code> <code>partition_spec</code> <code>PartitionSpec</code> <p>PartitionSpec for the table.</p> <code>UNPARTITIONED_PARTITION_SPEC</code> <code>sort_order</code> <code>SortOrder</code> <p>SortOrder for the table.</p> <code>UNSORTED_SORT_ORDER</code> <code>properties</code> <code>Properties</code> <p>Table properties that can be a string based dictionary.</p> <code>EMPTY_DICT</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>the created table instance.</p> <p>Raises:</p> Type Description <code>AlreadyExistsError</code> <p>If a table with the name already exists.</p> <code>ValueError</code> <p>If the identifier is invalid.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/hive.py</code> <pre><code>def create_table(\nself,\nidentifier: Union[str, Identifier],\nschema: Schema,\nlocation: Optional[str] = None,\npartition_spec: PartitionSpec = UNPARTITIONED_PARTITION_SPEC,\nsort_order: SortOrder = UNSORTED_SORT_ORDER,\nproperties: Properties = EMPTY_DICT,\n) -&gt; Table:\n\"\"\"Create a table.\n    Args:\n        identifier: Table identifier.\n        schema: Table's schema.\n        location: Location for the table. Optional Argument.\n        partition_spec: PartitionSpec for the table.\n        sort_order: SortOrder for the table.\n        properties: Table properties that can be a string based dictionary.\n    Returns:\n        Table: the created table instance.\n    Raises:\n        AlreadyExistsError: If a table with the name already exists.\n        ValueError: If the identifier is invalid.\n    \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier)\ncurrent_time_millis = int(time.time() * 1000)\nlocation = self._resolve_table_location(location, database_name, table_name)\nmetadata_location = self._get_metadata_location(location=location)\nmetadata = new_table_metadata(\nlocation=location, schema=schema, partition_spec=partition_spec, sort_order=sort_order, properties=properties\n)\nio = load_file_io({**self.properties, **properties}, location=location)\nself._write_metadata(metadata, io, metadata_location)\ntbl = HiveTable(\ndbName=database_name,\ntableName=table_name,\nowner=properties[OWNER] if properties and OWNER in properties else getpass.getuser(),\ncreateTime=current_time_millis // 1000,\nlastAccessTime=current_time_millis // 1000,\nsd=_construct_hive_storage_descriptor(schema, location),\ntableType=EXTERNAL_TABLE,\nparameters=_construct_parameters(metadata_location),\n)\ntry:\nwith self._client as open_client:\nopen_client.create_table(tbl)\nhive_table = open_client.get_table(dbname=database_name, tbl_name=table_name)\nexcept AlreadyExistsException as e:\nraise TableAlreadyExistsError(f\"Table {database_name}.{table_name} already exists\") from e\nreturn self._convert_hive_into_iceberg(hive_table, io)\n</code></pre>"},{"location":"reference/pyiceberg/catalog/hive/#pyiceberg.catalog.hive.HiveCatalog.drop_namespace","title":"<code>drop_namespace(namespace)</code>","text":"<p>Drop a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>Union[str, Identifier]</code> <p>Namespace identifier.</p> required <p>Raises:</p> Type Description <code>NoSuchNamespaceError</code> <p>If a namespace with the given name does not exist, or the identifier is invalid.</p> <code>NamespaceNotEmptyError</code> <p>If the namespace is not empty.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/hive.py</code> <pre><code>def drop_namespace(self, namespace: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a namespace.\n    Args:\n        namespace: Namespace identifier.\n    Raises:\n        NoSuchNamespaceError: If a namespace with the given name does not exist, or the identifier is invalid.\n        NamespaceNotEmptyError: If the namespace is not empty.\n    \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\ntry:\nwith self._client as open_client:\nopen_client.drop_database(database_name, deleteData=False, cascade=False)\nexcept InvalidOperationException as e:\nraise NamespaceNotEmptyError(f\"Database {database_name} is not empty\") from e\nexcept MetaException as e:\nraise NoSuchNamespaceError(f\"Database does not exists: {database_name}\") from e\n</code></pre>"},{"location":"reference/pyiceberg/catalog/hive/#pyiceberg.catalog.hive.HiveCatalog.drop_table","title":"<code>drop_table(identifier)</code>","text":"<p>Drop a table.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Union[str, Identifier]</code> <p>Table identifier.</p> required <p>Raises:</p> Type Description <code>NoSuchTableError</code> <p>If a table with the name does not exist, or the identifier is invalid.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/hive.py</code> <pre><code>def drop_table(self, identifier: Union[str, Identifier]) -&gt; None:\n\"\"\"Drop a table.\n    Args:\n        identifier: Table identifier.\n    Raises:\n        NoSuchTableError: If a table with the name does not exist, or the identifier is invalid.\n    \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier, NoSuchTableError)\ntry:\nwith self._client as open_client:\nopen_client.drop_table(dbname=database_name, name=table_name, deleteData=False)\nexcept NoSuchObjectException as e:\n# When the namespace doesn't exist, it throws the same error\nraise NoSuchTableError(f\"Table does not exists: {table_name}\") from e\n</code></pre>"},{"location":"reference/pyiceberg/catalog/hive/#pyiceberg.catalog.hive.HiveCatalog.list_namespaces","title":"<code>list_namespaces(namespace=())</code>","text":"<p>List namespaces from the given namespace. If not given, list top-level namespaces from the catalog.</p> <p>Returns:</p> Type Description <code>List[Identifier]</code> <p>List[Identifier]: a List of namespace identifiers.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/hive.py</code> <pre><code>def list_namespaces(self, namespace: Union[str, Identifier] = ()) -&gt; List[Identifier]:\n\"\"\"List namespaces from the given namespace. If not given, list top-level namespaces from the catalog.\n    Returns:\n        List[Identifier]: a List of namespace identifiers.\n    \"\"\"\n# Hierarchical namespace is not supported. Return an empty list\nif namespace:\nreturn []\nwith self._client as open_client:\nreturn list(map(self.identifier_to_tuple, open_client.get_all_databases()))\n</code></pre>"},{"location":"reference/pyiceberg/catalog/hive/#pyiceberg.catalog.hive.HiveCatalog.list_tables","title":"<code>list_tables(namespace)</code>","text":"<p>List tables under the given namespace in the catalog (including non-Iceberg tables).</p> <p>When the database doesn't exist, it will just return an empty list.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>Union[str, Identifier]</code> <p>Database to list.</p> required <p>Returns:</p> Type Description <code>List[Identifier]</code> <p>List[Identifier]: list of table identifiers.</p> <p>Raises:</p> Type Description <code>NoSuchNamespaceError</code> <p>If a namespace with the given name does not exist, or the identifier is invalid.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/hive.py</code> <pre><code>def list_tables(self, namespace: Union[str, Identifier]) -&gt; List[Identifier]:\n\"\"\"List tables under the given namespace in the catalog (including non-Iceberg tables).\n    When the database doesn't exist, it will just return an empty list.\n    Args:\n        namespace: Database to list.\n    Returns:\n        List[Identifier]: list of table identifiers.\n    Raises:\n        NoSuchNamespaceError: If a namespace with the given name does not exist, or the identifier is invalid.\n    \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\nwith self._client as open_client:\nreturn [(database_name, table_name) for table_name in open_client.get_all_tables(db_name=database_name)]\n</code></pre>"},{"location":"reference/pyiceberg/catalog/hive/#pyiceberg.catalog.hive.HiveCatalog.load_namespace_properties","title":"<code>load_namespace_properties(namespace)</code>","text":"<p>Get properties for a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>Union[str, Identifier]</code> <p>Namespace identifier.</p> required <p>Returns:</p> Name Type Description <code>Properties</code> <code>Properties</code> <p>Properties for the given namespace.</p> <p>Raises:</p> Type Description <code>NoSuchNamespaceError</code> <p>If a namespace with the given name does not exist, or identifier is invalid.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/hive.py</code> <pre><code>def load_namespace_properties(self, namespace: Union[str, Identifier]) -&gt; Properties:\n\"\"\"Get properties for a namespace.\n    Args:\n        namespace: Namespace identifier.\n    Returns:\n        Properties: Properties for the given namespace.\n    Raises:\n        NoSuchNamespaceError: If a namespace with the given name does not exist, or identifier is invalid.\n    \"\"\"\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\ntry:\nwith self._client as open_client:\ndatabase = open_client.get_database(name=database_name)\nproperties = database.parameters\nproperties[LOCATION] = database.locationUri\nif comment := database.description:\nproperties[COMMENT] = comment\nreturn properties\nexcept NoSuchObjectException as e:\nraise NoSuchNamespaceError(f\"Database does not exists: {database_name}\") from e\n</code></pre>"},{"location":"reference/pyiceberg/catalog/hive/#pyiceberg.catalog.hive.HiveCatalog.load_table","title":"<code>load_table(identifier)</code>","text":"<p>Loads the table's metadata and returns the table instance.</p> <p>You can also use this method to check for table existence using 'try catalog.table() except TableNotFoundError'. Note: This method doesn't scan data stored in the table.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>Union[str, Identifier]</code> <p>Table identifier.</p> required <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>the table instance with its metadata.</p> <p>Raises:</p> Type Description <code>NoSuchTableError</code> <p>If a table with the name does not exist, or the identifier is invalid.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/hive.py</code> <pre><code>def load_table(self, identifier: Union[str, Identifier]) -&gt; Table:\n\"\"\"Loads the table's metadata and returns the table instance.\n    You can also use this method to check for table existence using 'try catalog.table() except TableNotFoundError'.\n    Note: This method doesn't scan data stored in the table.\n    Args:\n        identifier: Table identifier.\n    Returns:\n        Table: the table instance with its metadata.\n    Raises:\n        NoSuchTableError: If a table with the name does not exist, or the identifier is invalid.\n    \"\"\"\ndatabase_name, table_name = self.identifier_to_database_and_table(identifier, NoSuchTableError)\ntry:\nwith self._client as open_client:\nhive_table = open_client.get_table(dbname=database_name, tbl_name=table_name)\nexcept NoSuchObjectException as e:\nraise NoSuchTableError(f\"Table does not exists: {table_name}\") from e\nio = load_file_io({**self.properties, **hive_table.parameters}, hive_table.sd.location)\nreturn self._convert_hive_into_iceberg(hive_table, io)\n</code></pre>"},{"location":"reference/pyiceberg/catalog/hive/#pyiceberg.catalog.hive.HiveCatalog.rename_table","title":"<code>rename_table(from_identifier, to_identifier)</code>","text":"<p>Rename a fully classified table name.</p> <p>Parameters:</p> Name Type Description Default <code>from_identifier</code> <code>Union[str, Identifier]</code> <p>Existing table identifier.</p> required <code>to_identifier</code> <code>Union[str, Identifier]</code> <p>New table identifier.</p> required <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>the updated table instance with its metadata.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When from table identifier is invalid.</p> <code>NoSuchTableError</code> <p>When a table with the name does not exist.</p> <code>NoSuchNamespaceError</code> <p>When the destination namespace doesn't exist.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/hive.py</code> <pre><code>def rename_table(self, from_identifier: Union[str, Identifier], to_identifier: Union[str, Identifier]) -&gt; Table:\n\"\"\"Rename a fully classified table name.\n    Args:\n        from_identifier: Existing table identifier.\n        to_identifier: New table identifier.\n    Returns:\n        Table: the updated table instance with its metadata.\n    Raises:\n        ValueError: When from table identifier is invalid.\n        NoSuchTableError: When a table with the name does not exist.\n        NoSuchNamespaceError: When the destination namespace doesn't exist.\n    \"\"\"\nfrom_database_name, from_table_name = self.identifier_to_database_and_table(from_identifier, NoSuchTableError)\nto_database_name, to_table_name = self.identifier_to_database_and_table(to_identifier)\ntry:\nwith self._client as open_client:\ntbl = open_client.get_table(dbname=from_database_name, tbl_name=from_table_name)\ntbl.dbName = to_database_name\ntbl.tableName = to_table_name\nopen_client.alter_table(dbname=from_database_name, tbl_name=from_table_name, new_tbl=tbl)\nexcept NoSuchObjectException as e:\nraise NoSuchTableError(f\"Table does not exist: {from_table_name}\") from e\nexcept InvalidOperationException as e:\nraise NoSuchNamespaceError(f\"Database does not exists: {to_database_name}\") from e\nreturn self.load_table(to_identifier)\n</code></pre>"},{"location":"reference/pyiceberg/catalog/hive/#pyiceberg.catalog.hive.HiveCatalog.update_namespace_properties","title":"<code>update_namespace_properties(namespace, removals=None, updates=EMPTY_DICT)</code>","text":"<p>Removes provided property keys and updates properties for a namespace.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>Union[str, Identifier]</code> <p>Namespace identifier.</p> required <code>removals</code> <code>Optional[Set[str]]</code> <p>Set of property keys that need to be removed. Optional Argument.</p> <code>None</code> <code>updates</code> <code>Properties</code> <p>Properties to be updated for the given namespace.</p> <code>EMPTY_DICT</code> <p>Raises:</p> Type Description <code>NoSuchNamespaceError</code> <p>If a namespace with the given name does not exist</p> <code>ValueError</code> <p>If removals and updates have overlapping keys.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/hive.py</code> <pre><code>def update_namespace_properties(\nself, namespace: Union[str, Identifier], removals: Optional[Set[str]] = None, updates: Properties = EMPTY_DICT\n) -&gt; PropertiesUpdateSummary:\n\"\"\"Removes provided property keys and updates properties for a namespace.\n    Args:\n        namespace: Namespace identifier.\n        removals: Set of property keys that need to be removed. Optional Argument.\n        updates: Properties to be updated for the given namespace.\n    Raises:\n        NoSuchNamespaceError: If a namespace with the given name does not exist\n        ValueError: If removals and updates have overlapping keys.\n    \"\"\"\nself._check_for_overlap(updates=updates, removals=removals)\ndatabase_name = self.identifier_to_database(namespace, NoSuchNamespaceError)\nwith self._client as open_client:\ntry:\ndatabase = open_client.get_database(database_name)\nparameters = database.parameters\nexcept NoSuchObjectException as e:\nraise NoSuchNamespaceError(f\"Database does not exists: {database_name}\") from e\nremoved: Set[str] = set()\nupdated: Set[str] = set()\nif removals:\nfor key in removals:\nif key in parameters:\nparameters[key] = None\nremoved.add(key)\nif updates:\nfor key, value in updates.items():\nparameters[key] = value\nupdated.add(key)\nopen_client.alter_database(database_name, _annotate_namespace(database, parameters))\nexpected_to_change = (removals or set()).difference(removed)\nreturn PropertiesUpdateSummary(removed=list(removed or []), updated=list(updated or []), missing=list(expected_to_change))\n</code></pre>"},{"location":"reference/pyiceberg/catalog/noop/","title":"noop","text":""},{"location":"reference/pyiceberg/catalog/rest/","title":"rest","text":""},{"location":"reference/pyiceberg/catalog/rest/#pyiceberg.catalog.rest.RestCatalog","title":"<code>RestCatalog</code>","text":"<p>         Bases: <code>Catalog</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/rest.py</code> <pre><code>class RestCatalog(Catalog):\nuri: str\n_session: Session\ndef __init__(self, name: str, **properties: str):\n\"\"\"Rest Catalog.\n        You either need to provide a client_id and client_secret, or an already valid token.\n        Args:\n            name: Name to identify the catalog.\n            properties: Properties that are passed along to the configuration.\n        \"\"\"\nsuper().__init__(name, **properties)\nself.uri = properties[URI]\nself._fetch_config()\nself._session = self._create_session()\ndef _create_session(self) -&gt; Session:\n\"\"\"Creates a request session with provided catalog configuration.\"\"\"\nsession = Session()\n# Sets the client side and server side SSL cert verification, if provided as properties.\nif ssl_config := self.properties.get(SSL):\nif ssl_ca_bundle := ssl_config.get(CA_BUNDLE):  # type: ignore\nsession.verify = ssl_ca_bundle\nif ssl_client := ssl_config.get(CLIENT):  # type: ignore\nif all(k in ssl_client for k in (CERT, KEY)):\nsession.cert = (ssl_client[CERT], ssl_client[KEY])\nelif ssl_client_cert := ssl_client.get(CERT):\nsession.cert = ssl_client_cert\n# If we have credentials, but not a token, we want to fetch a token\nif TOKEN not in self.properties and CREDENTIAL in self.properties:\nself.properties[TOKEN] = self._fetch_access_token(session, self.properties[CREDENTIAL])\n# Set Auth token for subsequent calls in the session\nif token := self.properties.get(TOKEN):\nsession.headers[AUTHORIZATION_HEADER] = f\"{BEARER_PREFIX} {token}\"\n# Set HTTP headers\nsession.headers[\"Content-type\"] = \"application/json\"\nsession.headers[\"X-Client-Version\"] = ICEBERG_REST_SPEC_VERSION\nsession.headers[\"User-Agent\"] = f\"PyIceberg/{__version__}\"\n# Configure SigV4 Request Signing\nif str(self.properties.get(SIGV4, False)).lower() == \"true\":\nself._init_sigv4(session)\nreturn session\ndef _check_valid_namespace_identifier(self, identifier: Union[str, Identifier]) -&gt; Identifier:\n\"\"\"The identifier should have at least one element.\"\"\"\nidentifier_tuple = Catalog.identifier_to_tuple(identifier)\nif len(identifier_tuple) &lt; 1:\nraise NoSuchNamespaceError(f\"Empty namespace identifier: {identifier}\")\nreturn identifier_tuple\ndef url(self, endpoint: str, prefixed: bool = True, **kwargs: Any) -&gt; str:\n\"\"\"Constructs the endpoint.\n        Args:\n            endpoint: Resource identifier that points to the REST catalog.\n            prefixed: If the prefix return by the config needs to be appended.\n        Returns:\n            The base url of the rest catalog.\n        \"\"\"\nurl = self.uri\nurl = url + \"v1/\" if url.endswith(\"/\") else url + \"/v1/\"\nif prefixed:\nurl += self.properties.get(PREFIX, \"\")\nurl = url if url.endswith(\"/\") else url + \"/\"\nreturn url + endpoint.format(**kwargs)\ndef _fetch_access_token(self, session: Session, credential: str) -&gt; str:\nif SEMICOLON in credential:\nclient_id, client_secret = credential.split(SEMICOLON)\nelse:\nclient_id, client_secret = None, credential\ndata = {GRANT_TYPE: CLIENT_CREDENTIALS, CLIENT_ID: client_id, CLIENT_SECRET: client_secret, SCOPE: CATALOG_SCOPE}\nurl = self.url(Endpoints.get_token, prefixed=False)\n# Uses application/x-www-form-urlencoded by default\nresponse = session.post(url=url, data=data)\ntry:\nresponse.raise_for_status()\nexcept HTTPError as exc:\nself._handle_non_200_response(exc, {400: OAuthError, 401: OAuthError})\nreturn TokenResponse(**response.json()).access_token\ndef _fetch_config(self) -&gt; None:\nparams = {}\nif warehouse_location := self.properties.get(WAREHOUSE_LOCATION):\nparams[WAREHOUSE_LOCATION] = warehouse_location\nwith self._create_session() as session:\nresponse = session.get(self.url(Endpoints.get_config, prefixed=False), params=params)\ntry:\nresponse.raise_for_status()\nexcept HTTPError as exc:\nself._handle_non_200_response(exc, {})\nconfig_response = ConfigResponse(**response.json())\nconfig = config_response.defaults\nconfig.update(self.properties)\nconfig.update(config_response.overrides)\nself.properties = config\n# Update URI based on overrides\nself.uri = config[URI]\ndef _split_identifier_for_path(self, identifier: Union[str, Identifier]) -&gt; Properties:\nidentifier_tuple = self.identifier_to_tuple(identifier)\nif len(identifier_tuple) &lt;= 1:\nraise NoSuchTableError(f\"Missing namespace or invalid identifier: {'.'.join(identifier_tuple)}\")\nreturn {\"namespace\": NAMESPACE_SEPARATOR.join(identifier_tuple[:-1]), \"table\": identifier_tuple[-1]}\ndef _split_identifier_for_json(self, identifier: Union[str, Identifier]) -&gt; Dict[str, Union[Identifier, str]]:\nidentifier_tuple = self.identifier_to_tuple(identifier)\nif len(identifier_tuple) &lt;= 1:\nraise NoSuchTableError(f\"Missing namespace or invalid identifier: {identifier_tuple}\")\nreturn {\"namespace\": identifier_tuple[:-1], \"name\": identifier_tuple[-1]}\ndef _handle_non_200_response(self, exc: HTTPError, error_handler: Dict[int, Type[Exception]]) -&gt; None:\nexception: Type[Exception]\ncode = exc.response.status_code\nif code in error_handler:\nexception = error_handler[code]\nelif code == 400:\nexception = BadRequestError\nelif code == 401:\nexception = UnauthorizedError\nelif code == 403:\nexception = ForbiddenError\nelif code == 422:\nexception = RESTError\nelif code == 419:\nexception = AuthorizationExpiredError\nelif code == 501:\nexception = NotImplementedError\nelif code == 503:\nexception = ServiceUnavailableError\nelif 500 &lt;= code &lt; 600:\nexception = ServerError\nelse:\nexception = RESTError\ntry:\nif exception == OAuthError:\n# The OAuthErrorResponse has a different format\nerror = OAuthErrorResponse(**exc.response.json())\nresponse = str(error.error)\nif description := error.error_description:\nresponse += f\": {description}\"\nif uri := error.error_uri:\nresponse += f\" ({uri})\"\nelse:\nerror = ErrorResponse(**exc.response.json()).error\nresponse = f\"{error.type}: {error.message}\"\nexcept JSONDecodeError:\n# In the case we don't have a proper response\nresponse = f\"RESTError {exc.response.status_code}: Could not decode json payload: {exc.response.text}\"\nexcept ValidationError as e:\n# In the case we don't have a proper response\nerrs = \", \".join(err[\"msg\"] for err in e.errors())\nresponse = (\nf\"RESTError {exc.response.status_code}: Received unexpected JSON Payload: {exc.response.text}, errors: {errs}\"\n)\nraise exception(response) from exc\ndef _init_sigv4(self, session: Session) -&gt; None:\nfrom urllib import parse\nimport boto3\nfrom botocore.auth import SigV4Auth\nfrom botocore.awsrequest import AWSRequest\nfrom requests import PreparedRequest\nfrom requests.adapters import HTTPAdapter\nclass SigV4Adapter(HTTPAdapter):\ndef __init__(self, **properties: str):\nsuper().__init__()\nself._properties = properties\ndef add_headers(self, request: PreparedRequest, **kwargs: Any) -&gt; None:  # pylint: disable=W0613\nboto_session = boto3.Session()\ncredentials = boto_session.get_credentials().get_frozen_credentials()\nregion = self._properties.get(SIGV4_REGION, boto_session.region_name)\nservice = self._properties.get(SIGV4_SERVICE, \"execute-api\")\nurl = str(request.url).split(\"?\")[0]\nquery = str(parse.urlsplit(request.url).query)\nparams = dict(parse.parse_qsl(query))\n# remove the connection header as it will be updated after signing\ndel request.headers[\"connection\"]\naws_request = AWSRequest(\nmethod=request.method, url=url, params=params, data=request.body, headers=dict(request.headers)\n)\nSigV4Auth(credentials, service, region).add_auth(aws_request)\noriginal_header = request.headers\nsigned_headers = aws_request.headers\nrelocated_headers = {}\n# relocate headers if there is a conflict with signed headers\nfor header, value in original_header.items():\nif header in signed_headers and signed_headers[header] != value:\nrelocated_headers[f\"Original-{header}\"] = value\nrequest.headers.update(relocated_headers)\nrequest.headers.update(signed_headers)\nsession.mount(self.uri, SigV4Adapter(**self.properties))\ndef _response_to_table(self, identifier_tuple: Tuple[str, ...], table_response: TableResponse) -&gt; Table:\nreturn Table(\nidentifier=(self.name,) + identifier_tuple if self.name else identifier_tuple,\nmetadata_location=table_response.metadata_location,\nmetadata=table_response.metadata,\nio=self._load_file_io(\n{**table_response.metadata.properties, **table_response.config}, table_response.metadata_location\n),\ncatalog=self,\n)\ndef create_table(\nself,\nidentifier: Union[str, Identifier],\nschema: Schema,\nlocation: Optional[str] = None,\npartition_spec: PartitionSpec = UNPARTITIONED_PARTITION_SPEC,\nsort_order: SortOrder = UNSORTED_SORT_ORDER,\nproperties: Properties = EMPTY_DICT,\n) -&gt; Table:\nnamespace_and_table = self._split_identifier_for_path(identifier)\nrequest = CreateTableRequest(\nname=namespace_and_table[\"table\"],\nlocation=location,\ntable_schema=schema,\npartition_spec=partition_spec,\nwrite_order=sort_order,\nproperties=properties,\n)\nserialized_json = request.json()\nresponse = self._session.post(\nself.url(Endpoints.create_table, namespace=namespace_and_table[\"namespace\"]),\ndata=serialized_json,\n)\ntry:\nresponse.raise_for_status()\nexcept HTTPError as exc:\nself._handle_non_200_response(exc, {409: TableAlreadyExistsError})\ntable_response = TableResponse(**response.json())\nreturn self._response_to_table(self.identifier_to_tuple(identifier), table_response)\ndef list_tables(self, namespace: Union[str, Identifier]) -&gt; List[Identifier]:\nnamespace_tuple = self._check_valid_namespace_identifier(namespace)\nnamespace_concat = NAMESPACE_SEPARATOR.join(namespace_tuple)\nresponse = self._session.get(self.url(Endpoints.list_tables, namespace=namespace_concat))\ntry:\nresponse.raise_for_status()\nexcept HTTPError as exc:\nself._handle_non_200_response(exc, {404: NoSuchNamespaceError})\nreturn [(*table.namespace, table.name) for table in ListTablesResponse(**response.json()).identifiers]\ndef load_table(self, identifier: Union[str, Identifier]) -&gt; Table:\nidentifier_tuple = self.identifier_to_tuple(identifier)\nif len(identifier_tuple) &lt;= 1:\nraise NoSuchTableError(f\"Missing namespace or invalid identifier: {identifier}\")\nresponse = self._session.get(self.url(Endpoints.load_table, prefixed=True, **self._split_identifier_for_path(identifier)))\ntry:\nresponse.raise_for_status()\nexcept HTTPError as exc:\nself._handle_non_200_response(exc, {404: NoSuchTableError})\ntable_response = TableResponse(**response.json())\nreturn self._response_to_table(identifier_tuple, table_response)\ndef drop_table(self, identifier: Union[str, Identifier], purge_requested: bool = False) -&gt; None:\nresponse = self._session.delete(\nself.url(Endpoints.drop_table, prefixed=True, purge=purge_requested, **self._split_identifier_for_path(identifier)),\n)\ntry:\nresponse.raise_for_status()\nexcept HTTPError as exc:\nself._handle_non_200_response(exc, {404: NoSuchTableError})\ndef purge_table(self, identifier: Union[str, Identifier]) -&gt; None:\nself.drop_table(identifier=identifier, purge_requested=True)\ndef rename_table(self, from_identifier: Union[str, Identifier], to_identifier: Union[str, Identifier]) -&gt; Table:\npayload = {\n\"source\": self._split_identifier_for_json(from_identifier),\n\"destination\": self._split_identifier_for_json(to_identifier),\n}\nresponse = self._session.post(self.url(Endpoints.rename_table), json=payload)\ntry:\nresponse.raise_for_status()\nexcept HTTPError as exc:\nself._handle_non_200_response(exc, {404: NoSuchTableError, 409: TableAlreadyExistsError})\nreturn self.load_table(to_identifier)\ndef _commit_table(self, table_request: CommitTableRequest) -&gt; CommitTableResponse:\n\"\"\"Updates the table.\n        Args:\n            table_request (CommitTableRequest): The table requests to be carried out.\n        Returns:\n            CommitTableResponse: The updated metadata.\n        Raises:\n            NoSuchTableError: If a table with the given identifier does not exist.\n        \"\"\"\nresponse = self._session.post(\nself.url(Endpoints.update_table, prefixed=True, **self._split_identifier_for_path(table_request.identifier)),\ndata=table_request.json(),\n)\ntry:\nresponse.raise_for_status()\nexcept HTTPError as exc:\nself._handle_non_200_response(\nexc,\n{\n409: CommitFailedException,\n500: CommitStateUnknownException,\n502: CommitStateUnknownException,\n504: CommitStateUnknownException,\n},\n)\nreturn CommitTableResponse(**response.json())\ndef create_namespace(self, namespace: Union[str, Identifier], properties: Properties = EMPTY_DICT) -&gt; None:\nnamespace_tuple = self._check_valid_namespace_identifier(namespace)\npayload = {\"namespace\": namespace_tuple, \"properties\": properties}\nresponse = self._session.post(self.url(Endpoints.create_namespace), json=payload)\ntry:\nresponse.raise_for_status()\nexcept HTTPError as exc:\nself._handle_non_200_response(exc, {404: NoSuchNamespaceError, 409: NamespaceAlreadyExistsError})\ndef drop_namespace(self, namespace: Union[str, Identifier]) -&gt; None:\nnamespace_tuple = self._check_valid_namespace_identifier(namespace)\nnamespace = NAMESPACE_SEPARATOR.join(namespace_tuple)\nresponse = self._session.delete(self.url(Endpoints.drop_namespace, namespace=namespace))\ntry:\nresponse.raise_for_status()\nexcept HTTPError as exc:\nself._handle_non_200_response(exc, {404: NoSuchNamespaceError})\ndef list_namespaces(self, namespace: Union[str, Identifier] = ()) -&gt; List[Identifier]:\nnamespace_tuple = self.identifier_to_tuple(namespace)\nresponse = self._session.get(\nself.url(\nf\"{Endpoints.list_namespaces}?parent={NAMESPACE_SEPARATOR.join(namespace_tuple)}\"\nif namespace_tuple\nelse Endpoints.list_namespaces\n),\n)\ntry:\nresponse.raise_for_status()\nexcept HTTPError as exc:\nself._handle_non_200_response(exc, {})\nnamespaces = ListNamespaceResponse(**response.json())\nreturn [namespace_tuple + child_namespace for child_namespace in namespaces.namespaces]\ndef load_namespace_properties(self, namespace: Union[str, Identifier]) -&gt; Properties:\nnamespace_tuple = self._check_valid_namespace_identifier(namespace)\nnamespace = NAMESPACE_SEPARATOR.join(namespace_tuple)\nresponse = self._session.get(self.url(Endpoints.load_namespace_metadata, namespace=namespace))\ntry:\nresponse.raise_for_status()\nexcept HTTPError as exc:\nself._handle_non_200_response(exc, {404: NoSuchNamespaceError})\nreturn NamespaceResponse(**response.json()).properties\ndef update_namespace_properties(\nself, namespace: Union[str, Identifier], removals: Optional[Set[str]] = None, updates: Properties = EMPTY_DICT\n) -&gt; PropertiesUpdateSummary:\nnamespace_tuple = self._check_valid_namespace_identifier(namespace)\nnamespace = NAMESPACE_SEPARATOR.join(namespace_tuple)\npayload = {\"removals\": list(removals or []), \"updates\": updates}\nresponse = self._session.post(self.url(Endpoints.update_namespace_properties, namespace=namespace), json=payload)\ntry:\nresponse.raise_for_status()\nexcept HTTPError as exc:\nself._handle_non_200_response(exc, {404: NoSuchNamespaceError})\nparsed_response = UpdateNamespacePropertiesResponse(**response.json())\nreturn PropertiesUpdateSummary(\nremoved=parsed_response.removed,\nupdated=parsed_response.updated,\nmissing=parsed_response.missing,\n)\n</code></pre>"},{"location":"reference/pyiceberg/catalog/rest/#pyiceberg.catalog.rest.RestCatalog.__init__","title":"<code>__init__(name, **properties)</code>","text":"<p>Rest Catalog.</p> <p>You either need to provide a client_id and client_secret, or an already valid token.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to identify the catalog.</p> required <code>properties</code> <code>str</code> <p>Properties that are passed along to the configuration.</p> <code>{}</code> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/rest.py</code> <pre><code>def __init__(self, name: str, **properties: str):\n\"\"\"Rest Catalog.\n    You either need to provide a client_id and client_secret, or an already valid token.\n    Args:\n        name: Name to identify the catalog.\n        properties: Properties that are passed along to the configuration.\n    \"\"\"\nsuper().__init__(name, **properties)\nself.uri = properties[URI]\nself._fetch_config()\nself._session = self._create_session()\n</code></pre>"},{"location":"reference/pyiceberg/catalog/rest/#pyiceberg.catalog.rest.RestCatalog.url","title":"<code>url(endpoint, prefixed=True, **kwargs)</code>","text":"<p>Constructs the endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Resource identifier that points to the REST catalog.</p> required <code>prefixed</code> <code>bool</code> <p>If the prefix return by the config needs to be appended.</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>The base url of the rest catalog.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/catalog/rest.py</code> <pre><code>def url(self, endpoint: str, prefixed: bool = True, **kwargs: Any) -&gt; str:\n\"\"\"Constructs the endpoint.\n    Args:\n        endpoint: Resource identifier that points to the REST catalog.\n        prefixed: If the prefix return by the config needs to be appended.\n    Returns:\n        The base url of the rest catalog.\n    \"\"\"\nurl = self.uri\nurl = url + \"v1/\" if url.endswith(\"/\") else url + \"/v1/\"\nif prefixed:\nurl += self.properties.get(PREFIX, \"\")\nurl = url if url.endswith(\"/\") else url + \"/\"\nreturn url + endpoint.format(**kwargs)\n</code></pre>"},{"location":"reference/pyiceberg/cli/","title":"cli","text":""},{"location":"reference/pyiceberg/cli/console/","title":"console","text":""},{"location":"reference/pyiceberg/cli/console/#pyiceberg.cli.console.describe","title":"<code>describe(ctx, entity, identifier)</code>","text":"<p>Describes a namespace or a table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/console.py</code> <pre><code>@run.command()\n@click.option(\"--entity\", type=click.Choice([\"any\", \"namespace\", \"table\"]), default=\"any\")\n@click.argument(\"identifier\")\n@click.pass_context\n@catch_exception()\ndef describe(ctx: Context, entity: Literal[\"name\", \"namespace\", \"table\"], identifier: str) -&gt; None:\n\"\"\"Describes a namespace or a table.\"\"\"\ncatalog, output = _catalog_and_output(ctx)\nidentifier_tuple = Catalog.identifier_to_tuple(identifier)\nis_namespace = False\nif entity in {\"namespace\", \"any\"} and len(identifier_tuple) &gt; 0:\ntry:\nnamespace_properties = catalog.load_namespace_properties(identifier_tuple)\noutput.describe_properties(namespace_properties)\nis_namespace = True\nexcept NoSuchNamespaceError as exc:\nif entity != \"any\" or len(identifier_tuple) == 1:  # type: ignore\nraise exc\nis_table = False\nif entity in {\"table\", \"any\"} and len(identifier_tuple) &gt; 1:\ntry:\ncatalog_table = catalog.load_table(identifier)\noutput.describe_table(catalog_table)\nis_table = True\nexcept NoSuchTableError as exc:\nif entity != \"any\":\nraise exc\nif is_namespace is False and is_table is False:\nraise NoSuchTableError(f\"Table or namespace does not exist: {identifier}\")\n</code></pre>"},{"location":"reference/pyiceberg/cli/console/#pyiceberg.cli.console.drop","title":"<code>drop()</code>","text":"<p>Operations to drop a namespace or table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/console.py</code> <pre><code>@run.group()\ndef drop() -&gt; None:\n\"\"\"Operations to drop a namespace or table.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/cli/console/#pyiceberg.cli.console.files","title":"<code>files(ctx, identifier, history)</code>","text":"<p>Lists all the files of the table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/console.py</code> <pre><code>@run.command()\n@click.argument(\"identifier\")\n@click.option(\"--history\", is_flag=True)\n@click.pass_context\n@catch_exception()\ndef files(ctx: Context, identifier: str, history: bool) -&gt; None:\n\"\"\"Lists all the files of the table.\"\"\"\ncatalog, output = _catalog_and_output(ctx)\ncatalog_table = catalog.load_table(identifier)\noutput.files(catalog_table, history)\n</code></pre>"},{"location":"reference/pyiceberg/cli/console/#pyiceberg.cli.console.get","title":"<code>get()</code>","text":"<p>Fetch properties on tables/namespaces.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/console.py</code> <pre><code>@properties.group()\ndef get() -&gt; None:\n\"\"\"Fetch properties on tables/namespaces.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/cli/console/#pyiceberg.cli.console.get_namespace","title":"<code>get_namespace(ctx, identifier, property_name)</code>","text":"<p>Fetch properties on a namespace.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/console.py</code> <pre><code>@get.command(\"namespace\")\n@click.argument(\"identifier\")\n@click.argument(\"property_name\", required=False)\n@click.pass_context\n@catch_exception()\ndef get_namespace(ctx: Context, identifier: str, property_name: str) -&gt; None:\n\"\"\"Fetch properties on a namespace.\"\"\"\ncatalog, output = _catalog_and_output(ctx)\nidentifier_tuple = Catalog.identifier_to_tuple(identifier)\nnamespace_properties = catalog.load_namespace_properties(identifier_tuple)\nassert namespace_properties\nif property_name:\nif property_value := namespace_properties.get(property_name):\noutput.text(property_value)\nelse:\nraise NoSuchPropertyException(f\"Could not find property {property_name} on namespace {identifier}\")\nelse:\noutput.describe_properties(namespace_properties)\n</code></pre>"},{"location":"reference/pyiceberg/cli/console/#pyiceberg.cli.console.get_table","title":"<code>get_table(ctx, identifier, property_name)</code>","text":"<p>Fetch properties on a table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/console.py</code> <pre><code>@get.command(\"table\")\n@click.argument(\"identifier\")\n@click.argument(\"property_name\", required=False)\n@click.pass_context\n@catch_exception()\ndef get_table(ctx: Context, identifier: str, property_name: str) -&gt; None:\n\"\"\"Fetch properties on a table.\"\"\"\ncatalog, output = _catalog_and_output(ctx)\nidentifier_tuple = Catalog.identifier_to_tuple(identifier)\nmetadata = catalog.load_table(identifier_tuple).metadata\nassert metadata\nif property_name:\nif property_value := metadata.properties.get(property_name):\noutput.text(property_value)\nelse:\nraise NoSuchPropertyException(f\"Could not find property {property_name} on table {identifier}\")\nelse:\noutput.describe_properties(metadata.properties)\n</code></pre>"},{"location":"reference/pyiceberg/cli/console/#pyiceberg.cli.console.list","title":"<code>list(ctx, parent)</code>","text":"<p>Lists tables or namespaces.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/console.py</code> <pre><code>@run.command()\n@click.pass_context\n@click.argument(\"parent\", required=False)\n@catch_exception()\ndef list(ctx: Context, parent: Optional[str]) -&gt; None:  # pylint: disable=redefined-builtin\n\"\"\"Lists tables or namespaces.\"\"\"\ncatalog, output = _catalog_and_output(ctx)\nidentifiers = catalog.list_namespaces(parent or ())\nif not identifiers and parent:\nidentifiers = catalog.list_tables(parent)\noutput.identifiers(identifiers)\n</code></pre>"},{"location":"reference/pyiceberg/cli/console/#pyiceberg.cli.console.location","title":"<code>location(ctx, identifier)</code>","text":"<p>Returns the location of the table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/console.py</code> <pre><code>@run.command()\n@click.argument(\"identifier\")\n@click.pass_context\n@catch_exception()\ndef location(ctx: Context, identifier: str) -&gt; None:\n\"\"\"Returns the location of the table.\"\"\"\ncatalog, output = _catalog_and_output(ctx)\ntable = catalog.load_table(identifier)\noutput.text(table.location())\n</code></pre>"},{"location":"reference/pyiceberg/cli/console/#pyiceberg.cli.console.namespace","title":"<code>namespace(ctx, identifier, property_name)</code>","text":"<p>Removes a property from a namespace.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/console.py</code> <pre><code>@remove.command()  # type: ignore\n@click.argument(\"identifier\")\n@click.argument(\"property_name\")\n@click.pass_context\n@catch_exception()\ndef namespace(ctx: Context, identifier: str, property_name: str) -&gt; None:  # noqa: F811\n\"\"\"Removes a property from a namespace.\"\"\"\ncatalog, output = _catalog_and_output(ctx)\nresult = catalog.update_namespace_properties(identifier, removals={property_name})\nif result.removed == [property_name]:\noutput.text(f\"Property {property_name} removed from {identifier}\")\nelse:\nraise NoSuchPropertyException(f\"Property {property_name} does not exist on {identifier}\")\n</code></pre>"},{"location":"reference/pyiceberg/cli/console/#pyiceberg.cli.console.properties","title":"<code>properties()</code>","text":"<p>Properties on tables/namespaces.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/console.py</code> <pre><code>@run.group()\ndef properties() -&gt; None:\n\"\"\"Properties on tables/namespaces.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/cli/console/#pyiceberg.cli.console.remove","title":"<code>remove()</code>","text":"<p>Removes a property from tables/namespaces.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/console.py</code> <pre><code>@properties.group()\ndef remove() -&gt; None:\n\"\"\"Removes a property from tables/namespaces.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/cli/console/#pyiceberg.cli.console.rename","title":"<code>rename(ctx, from_identifier, to_identifier)</code>","text":"<p>Renames a table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/console.py</code> <pre><code>@run.command()\n@click.argument(\"from_identifier\")\n@click.argument(\"to_identifier\")\n@click.pass_context\n@catch_exception()\ndef rename(ctx: Context, from_identifier: str, to_identifier: str) -&gt; None:\n\"\"\"Renames a table.\"\"\"\ncatalog, output = _catalog_and_output(ctx)\ncatalog.rename_table(from_identifier, to_identifier)\noutput.text(f\"Renamed table from {from_identifier} to {to_identifier}\")\n</code></pre>"},{"location":"reference/pyiceberg/cli/console/#pyiceberg.cli.console.schema","title":"<code>schema(ctx, identifier)</code>","text":"<p>Gets the schema of the table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/console.py</code> <pre><code>@run.command()\n@click.argument(\"identifier\")\n@click.pass_context\n@catch_exception()\ndef schema(ctx: Context, identifier: str) -&gt; None:\n\"\"\"Gets the schema of the table.\"\"\"\ncatalog, output = _catalog_and_output(ctx)\ntable = catalog.load_table(identifier)\noutput.schema(table.schema())\n</code></pre>"},{"location":"reference/pyiceberg/cli/console/#pyiceberg.cli.console.set","title":"<code>set()</code>","text":"<p>Sets a property on tables/namespaces.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/console.py</code> <pre><code>@properties.group()\ndef set() -&gt; None:\n\"\"\"Sets a property on tables/namespaces.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/cli/console/#pyiceberg.cli.console.spec","title":"<code>spec(ctx, identifier)</code>","text":"<p>Returns the partition spec of the table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/console.py</code> <pre><code>@run.command()\n@click.argument(\"identifier\")\n@click.pass_context\n@catch_exception()\ndef spec(ctx: Context, identifier: str) -&gt; None:\n\"\"\"Returns the partition spec of the table.\"\"\"\ncatalog, output = _catalog_and_output(ctx)\ntable = catalog.load_table(identifier)\noutput.spec(table.spec())\n</code></pre>"},{"location":"reference/pyiceberg/cli/console/#pyiceberg.cli.console.table","title":"<code>table(ctx, identifier, property_name)</code>","text":"<p>Removes a property from a table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/console.py</code> <pre><code>@remove.command()  # type: ignore\n@click.argument(\"identifier\")\n@click.argument(\"property_name\")\n@click.pass_context\n@catch_exception()\ndef table(ctx: Context, identifier: str, property_name: str) -&gt; None:  # noqa: F811\n\"\"\"Removes a property from a table.\"\"\"\ncatalog, output = _catalog_and_output(ctx)\ntable = catalog.load_table(identifier)\nif property_name in table.metadata.properties:\n# We should think of the process here\n# Do we want something similar as in Java:\n# https://github.com/apache/iceberg/blob/master/api/src/main/java/org/apache/iceberg/Table.java#L178\ndel table.metadata.properties\noutput.exception(NotImplementedError(\"Writing is WIP\"))\nctx.exit(1)\nelse:\nraise NoSuchPropertyException(f\"Property {property_name} does not exist on {identifier}\")\n</code></pre>"},{"location":"reference/pyiceberg/cli/console/#pyiceberg.cli.console.uuid","title":"<code>uuid(ctx, identifier)</code>","text":"<p>Returns the UUID of the table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/console.py</code> <pre><code>@run.command()\n@click.argument(\"identifier\")\n@click.pass_context\n@catch_exception()\ndef uuid(ctx: Context, identifier: str) -&gt; None:\n\"\"\"Returns the UUID of the table.\"\"\"\ncatalog, output = _catalog_and_output(ctx)\nmetadata = catalog.load_table(identifier).metadata\noutput.uuid(metadata.table_uuid)\n</code></pre>"},{"location":"reference/pyiceberg/cli/output/","title":"output","text":""},{"location":"reference/pyiceberg/cli/output/#pyiceberg.cli.output.ConsoleOutput","title":"<code>ConsoleOutput</code>","text":"<p>         Bases: <code>Output</code></p> <p>Writes to the console.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/output.py</code> <pre><code>class ConsoleOutput(Output):\n\"\"\"Writes to the console.\"\"\"\nverbose: bool\ndef __init__(self, **properties: Any) -&gt; None:\nself.verbose = properties.get(\"verbose\", False)\n@property\ndef _table(self) -&gt; RichTable:\nreturn RichTable.grid(padding=(0, 2))\ndef exception(self, ex: Exception) -&gt; None:\nif self.verbose:\nConsole(stderr=True).print_exception()\nelse:\nConsole(stderr=True).print(ex)\ndef identifiers(self, identifiers: List[Identifier]) -&gt; None:\ntable = self._table\nfor identifier in identifiers:\ntable.add_row(\".\".join(identifier))\nConsole().print(table)\ndef describe_table(self, table: Table) -&gt; None:\nmetadata = table.metadata\ntable_properties = self._table\nfor key, value in metadata.properties.items():\ntable_properties.add_row(key, value)\nschema_tree = Tree(f\"Schema, id={table.metadata.current_schema_id}\")\nfor field in table.schema().fields:\nschema_tree.add(str(field))\nsnapshot_tree = Tree(\"Snapshots\")\nfor snapshot in metadata.snapshots:\nmanifest_list_str = f\": {snapshot.manifest_list}\" if snapshot.manifest_list else \"\"\nsnapshot_tree.add(f\"Snapshot {snapshot.snapshot_id}, schema {snapshot.schema_id}{manifest_list_str}\")\noutput_table = self._table\noutput_table.add_row(\"Table format version\", str(metadata.format_version))\noutput_table.add_row(\"Metadata location\", table.metadata_location)\noutput_table.add_row(\"Table UUID\", str(table.metadata.table_uuid))\noutput_table.add_row(\"Last Updated\", str(metadata.last_updated_ms))\noutput_table.add_row(\"Partition spec\", str(table.spec()))\noutput_table.add_row(\"Sort order\", str(table.sort_order()))\noutput_table.add_row(\"Current schema\", schema_tree)\noutput_table.add_row(\"Current snapshot\", str(table.current_snapshot()))\noutput_table.add_row(\"Snapshots\", snapshot_tree)\noutput_table.add_row(\"Properties\", table_properties)\nConsole().print(output_table)\ndef files(self, table: Table, history: bool) -&gt; None:\nif history:\nsnapshots = table.metadata.snapshots\nelse:\nif snapshot := table.current_snapshot():\nsnapshots = [snapshot]\nelse:\nsnapshots = []\nsnapshot_tree = Tree(f\"Snapshots: {'.'.join(table.identifier)}\")\nio = table.io\nfor snapshot in snapshots:\nmanifest_list_str = f\": {snapshot.manifest_list}\" if snapshot.manifest_list else \"\"\nlist_tree = snapshot_tree.add(f\"Snapshot {snapshot.snapshot_id}, schema {snapshot.schema_id}{manifest_list_str}\")\nmanifest_list = snapshot.manifests(io)\nfor manifest in manifest_list:\nmanifest_tree = list_tree.add(f\"Manifest: {manifest.manifest_path}\")\nfor manifest_entry in manifest.fetch_manifest_entry(io, discard_deleted=False):\nmanifest_tree.add(f\"Datafile: {manifest_entry.data_file.file_path}\")\nConsole().print(snapshot_tree)\ndef describe_properties(self, properties: Properties) -&gt; None:\noutput_table = self._table\nfor k, v in properties.items():\noutput_table.add_row(k, v)\nConsole().print(output_table)\ndef text(self, response: str) -&gt; None:\nConsole().print(response)\ndef schema(self, schema: Schema) -&gt; None:\noutput_table = self._table\nfor field in schema.fields:\noutput_table.add_row(field.name, str(field.field_type), field.doc or \"\")\nConsole().print(output_table)\ndef spec(self, spec: PartitionSpec) -&gt; None:\nConsole().print(str(spec))\ndef uuid(self, uuid: Optional[UUID]) -&gt; None:\nConsole().print(str(uuid) if uuid else \"missing\")\n</code></pre>"},{"location":"reference/pyiceberg/cli/output/#pyiceberg.cli.output.JsonOutput","title":"<code>JsonOutput</code>","text":"<p>         Bases: <code>Output</code></p> <p>Writes json to stdout.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/output.py</code> <pre><code>class JsonOutput(Output):\n\"\"\"Writes json to stdout.\"\"\"\nverbose: bool\ndef __init__(self, **properties: Any) -&gt; None:\nself.verbose = properties.get(\"verbose\", False)\ndef _out(self, d: Any) -&gt; None:\nprint(json.dumps(d))\ndef exception(self, ex: Exception) -&gt; None:\nself._out({\"type\": ex.__class__.__name__, \"message\": str(ex)})\ndef identifiers(self, identifiers: List[Identifier]) -&gt; None:\nself._out([\".\".join(identifier) for identifier in identifiers])\ndef describe_table(self, table: Table) -&gt; None:\nclass FauxTable(IcebergBaseModel):\n\"\"\"Just to encode it using Pydantic.\"\"\"\nidentifier: Identifier\nmetadata_location: str\nmetadata: TableMetadata\nprint(FauxTable(identifier=table.identifier, metadata=table.metadata, metadata_location=table.metadata_location).json())\ndef describe_properties(self, properties: Properties) -&gt; None:\nself._out(properties)\ndef text(self, response: str) -&gt; None:\nprint(json.dumps(response))\ndef schema(self, schema: Schema) -&gt; None:\nprint(schema.json())\ndef files(self, table: Table, history: bool) -&gt; None:\npass\ndef spec(self, spec: PartitionSpec) -&gt; None:\nprint(spec.json())\ndef uuid(self, uuid: Optional[UUID]) -&gt; None:\nself._out({\"uuid\": str(uuid) if uuid else \"missing\"})\n</code></pre>"},{"location":"reference/pyiceberg/cli/output/#pyiceberg.cli.output.Output","title":"<code>Output</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Output interface for exporting.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/cli/output.py</code> <pre><code>class Output(ABC):\n\"\"\"Output interface for exporting.\"\"\"\n@abstractmethod\ndef exception(self, ex: Exception) -&gt; None:\n...\n@abstractmethod\ndef identifiers(self, identifiers: List[Identifier]) -&gt; None:\n...\n@abstractmethod\ndef describe_table(self, table: Table) -&gt; None:\n...\n@abstractmethod\ndef files(self, table: Table, history: bool) -&gt; None:\n...\n@abstractmethod\ndef describe_properties(self, properties: Properties) -&gt; None:\n...\n@abstractmethod\ndef text(self, response: str) -&gt; None:\n...\n@abstractmethod\ndef schema(self, schema: Schema) -&gt; None:\n...\n@abstractmethod\ndef spec(self, spec: PartitionSpec) -&gt; None:\n...\n@abstractmethod\ndef uuid(self, uuid: Optional[UUID]) -&gt; None:\n...\n</code></pre>"},{"location":"reference/pyiceberg/expressions/","title":"expressions","text":""},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.AlwaysFalse","title":"<code>AlwaysFalse</code>","text":"<p>         Bases: <code>BooleanExpression</code>, <code>Singleton</code></p> <p>FALSE expression.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class AlwaysFalse(BooleanExpression, Singleton):\n\"\"\"FALSE expression.\"\"\"\ndef __invert__(self) -&gt; AlwaysTrue:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn AlwaysTrue()\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the AlwaysFalse class.\"\"\"\nreturn \"AlwaysFalse()\"\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the AlwaysFalse class.\"\"\"\nreturn \"AlwaysFalse()\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.AlwaysFalse.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; AlwaysTrue:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn AlwaysTrue()\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.AlwaysFalse.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the AlwaysFalse class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the AlwaysFalse class.\"\"\"\nreturn \"AlwaysFalse()\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.AlwaysFalse.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the AlwaysFalse class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the AlwaysFalse class.\"\"\"\nreturn \"AlwaysFalse()\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.AlwaysTrue","title":"<code>AlwaysTrue</code>","text":"<p>         Bases: <code>BooleanExpression</code>, <code>Singleton</code></p> <p>TRUE expression.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class AlwaysTrue(BooleanExpression, Singleton):\n\"\"\"TRUE expression.\"\"\"\ndef __invert__(self) -&gt; AlwaysFalse:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn AlwaysFalse()\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the AlwaysTrue class.\"\"\"\nreturn \"AlwaysTrue()\"\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the AlwaysTrue class.\"\"\"\nreturn \"AlwaysTrue()\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.AlwaysTrue.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; AlwaysFalse:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn AlwaysFalse()\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.AlwaysTrue.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the AlwaysTrue class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the AlwaysTrue class.\"\"\"\nreturn \"AlwaysTrue()\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.AlwaysTrue.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the AlwaysTrue class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the AlwaysTrue class.\"\"\"\nreturn \"AlwaysTrue()\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.And","title":"<code>And</code>","text":"<p>         Bases: <code>BooleanExpression</code></p> <p>AND operation expression - logical conjunction.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class And(BooleanExpression):\n\"\"\"AND operation expression - logical conjunction.\"\"\"\nleft: BooleanExpression\nright: BooleanExpression\ndef __new__(cls, left: BooleanExpression, right: BooleanExpression, *rest: BooleanExpression) -&gt; BooleanExpression:  # type: ignore\nif rest:\nreturn reduce(And, (left, right, *rest))\nif left is AlwaysFalse() or right is AlwaysFalse():\nreturn AlwaysFalse()\nelif left is AlwaysTrue():\nreturn right\nelif right is AlwaysTrue():\nreturn left\nelse:\nobj = super().__new__(cls)\nobj.left = left\nobj.right = right\nreturn obj\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the And class.\"\"\"\nreturn self.left == other.left and self.right == other.right if isinstance(other, And) else False\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the And class.\"\"\"\nreturn f\"And(left={str(self.left)}, right={str(self.right)})\"\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the And class.\"\"\"\nreturn f\"And(left={repr(self.left)}, right={repr(self.right)})\"\ndef __invert__(self) -&gt; BooleanExpression:\n\"\"\"Transform the Expression into its negated version.\"\"\"\n# De Morgan's law: not (A and B) = (not A) or (not B)\nreturn Or(~self.left, ~self.right)\ndef __getnewargs__(self) -&gt; Tuple[BooleanExpression, BooleanExpression]:\n\"\"\"A magic function for pickling the And class.\"\"\"\nreturn (self.left, self.right)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.And.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the And class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the And class.\"\"\"\nreturn self.left == other.left and self.right == other.right if isinstance(other, And) else False\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.And.__getnewargs__","title":"<code>__getnewargs__()</code>","text":"<p>A magic function for pickling the And class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __getnewargs__(self) -&gt; Tuple[BooleanExpression, BooleanExpression]:\n\"\"\"A magic function for pickling the And class.\"\"\"\nreturn (self.left, self.right)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.And.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; BooleanExpression:\n\"\"\"Transform the Expression into its negated version.\"\"\"\n# De Morgan's law: not (A and B) = (not A) or (not B)\nreturn Or(~self.left, ~self.right)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.And.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the And class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the And class.\"\"\"\nreturn f\"And(left={repr(self.left)}, right={repr(self.right)})\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.And.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the And class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the And class.\"\"\"\nreturn f\"And(left={str(self.left)}, right={str(self.right)})\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BooleanExpression","title":"<code>BooleanExpression</code>","text":"<p>         Bases: <code>ABC</code></p> <p>An expression that evaluates to a boolean.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BooleanExpression(ABC):\n\"\"\"An expression that evaluates to a boolean.\"\"\"\n@abstractmethod\ndef __invert__(self) -&gt; BooleanExpression:\n\"\"\"Transform the Expression into its negated version.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BooleanExpression.__invert__","title":"<code>__invert__()</code>  <code>abstractmethod</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>@abstractmethod\ndef __invert__(self) -&gt; BooleanExpression:\n\"\"\"Transform the Expression into its negated version.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.Bound","title":"<code>Bound</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Represents a bound value expression.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class Bound(ABC):\n\"\"\"Represents a bound value expression.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundEqualTo","title":"<code>BoundEqualTo</code>","text":"<p>         Bases: <code>BoundLiteralPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundEqualTo(BoundLiteralPredicate[L]):\ndef __invert__(self) -&gt; BoundNotEqualTo[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundNotEqualTo[L](self.term, self.literal)\n@property\ndef as_unbound(self) -&gt; Type[EqualTo[L]]:\nreturn EqualTo\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundEqualTo.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; BoundNotEqualTo[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundNotEqualTo[L](self.term, self.literal)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundGreaterThan","title":"<code>BoundGreaterThan</code>","text":"<p>         Bases: <code>BoundLiteralPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundGreaterThan(BoundLiteralPredicate[L]):\ndef __invert__(self) -&gt; BoundLessThanOrEqual[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundLessThanOrEqual(self.term, self.literal)\n@property\ndef as_unbound(self) -&gt; Type[GreaterThan[L]]:\nreturn GreaterThan[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundGreaterThan.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; BoundLessThanOrEqual[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundLessThanOrEqual(self.term, self.literal)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundGreaterThanOrEqual","title":"<code>BoundGreaterThanOrEqual</code>","text":"<p>         Bases: <code>BoundLiteralPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundGreaterThanOrEqual(BoundLiteralPredicate[L]):\ndef __invert__(self) -&gt; BoundLessThan[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundLessThan[L](self.term, self.literal)\n@property\ndef as_unbound(self) -&gt; Type[GreaterThanOrEqual[L]]:\nreturn GreaterThanOrEqual[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundGreaterThanOrEqual.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; BoundLessThan[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundLessThan[L](self.term, self.literal)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundIn","title":"<code>BoundIn</code>","text":"<p>         Bases: <code>BoundSetPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundIn(BoundSetPredicate[L]):\ndef __new__(cls, term: BoundTerm[L], literals: Set[Literal[L]]) -&gt; BooleanExpression:  # type: ignore  # pylint: disable=W0221\ncount = len(literals)\nif count == 0:\nreturn AlwaysFalse()\nelif count == 1:\nreturn BoundEqualTo(term, next(iter(literals)))\nelse:\nreturn super().__new__(cls)\ndef __invert__(self) -&gt; BoundNotIn[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundNotIn(self.term, self.literals)\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the BoundIn class.\"\"\"\nreturn self.term == other.term and self.literals == other.literals if isinstance(other, BoundIn) else False\n@property\ndef as_unbound(self) -&gt; Type[In[L]]:\nreturn In\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundIn.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the BoundIn class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the BoundIn class.\"\"\"\nreturn self.term == other.term and self.literals == other.literals if isinstance(other, BoundIn) else False\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundIn.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; BoundNotIn[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundNotIn(self.term, self.literals)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundIsNaN","title":"<code>BoundIsNaN</code>","text":"<p>         Bases: <code>BoundUnaryPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundIsNaN(BoundUnaryPredicate[L]):\ndef __new__(cls, term: BoundTerm[L]) -&gt; BooleanExpression:  # type: ignore  # pylint: disable=W0221\nbound_type = term.ref().field.field_type\nif type(bound_type) in {FloatType, DoubleType}:\nreturn super().__new__(cls)\nreturn AlwaysFalse()\ndef __invert__(self) -&gt; BoundNotNaN[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundNotNaN(self.term)\n@property\ndef as_unbound(self) -&gt; Type[IsNaN]:\nreturn IsNaN\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundIsNaN.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; BoundNotNaN[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundNotNaN(self.term)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundIsNull","title":"<code>BoundIsNull</code>","text":"<p>         Bases: <code>BoundUnaryPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundIsNull(BoundUnaryPredicate[L]):\ndef __new__(cls, term: BoundTerm[L]) -&gt; BooleanExpression:  # type: ignore  # pylint: disable=W0221\nif term.ref().field.required:\nreturn AlwaysFalse()\nreturn super().__new__(cls)\ndef __invert__(self) -&gt; BoundNotNull[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundNotNull(self.term)\n@property\ndef as_unbound(self) -&gt; Type[IsNull]:\nreturn IsNull\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundIsNull.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; BoundNotNull[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundNotNull(self.term)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundLessThan","title":"<code>BoundLessThan</code>","text":"<p>         Bases: <code>BoundLiteralPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundLessThan(BoundLiteralPredicate[L]):\ndef __invert__(self) -&gt; BoundGreaterThanOrEqual[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundGreaterThanOrEqual[L](self.term, self.literal)\n@property\ndef as_unbound(self) -&gt; Type[LessThan[L]]:\nreturn LessThan[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundLessThan.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; BoundGreaterThanOrEqual[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundGreaterThanOrEqual[L](self.term, self.literal)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundLessThanOrEqual","title":"<code>BoundLessThanOrEqual</code>","text":"<p>         Bases: <code>BoundLiteralPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundLessThanOrEqual(BoundLiteralPredicate[L]):\ndef __invert__(self) -&gt; BoundGreaterThan[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundGreaterThan[L](self.term, self.literal)\n@property\ndef as_unbound(self) -&gt; Type[LessThanOrEqual[L]]:\nreturn LessThanOrEqual[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundLessThanOrEqual.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; BoundGreaterThan[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundGreaterThan[L](self.term, self.literal)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundLiteralPredicate","title":"<code>BoundLiteralPredicate</code>","text":"<p>         Bases: <code>BoundPredicate[L]</code>, <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundLiteralPredicate(BoundPredicate[L], ABC):\nliteral: Literal[L]\ndef __init__(self, term: BoundTerm[L], literal: Literal[L]):  # pylint: disable=W0621\n# Since we don't know the type of BoundPredicate[L], we have to ignore this one\nsuper().__init__(term)  # type: ignore\nself.literal = literal  # pylint: disable=W0621\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the BoundLiteralPredicate class.\"\"\"\nif isinstance(other, BoundLiteralPredicate):\nreturn self.term == other.term and self.literal == other.literal\nreturn False\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the BoundLiteralPredicate class.\"\"\"\nreturn f\"{str(self.__class__.__name__)}(term={repr(self.term)}, literal={repr(self.literal)})\"\n@property\n@abstractmethod\ndef as_unbound(self) -&gt; Type[LiteralPredicate[L]]:\n...\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundLiteralPredicate.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the BoundLiteralPredicate class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the BoundLiteralPredicate class.\"\"\"\nif isinstance(other, BoundLiteralPredicate):\nreturn self.term == other.term and self.literal == other.literal\nreturn False\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundLiteralPredicate.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the BoundLiteralPredicate class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the BoundLiteralPredicate class.\"\"\"\nreturn f\"{str(self.__class__.__name__)}(term={repr(self.term)}, literal={repr(self.literal)})\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundNotEqualTo","title":"<code>BoundNotEqualTo</code>","text":"<p>         Bases: <code>BoundLiteralPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundNotEqualTo(BoundLiteralPredicate[L]):\ndef __invert__(self) -&gt; BoundEqualTo[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundEqualTo[L](self.term, self.literal)\n@property\ndef as_unbound(self) -&gt; Type[NotEqualTo[L]]:\nreturn NotEqualTo\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundNotEqualTo.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; BoundEqualTo[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundEqualTo[L](self.term, self.literal)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundNotIn","title":"<code>BoundNotIn</code>","text":"<p>         Bases: <code>BoundSetPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundNotIn(BoundSetPredicate[L]):\ndef __new__(  # type: ignore  # pylint: disable=W0221\ncls,\nterm: BoundTerm[L],\nliterals: Set[Literal[L]],\n) -&gt; BooleanExpression:\ncount = len(literals)\nif count == 0:\nreturn AlwaysTrue()\nelif count == 1:\nreturn BoundNotEqualTo(term, next(iter(literals)))\nelse:\nreturn super().__new__(cls)\ndef __invert__(self) -&gt; BoundIn[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundIn(self.term, self.literals)\n@property\ndef as_unbound(self) -&gt; Type[NotIn[L]]:\nreturn NotIn\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundNotIn.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; BoundIn[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundIn(self.term, self.literals)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundNotNaN","title":"<code>BoundNotNaN</code>","text":"<p>         Bases: <code>BoundUnaryPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundNotNaN(BoundUnaryPredicate[L]):\ndef __new__(cls, term: BoundTerm[L]) -&gt; BooleanExpression:  # type: ignore  # pylint: disable=W0221\nbound_type = term.ref().field.field_type\nif type(bound_type) in {FloatType, DoubleType}:\nreturn super().__new__(cls)\nreturn AlwaysTrue()\ndef __invert__(self) -&gt; BoundIsNaN[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundIsNaN(self.term)\n@property\ndef as_unbound(self) -&gt; Type[NotNaN]:\nreturn NotNaN\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundNotNaN.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; BoundIsNaN[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundIsNaN(self.term)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundNotNull","title":"<code>BoundNotNull</code>","text":"<p>         Bases: <code>BoundUnaryPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundNotNull(BoundUnaryPredicate[L]):\ndef __new__(cls, term: BoundTerm[L]):  # type: ignore  # pylint: disable=W0221\nif term.ref().field.required:\nreturn AlwaysTrue()\nreturn super().__new__(cls)\ndef __invert__(self) -&gt; BoundIsNull[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundIsNull(self.term)\n@property\ndef as_unbound(self) -&gt; Type[NotNull]:\nreturn NotNull\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundNotNull.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; BoundIsNull[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundIsNull(self.term)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundNotStartsWith","title":"<code>BoundNotStartsWith</code>","text":"<p>         Bases: <code>BoundLiteralPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundNotStartsWith(BoundLiteralPredicate[L]):\ndef __invert__(self) -&gt; BoundStartsWith[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundStartsWith[L](self.term, self.literal)\n@property\ndef as_unbound(self) -&gt; Type[NotStartsWith[L]]:\nreturn NotStartsWith[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundNotStartsWith.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; BoundStartsWith[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundStartsWith[L](self.term, self.literal)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundPredicate","title":"<code>BoundPredicate</code>","text":"<p>         Bases: <code>Generic[L]</code>, <code>Bound</code>, <code>BooleanExpression</code>, <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundPredicate(Generic[L], Bound, BooleanExpression, ABC):\nterm: BoundTerm[L]\ndef __init__(self, term: BoundTerm[L]):\nself.term = term\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the BoundPredicate class.\"\"\"\nif isinstance(other, BoundPredicate):\nreturn self.term == other.term\nreturn False\n@property\n@abstractmethod\ndef as_unbound(self) -&gt; Type[UnboundPredicate[Any]]:\n...\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundPredicate.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the BoundPredicate class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the BoundPredicate class.\"\"\"\nif isinstance(other, BoundPredicate):\nreturn self.term == other.term\nreturn False\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundReference","title":"<code>BoundReference</code>","text":"<p>         Bases: <code>BoundTerm[L]</code></p> <p>A reference bound to a field in a schema.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>NestedField</code> <p>A referenced field in an Iceberg schema.</p> required <code>accessor</code> <code>Accessor</code> <p>An Accessor object to access the value at the field's position.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundReference(BoundTerm[L]):\n\"\"\"A reference bound to a field in a schema.\n    Args:\n        field (NestedField): A referenced field in an Iceberg schema.\n        accessor (Accessor): An Accessor object to access the value at the field's position.\n    \"\"\"\nfield: NestedField\naccessor: Accessor\ndef __init__(self, field: NestedField, accessor: Accessor):\nself.field = field\nself.accessor = accessor\ndef eval(self, struct: StructProtocol) -&gt; L:\n\"\"\"Returns the value at the referenced field's position in an object that abides by the StructProtocol.\n        Args:\n            struct (StructProtocol): A row object that abides by the StructProtocol and returns values given a position.\n        Returns:\n            Any: The value at the referenced field's position in `struct`.\n        \"\"\"\nreturn self.accessor.get(struct)\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the BoundReference class.\"\"\"\nreturn self.field == other.field if isinstance(other, BoundReference) else False\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the BoundReference class.\"\"\"\nreturn f\"BoundReference(field={repr(self.field)}, accessor={repr(self.accessor)})\"\ndef ref(self) -&gt; BoundReference[L]:\nreturn self\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundReference.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the BoundReference class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the BoundReference class.\"\"\"\nreturn self.field == other.field if isinstance(other, BoundReference) else False\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundReference.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the BoundReference class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the BoundReference class.\"\"\"\nreturn f\"BoundReference(field={repr(self.field)}, accessor={repr(self.accessor)})\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundReference.eval","title":"<code>eval(struct)</code>","text":"<p>Returns the value at the referenced field's position in an object that abides by the StructProtocol.</p> <p>Parameters:</p> Name Type Description Default <code>struct</code> <code>StructProtocol</code> <p>A row object that abides by the StructProtocol and returns values given a position.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>L</code> <p>The value at the referenced field's position in <code>struct</code>.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def eval(self, struct: StructProtocol) -&gt; L:\n\"\"\"Returns the value at the referenced field's position in an object that abides by the StructProtocol.\n    Args:\n        struct (StructProtocol): A row object that abides by the StructProtocol and returns values given a position.\n    Returns:\n        Any: The value at the referenced field's position in `struct`.\n    \"\"\"\nreturn self.accessor.get(struct)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundSetPredicate","title":"<code>BoundSetPredicate</code>","text":"<p>         Bases: <code>BoundPredicate[L]</code>, <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundSetPredicate(BoundPredicate[L], ABC):\nliterals: Set[Literal[L]]\ndef __init__(self, term: BoundTerm[L], literals: Set[Literal[L]]):\n# Since we don't know the type of BoundPredicate[L], we have to ignore this one\nsuper().__init__(term)  # type: ignore\nself.literals = _to_literal_set(literals)  # pylint: disable=W0621\n@cached_property\ndef value_set(self) -&gt; Set[L]:\nreturn {lit.value for lit in self.literals}\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the BoundSetPredicate class.\"\"\"\n# Sort to make it deterministic\nreturn f\"{str(self.__class__.__name__)}({str(self.term)}, {{{', '.join(sorted([str(literal) for literal in self.literals]))}}})\"\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the BoundSetPredicate class.\"\"\"\n# Sort to make it deterministic\nreturn f\"{str(self.__class__.__name__)}({repr(self.term)}, {{{', '.join(sorted([repr(literal) for literal in self.literals]))}}})\"\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the BoundSetPredicate class.\"\"\"\nreturn self.term == other.term and self.literals == other.literals if isinstance(other, BoundSetPredicate) else False\ndef __getnewargs__(self) -&gt; Tuple[BoundTerm[L], Set[Literal[L]]]:\n\"\"\"A magic function for pickling the BoundSetPredicate class.\"\"\"\nreturn (self.term, self.literals)\n@property\n@abstractmethod\ndef as_unbound(self) -&gt; Type[SetPredicate[L]]:\n...\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundSetPredicate.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the BoundSetPredicate class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the BoundSetPredicate class.\"\"\"\nreturn self.term == other.term and self.literals == other.literals if isinstance(other, BoundSetPredicate) else False\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundSetPredicate.__getnewargs__","title":"<code>__getnewargs__()</code>","text":"<p>A magic function for pickling the BoundSetPredicate class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __getnewargs__(self) -&gt; Tuple[BoundTerm[L], Set[Literal[L]]]:\n\"\"\"A magic function for pickling the BoundSetPredicate class.\"\"\"\nreturn (self.term, self.literals)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundSetPredicate.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the BoundSetPredicate class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the BoundSetPredicate class.\"\"\"\n# Sort to make it deterministic\nreturn f\"{str(self.__class__.__name__)}({repr(self.term)}, {{{', '.join(sorted([repr(literal) for literal in self.literals]))}}})\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundSetPredicate.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the BoundSetPredicate class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the BoundSetPredicate class.\"\"\"\n# Sort to make it deterministic\nreturn f\"{str(self.__class__.__name__)}({str(self.term)}, {{{', '.join(sorted([str(literal) for literal in self.literals]))}}})\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundStartsWith","title":"<code>BoundStartsWith</code>","text":"<p>         Bases: <code>BoundLiteralPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundStartsWith(BoundLiteralPredicate[L]):\ndef __invert__(self) -&gt; BoundNotStartsWith[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundNotStartsWith[L](self.term, self.literal)\n@property\ndef as_unbound(self) -&gt; Type[StartsWith[L]]:\nreturn StartsWith[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundStartsWith.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; BoundNotStartsWith[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn BoundNotStartsWith[L](self.term, self.literal)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundTerm","title":"<code>BoundTerm</code>","text":"<p>         Bases: <code>Term[L]</code>, <code>Bound</code>, <code>ABC</code></p> <p>Represents a bound term.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundTerm(Term[L], Bound, ABC):\n\"\"\"Represents a bound term.\"\"\"\n@abstractmethod\ndef ref(self) -&gt; BoundReference[L]:\n\"\"\"Returns the bound reference.\"\"\"\n@abstractmethod\ndef eval(self, struct: StructProtocol) -&gt; L:  # pylint: disable=W0613\n\"\"\"Returns the value at the referenced field's position in an object that abides by the StructProtocol.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundTerm.eval","title":"<code>eval(struct)</code>  <code>abstractmethod</code>","text":"<p>Returns the value at the referenced field's position in an object that abides by the StructProtocol.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>@abstractmethod\ndef eval(self, struct: StructProtocol) -&gt; L:  # pylint: disable=W0613\n\"\"\"Returns the value at the referenced field's position in an object that abides by the StructProtocol.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundTerm.ref","title":"<code>ref()</code>  <code>abstractmethod</code>","text":"<p>Returns the bound reference.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>@abstractmethod\ndef ref(self) -&gt; BoundReference[L]:\n\"\"\"Returns the bound reference.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundUnaryPredicate","title":"<code>BoundUnaryPredicate</code>","text":"<p>         Bases: <code>BoundPredicate[L]</code>, <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class BoundUnaryPredicate(BoundPredicate[L], ABC):\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the BoundUnaryPredicate class.\"\"\"\nreturn f\"{str(self.__class__.__name__)}(term={repr(self.term)})\"\n@property\n@abstractmethod\ndef as_unbound(self) -&gt; Type[UnaryPredicate]:\n...\ndef __getnewargs__(self) -&gt; Tuple[BoundTerm[L]]:\n\"\"\"A magic function for pickling the BoundUnaryPredicate class.\"\"\"\nreturn (self.term,)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundUnaryPredicate.__getnewargs__","title":"<code>__getnewargs__()</code>","text":"<p>A magic function for pickling the BoundUnaryPredicate class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __getnewargs__(self) -&gt; Tuple[BoundTerm[L]]:\n\"\"\"A magic function for pickling the BoundUnaryPredicate class.\"\"\"\nreturn (self.term,)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.BoundUnaryPredicate.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the BoundUnaryPredicate class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the BoundUnaryPredicate class.\"\"\"\nreturn f\"{str(self.__class__.__name__)}(term={repr(self.term)})\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.EqualTo","title":"<code>EqualTo</code>","text":"<p>         Bases: <code>LiteralPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class EqualTo(LiteralPredicate[L]):\ndef __invert__(self) -&gt; NotEqualTo[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn NotEqualTo[L](self.term, self.literal)\n@property\ndef as_bound(self) -&gt; Type[BoundEqualTo[L]]:\nreturn BoundEqualTo[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.EqualTo.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; NotEqualTo[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn NotEqualTo[L](self.term, self.literal)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.GreaterThan","title":"<code>GreaterThan</code>","text":"<p>         Bases: <code>LiteralPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class GreaterThan(LiteralPredicate[L]):\ndef __invert__(self) -&gt; LessThanOrEqual[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn LessThanOrEqual[L](self.term, self.literal)\n@property\ndef as_bound(self) -&gt; Type[BoundGreaterThan[L]]:\nreturn BoundGreaterThan[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.GreaterThan.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; LessThanOrEqual[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn LessThanOrEqual[L](self.term, self.literal)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.GreaterThanOrEqual","title":"<code>GreaterThanOrEqual</code>","text":"<p>         Bases: <code>LiteralPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class GreaterThanOrEqual(LiteralPredicate[L]):\ndef __invert__(self) -&gt; LessThan[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn LessThan[L](self.term, self.literal)\n@property\ndef as_bound(self) -&gt; Type[BoundGreaterThanOrEqual[L]]:\nreturn BoundGreaterThanOrEqual[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.GreaterThanOrEqual.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; LessThan[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn LessThan[L](self.term, self.literal)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.In","title":"<code>In</code>","text":"<p>         Bases: <code>SetPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class In(SetPredicate[L]):\ndef __new__(  # type: ignore  # pylint: disable=W0221\ncls, term: Union[str, UnboundTerm[Any]], literals: Union[Iterable[L], Iterable[Literal[L]]]\n) -&gt; BooleanExpression:\nliterals_set: Set[Literal[L]] = _to_literal_set(literals)\ncount = len(literals_set)\nif count == 0:\nreturn AlwaysFalse()\nelif count == 1:\nreturn EqualTo(term, next(iter(literals)))  # type: ignore\nelse:\nreturn super().__new__(cls)\ndef __invert__(self) -&gt; NotIn[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn NotIn[L](self.term, self.literals)\n@property\ndef as_bound(self) -&gt; Type[BoundIn[L]]:\nreturn BoundIn[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.In.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; NotIn[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn NotIn[L](self.term, self.literals)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.IsNaN","title":"<code>IsNaN</code>","text":"<p>         Bases: <code>UnaryPredicate</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class IsNaN(UnaryPredicate):\ndef __invert__(self) -&gt; NotNaN:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn NotNaN(self.term)\n@property\ndef as_bound(self) -&gt; Type[BoundIsNaN[L]]:\nreturn BoundIsNaN[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.IsNaN.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; NotNaN:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn NotNaN(self.term)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.IsNull","title":"<code>IsNull</code>","text":"<p>         Bases: <code>UnaryPredicate</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class IsNull(UnaryPredicate):\ndef __invert__(self) -&gt; NotNull:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn NotNull(self.term)\n@property\ndef as_bound(self) -&gt; Type[BoundIsNull[L]]:\nreturn BoundIsNull[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.IsNull.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; NotNull:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn NotNull(self.term)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.LessThan","title":"<code>LessThan</code>","text":"<p>         Bases: <code>LiteralPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class LessThan(LiteralPredicate[L]):\ndef __invert__(self) -&gt; GreaterThanOrEqual[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn GreaterThanOrEqual[L](self.term, self.literal)\n@property\ndef as_bound(self) -&gt; Type[BoundLessThan[L]]:\nreturn BoundLessThan[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.LessThan.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; GreaterThanOrEqual[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn GreaterThanOrEqual[L](self.term, self.literal)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.LessThanOrEqual","title":"<code>LessThanOrEqual</code>","text":"<p>         Bases: <code>LiteralPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class LessThanOrEqual(LiteralPredicate[L]):\ndef __invert__(self) -&gt; GreaterThan[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn GreaterThan[L](self.term, self.literal)\n@property\ndef as_bound(self) -&gt; Type[BoundLessThanOrEqual[L]]:\nreturn BoundLessThanOrEqual[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.LessThanOrEqual.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; GreaterThan[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn GreaterThan[L](self.term, self.literal)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.LiteralPredicate","title":"<code>LiteralPredicate</code>","text":"<p>         Bases: <code>UnboundPredicate[L]</code>, <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class LiteralPredicate(UnboundPredicate[L], ABC):\nliteral: Literal[L]\ndef __init__(self, term: Union[str, UnboundTerm[Any]], literal: Union[L, Literal[L]]):  # pylint: disable=W0621\nsuper().__init__(term)\nself.literal = _to_literal(literal)  # pylint: disable=W0621\ndef bind(self, schema: Schema, case_sensitive: bool = True) -&gt; BoundLiteralPredicate[L]:\nbound_term = self.term.bind(schema, case_sensitive)\nlit = self.literal.to(bound_term.ref().field.field_type)\nif isinstance(lit, AboveMax):\nif isinstance(self, (LessThan, LessThanOrEqual, NotEqualTo)):\nreturn AlwaysTrue()  # type: ignore\nelif isinstance(self, (GreaterThan, GreaterThanOrEqual, EqualTo)):\nreturn AlwaysFalse()  # type: ignore\nelif isinstance(lit, BelowMin):\nif isinstance(self, (GreaterThan, GreaterThanOrEqual, NotEqualTo)):\nreturn AlwaysTrue()  # type: ignore\nelif isinstance(self, (LessThan, LessThanOrEqual, EqualTo)):\nreturn AlwaysFalse()  # type: ignore\nreturn self.as_bound(bound_term, lit)\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the LiteralPredicate class.\"\"\"\nif isinstance(other, LiteralPredicate):\nreturn self.term == other.term and self.literal == other.literal\nreturn False\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the LiteralPredicate class.\"\"\"\nreturn f\"{str(self.__class__.__name__)}(term={repr(self.term)}, literal={repr(self.literal)})\"\n@property\n@abstractmethod\ndef as_bound(self) -&gt; Type[BoundLiteralPredicate[L]]:\n...\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.LiteralPredicate.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the LiteralPredicate class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the LiteralPredicate class.\"\"\"\nif isinstance(other, LiteralPredicate):\nreturn self.term == other.term and self.literal == other.literal\nreturn False\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.LiteralPredicate.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the LiteralPredicate class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the LiteralPredicate class.\"\"\"\nreturn f\"{str(self.__class__.__name__)}(term={repr(self.term)}, literal={repr(self.literal)})\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.Not","title":"<code>Not</code>","text":"<p>         Bases: <code>BooleanExpression</code></p> <p>NOT operation expression - logical negation.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class Not(BooleanExpression):\n\"\"\"NOT operation expression - logical negation.\"\"\"\nchild: BooleanExpression\ndef __new__(cls, child: BooleanExpression) -&gt; BooleanExpression:  # type: ignore\nif child is AlwaysTrue():\nreturn AlwaysFalse()\nelif child is AlwaysFalse():\nreturn AlwaysTrue()\nelif isinstance(child, Not):\nreturn child.child\nobj = super().__new__(cls)\nobj.child = child\nreturn obj\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Not class.\"\"\"\nreturn f\"Not(child={repr(self.child)})\"\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the Not class.\"\"\"\nreturn self.child == other.child if isinstance(other, Not) else False\ndef __invert__(self) -&gt; BooleanExpression:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn self.child\ndef __getnewargs__(self) -&gt; Tuple[BooleanExpression]:\n\"\"\"A magic function for pickling the Not class.\"\"\"\nreturn (self.child,)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.Not.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the Not class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the Not class.\"\"\"\nreturn self.child == other.child if isinstance(other, Not) else False\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.Not.__getnewargs__","title":"<code>__getnewargs__()</code>","text":"<p>A magic function for pickling the Not class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __getnewargs__(self) -&gt; Tuple[BooleanExpression]:\n\"\"\"A magic function for pickling the Not class.\"\"\"\nreturn (self.child,)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.Not.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; BooleanExpression:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn self.child\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.Not.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the Not class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Not class.\"\"\"\nreturn f\"Not(child={repr(self.child)})\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.NotEqualTo","title":"<code>NotEqualTo</code>","text":"<p>         Bases: <code>LiteralPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class NotEqualTo(LiteralPredicate[L]):\ndef __invert__(self) -&gt; EqualTo[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn EqualTo[L](self.term, self.literal)\n@property\ndef as_bound(self) -&gt; Type[BoundNotEqualTo[L]]:\nreturn BoundNotEqualTo[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.NotEqualTo.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; EqualTo[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn EqualTo[L](self.term, self.literal)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.NotIn","title":"<code>NotIn</code>","text":"<p>         Bases: <code>SetPredicate[L]</code>, <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class NotIn(SetPredicate[L], ABC):\ndef __new__(  # type: ignore  # pylint: disable=W0221\ncls, term: Union[str, UnboundTerm[Any]], literals: Union[Iterable[L], Iterable[Literal[L]]]\n) -&gt; BooleanExpression:\nliterals_set: Set[Literal[L]] = _to_literal_set(literals)\ncount = len(literals_set)\nif count == 0:\nreturn AlwaysTrue()\nelif count == 1:\nreturn NotEqualTo(term, next(iter(literals_set)))\nelse:\nreturn super().__new__(cls)\ndef __invert__(self) -&gt; In[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn In[L](self.term, self.literals)\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the NotIn class.\"\"\"\nif isinstance(other, NotIn):\nreturn self.term == other.term and self.literals == other.literals\nreturn False\n@property\ndef as_bound(self) -&gt; Type[BoundNotIn[L]]:\nreturn BoundNotIn[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.NotIn.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the NotIn class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the NotIn class.\"\"\"\nif isinstance(other, NotIn):\nreturn self.term == other.term and self.literals == other.literals\nreturn False\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.NotIn.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; In[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn In[L](self.term, self.literals)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.NotNaN","title":"<code>NotNaN</code>","text":"<p>         Bases: <code>UnaryPredicate</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class NotNaN(UnaryPredicate):\ndef __invert__(self) -&gt; IsNaN:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn IsNaN(self.term)\n@property\ndef as_bound(self) -&gt; Type[BoundNotNaN[L]]:\nreturn BoundNotNaN[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.NotNaN.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; IsNaN:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn IsNaN(self.term)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.NotNull","title":"<code>NotNull</code>","text":"<p>         Bases: <code>UnaryPredicate</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class NotNull(UnaryPredicate):\ndef __invert__(self) -&gt; IsNull:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn IsNull(self.term)\n@property\ndef as_bound(self) -&gt; Type[BoundNotNull[L]]:\nreturn BoundNotNull[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.NotNull.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; IsNull:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn IsNull(self.term)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.NotStartsWith","title":"<code>NotStartsWith</code>","text":"<p>         Bases: <code>LiteralPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class NotStartsWith(LiteralPredicate[L]):\ndef __invert__(self) -&gt; NotStartsWith[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn NotStartsWith[L](self.term, self.literal)\n@property\ndef as_bound(self) -&gt; Type[BoundNotStartsWith[L]]:\nreturn BoundNotStartsWith[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.NotStartsWith.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; NotStartsWith[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn NotStartsWith[L](self.term, self.literal)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.Or","title":"<code>Or</code>","text":"<p>         Bases: <code>BooleanExpression</code></p> <p>OR operation expression - logical disjunction.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class Or(BooleanExpression):\n\"\"\"OR operation expression - logical disjunction.\"\"\"\nleft: BooleanExpression\nright: BooleanExpression\ndef __new__(cls, left: BooleanExpression, right: BooleanExpression, *rest: BooleanExpression) -&gt; BooleanExpression:  # type: ignore\nif rest:\nreturn reduce(Or, (left, right, *rest))\nif left is AlwaysTrue() or right is AlwaysTrue():\nreturn AlwaysTrue()\nelif left is AlwaysFalse():\nreturn right\nelif right is AlwaysFalse():\nreturn left\nelse:\nobj = super().__new__(cls)\nobj.left = left\nobj.right = right\nreturn obj\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the Or class.\"\"\"\nreturn self.left == other.left and self.right == other.right if isinstance(other, Or) else False\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Or class.\"\"\"\nreturn f\"Or(left={repr(self.left)}, right={repr(self.right)})\"\ndef __invert__(self) -&gt; BooleanExpression:\n\"\"\"Transform the Expression into its negated version.\"\"\"\n# De Morgan's law: not (A or B) = (not A) and (not B)\nreturn And(~self.left, ~self.right)\ndef __getnewargs__(self) -&gt; Tuple[BooleanExpression, BooleanExpression]:\n\"\"\"A magic function for pickling the Or class.\"\"\"\nreturn (self.left, self.right)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.Or.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the Or class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the Or class.\"\"\"\nreturn self.left == other.left and self.right == other.right if isinstance(other, Or) else False\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.Or.__getnewargs__","title":"<code>__getnewargs__()</code>","text":"<p>A magic function for pickling the Or class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __getnewargs__(self) -&gt; Tuple[BooleanExpression, BooleanExpression]:\n\"\"\"A magic function for pickling the Or class.\"\"\"\nreturn (self.left, self.right)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.Or.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; BooleanExpression:\n\"\"\"Transform the Expression into its negated version.\"\"\"\n# De Morgan's law: not (A or B) = (not A) and (not B)\nreturn And(~self.left, ~self.right)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.Or.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the Or class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Or class.\"\"\"\nreturn f\"Or(left={repr(self.left)}, right={repr(self.right)})\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.Reference","title":"<code>Reference</code>","text":"<p>         Bases: <code>UnboundTerm[Any]</code></p> <p>A reference not yet bound to a field in a schema.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the field.</p> required Note <p>An unbound reference is sometimes referred to as a \"named\" reference.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class Reference(UnboundTerm[Any]):\n\"\"\"A reference not yet bound to a field in a schema.\n    Args:\n        name (str): The name of the field.\n    Note:\n        An unbound reference is sometimes referred to as a \"named\" reference.\n    \"\"\"\nname: str\ndef __init__(self, name: str) -&gt; None:\nself.name = name\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Reference class.\"\"\"\nreturn f\"Reference(name={repr(self.name)})\"\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the Reference class.\"\"\"\nreturn self.name == other.name if isinstance(other, Reference) else False\ndef bind(self, schema: Schema, case_sensitive: bool = True) -&gt; BoundReference[L]:\n\"\"\"Bind the reference to an Iceberg schema.\n        Args:\n            schema (Schema): An Iceberg schema.\n            case_sensitive (bool): Whether to consider case when binding the reference to the field.\n        Raises:\n            ValueError: If an empty name is provided.\n        Returns:\n            BoundReference: A reference bound to the specific field in the Iceberg schema.\n        \"\"\"\nfield = schema.find_field(name_or_id=self.name, case_sensitive=case_sensitive)\naccessor = schema.accessor_for_field(field.field_id)\nreturn self.as_bound(field=field, accessor=accessor)  # type: ignore\n@property\ndef as_bound(self) -&gt; Type[BoundReference[L]]:\nreturn BoundReference[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.Reference.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the Reference class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the Reference class.\"\"\"\nreturn self.name == other.name if isinstance(other, Reference) else False\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.Reference.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the Reference class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Reference class.\"\"\"\nreturn f\"Reference(name={repr(self.name)})\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.Reference.bind","title":"<code>bind(schema, case_sensitive=True)</code>","text":"<p>Bind the reference to an Iceberg schema.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Schema</code> <p>An Iceberg schema.</p> required <code>case_sensitive</code> <code>bool</code> <p>Whether to consider case when binding the reference to the field.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an empty name is provided.</p> <p>Returns:</p> Name Type Description <code>BoundReference</code> <code>BoundReference[L]</code> <p>A reference bound to the specific field in the Iceberg schema.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def bind(self, schema: Schema, case_sensitive: bool = True) -&gt; BoundReference[L]:\n\"\"\"Bind the reference to an Iceberg schema.\n    Args:\n        schema (Schema): An Iceberg schema.\n        case_sensitive (bool): Whether to consider case when binding the reference to the field.\n    Raises:\n        ValueError: If an empty name is provided.\n    Returns:\n        BoundReference: A reference bound to the specific field in the Iceberg schema.\n    \"\"\"\nfield = schema.find_field(name_or_id=self.name, case_sensitive=case_sensitive)\naccessor = schema.accessor_for_field(field.field_id)\nreturn self.as_bound(field=field, accessor=accessor)  # type: ignore\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.SetPredicate","title":"<code>SetPredicate</code>","text":"<p>         Bases: <code>UnboundPredicate[L]</code>, <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class SetPredicate(UnboundPredicate[L], ABC):\nliterals: Set[Literal[L]]\ndef __init__(self, term: Union[str, UnboundTerm[Any]], literals: Union[Iterable[L], Iterable[Literal[L]]]):\nsuper().__init__(term)\nself.literals = _to_literal_set(literals)\ndef bind(self, schema: Schema, case_sensitive: bool = True) -&gt; BoundSetPredicate[L]:\nbound_term = self.term.bind(schema, case_sensitive)\nreturn self.as_bound(bound_term, {lit.to(bound_term.ref().field.field_type) for lit in self.literals})\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the SetPredicate class.\"\"\"\n# Sort to make it deterministic\nreturn f\"{str(self.__class__.__name__)}({str(self.term)}, {{{', '.join(sorted([str(literal) for literal in self.literals]))}}})\"\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the SetPredicate class.\"\"\"\n# Sort to make it deterministic\nreturn f\"{str(self.__class__.__name__)}({repr(self.term)}, {{{', '.join(sorted([repr(literal) for literal in self.literals]))}}})\"\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the SetPredicate class.\"\"\"\nreturn self.term == other.term and self.literals == other.literals if isinstance(other, SetPredicate) else False\ndef __getnewargs__(self) -&gt; Tuple[UnboundTerm[L], Set[Literal[L]]]:\n\"\"\"A magic function for pickling the SetPredicate class.\"\"\"\nreturn (self.term, self.literals)\n@property\n@abstractmethod\ndef as_bound(self) -&gt; Type[BoundSetPredicate[L]]:\nreturn BoundSetPredicate[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.SetPredicate.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the SetPredicate class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the SetPredicate class.\"\"\"\nreturn self.term == other.term and self.literals == other.literals if isinstance(other, SetPredicate) else False\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.SetPredicate.__getnewargs__","title":"<code>__getnewargs__()</code>","text":"<p>A magic function for pickling the SetPredicate class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __getnewargs__(self) -&gt; Tuple[UnboundTerm[L], Set[Literal[L]]]:\n\"\"\"A magic function for pickling the SetPredicate class.\"\"\"\nreturn (self.term, self.literals)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.SetPredicate.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the SetPredicate class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the SetPredicate class.\"\"\"\n# Sort to make it deterministic\nreturn f\"{str(self.__class__.__name__)}({repr(self.term)}, {{{', '.join(sorted([repr(literal) for literal in self.literals]))}}})\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.SetPredicate.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the SetPredicate class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the SetPredicate class.\"\"\"\n# Sort to make it deterministic\nreturn f\"{str(self.__class__.__name__)}({str(self.term)}, {{{', '.join(sorted([str(literal) for literal in self.literals]))}}})\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.StartsWith","title":"<code>StartsWith</code>","text":"<p>         Bases: <code>LiteralPredicate[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class StartsWith(LiteralPredicate[L]):\ndef __invert__(self) -&gt; NotStartsWith[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn NotStartsWith[L](self.term, self.literal)\n@property\ndef as_bound(self) -&gt; Type[BoundStartsWith[L]]:\nreturn BoundStartsWith[L]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.StartsWith.__invert__","title":"<code>__invert__()</code>","text":"<p>Transform the Expression into its negated version.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __invert__(self) -&gt; NotStartsWith[L]:\n\"\"\"Transform the Expression into its negated version.\"\"\"\nreturn NotStartsWith[L](self.term, self.literal)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.Term","title":"<code>Term</code>","text":"<p>         Bases: <code>Generic[L]</code>, <code>ABC</code></p> <p>A simple expression that evaluates to a value.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class Term(Generic[L], ABC):\n\"\"\"A simple expression that evaluates to a value.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.UnaryPredicate","title":"<code>UnaryPredicate</code>","text":"<p>         Bases: <code>UnboundPredicate[Any]</code>, <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class UnaryPredicate(UnboundPredicate[Any], ABC):\ndef bind(self, schema: Schema, case_sensitive: bool = True) -&gt; BoundUnaryPredicate[Any]:\nbound_term = self.term.bind(schema, case_sensitive)\nreturn self.as_bound(bound_term)\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the UnaryPredicate class.\"\"\"\nreturn f\"{str(self.__class__.__name__)}(term={repr(self.term)})\"\n@property\n@abstractmethod\ndef as_bound(self) -&gt; Type[BoundUnaryPredicate[Any]]:\n...\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.UnaryPredicate.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the UnaryPredicate class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the UnaryPredicate class.\"\"\"\nreturn f\"{str(self.__class__.__name__)}(term={repr(self.term)})\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.Unbound","title":"<code>Unbound</code>","text":"<p>         Bases: <code>Generic[B]</code>, <code>ABC</code></p> <p>Represents an unbound value expression.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class Unbound(Generic[B], ABC):\n\"\"\"Represents an unbound value expression.\"\"\"\n@abstractmethod\ndef bind(self, schema: Schema, case_sensitive: bool = True) -&gt; B:\n...\n@property\n@abstractmethod\ndef as_bound(self) -&gt; Type[Bound]:\n...\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.UnboundPredicate","title":"<code>UnboundPredicate</code>","text":"<p>         Bases: <code>Generic[L]</code>, <code>Unbound[BooleanExpression]</code>, <code>BooleanExpression</code>, <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class UnboundPredicate(Generic[L], Unbound[BooleanExpression], BooleanExpression, ABC):\nterm: UnboundTerm[Any]\ndef __init__(self, term: Union[str, UnboundTerm[Any]]):\nself.term = _to_unbound_term(term)\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the UnboundPredicate class.\"\"\"\nreturn self.term == other.term if isinstance(other, UnboundPredicate) else False\n@abstractmethod\ndef bind(self, schema: Schema, case_sensitive: bool = True) -&gt; BooleanExpression:\n...\n@property\n@abstractmethod\ndef as_bound(self) -&gt; Type[BoundPredicate[L]]:\n...\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.UnboundPredicate.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the UnboundPredicate class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the UnboundPredicate class.\"\"\"\nreturn self.term == other.term if isinstance(other, UnboundPredicate) else False\n</code></pre>"},{"location":"reference/pyiceberg/expressions/#pyiceberg.expressions.UnboundTerm","title":"<code>UnboundTerm</code>","text":"<p>         Bases: <code>Term[Any]</code>, <code>Unbound[BoundTerm[L]]</code>, <code>ABC</code></p> <p>Represents an unbound term.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/__init__.py</code> <pre><code>class UnboundTerm(Term[Any], Unbound[BoundTerm[L]], ABC):\n\"\"\"Represents an unbound term.\"\"\"\n@abstractmethod\ndef bind(self, schema: Schema, case_sensitive: bool = True) -&gt; BoundTerm[L]:\n...\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/","title":"literals","text":""},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.AboveMax","title":"<code>AboveMax</code>","text":"<p>         Bases: <code>Literal[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>class AboveMax(Literal[L]):\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the AboveMax class.\"\"\"\nreturn f\"{self.__class__.__name__}()\"\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the AboveMax class.\"\"\"\nreturn self.__class__.__name__\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.AboveMax.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the AboveMax class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the AboveMax class.\"\"\"\nreturn f\"{self.__class__.__name__}()\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.AboveMax.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the AboveMax class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the AboveMax class.\"\"\"\nreturn self.__class__.__name__\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.BelowMin","title":"<code>BelowMin</code>","text":"<p>         Bases: <code>Literal[L]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>class BelowMin(Literal[L]):\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the BelowMin class.\"\"\"\nreturn f\"{self.__class__.__name__}()\"\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the BelowMin class.\"\"\"\nreturn self.__class__.__name__\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.BelowMin.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the BelowMin class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the BelowMin class.\"\"\"\nreturn f\"{self.__class__.__name__}()\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.BelowMin.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the BelowMin class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the BelowMin class.\"\"\"\nreturn self.__class__.__name__\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.FloatLiteral","title":"<code>FloatLiteral</code>","text":"<p>         Bases: <code>Literal[float]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>class FloatLiteral(Literal[float]):\ndef __init__(self, value: float) -&gt; None:\nsuper().__init__(value, float)\nself._value32 = struct.unpack(\"&lt;f\", struct.pack(\"&lt;f\", value))[0]\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the FloatLiteral class.\"\"\"\nreturn self._value32 == other\ndef __lt__(self, other: Any) -&gt; bool:\n\"\"\"Returns if one instance of the FloatLiteral class is less than another instance.\"\"\"\nreturn self._value32 &lt; other\ndef __gt__(self, other: Any) -&gt; bool:\n\"\"\"Returns if one instance of the FloatLiteral class is greater than another instance.\"\"\"\nreturn self._value32 &gt; other\ndef __le__(self, other: Any) -&gt; bool:\n\"\"\"Returns if one instance of the FloatLiteral class is less than or equal to another instance.\"\"\"\nreturn self._value32 &lt;= other\ndef __ge__(self, other: Any) -&gt; bool:\n\"\"\"Returns if one instance of the FloatLiteral class is greater than or equal to another instance.\"\"\"\nreturn self._value32 &gt;= other\ndef __hash__(self) -&gt; int:\n\"\"\"Returns a hashed representation of the FloatLiteral class.\"\"\"\nreturn hash(self._value32)\n@singledispatchmethod\ndef to(self, type_var: IcebergType) -&gt; Literal:  # type: ignore\nraise TypeError(f\"Cannot convert FloatLiteral into {type_var}\")\n@to.register(FloatType)\ndef _(self, _: FloatType) -&gt; Literal[float]:\nreturn self\n@to.register(DoubleType)\ndef _(self, _: DoubleType) -&gt; Literal[float]:\nreturn DoubleLiteral(self.value)\n@to.register(DecimalType)\ndef _(self, type_var: DecimalType) -&gt; Literal[Decimal]:\nreturn DecimalLiteral(Decimal(self.value).quantize(Decimal((0, (1,), -type_var.scale)), rounding=ROUND_HALF_UP))\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.FloatLiteral.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the FloatLiteral class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the FloatLiteral class.\"\"\"\nreturn self._value32 == other\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.FloatLiteral.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Returns if one instance of the FloatLiteral class is greater than or equal to another instance.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __ge__(self, other: Any) -&gt; bool:\n\"\"\"Returns if one instance of the FloatLiteral class is greater than or equal to another instance.\"\"\"\nreturn self._value32 &gt;= other\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.FloatLiteral.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Returns if one instance of the FloatLiteral class is greater than another instance.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __gt__(self, other: Any) -&gt; bool:\n\"\"\"Returns if one instance of the FloatLiteral class is greater than another instance.\"\"\"\nreturn self._value32 &gt; other\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.FloatLiteral.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns a hashed representation of the FloatLiteral class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __hash__(self) -&gt; int:\n\"\"\"Returns a hashed representation of the FloatLiteral class.\"\"\"\nreturn hash(self._value32)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.FloatLiteral.__le__","title":"<code>__le__(other)</code>","text":"<p>Returns if one instance of the FloatLiteral class is less than or equal to another instance.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __le__(self, other: Any) -&gt; bool:\n\"\"\"Returns if one instance of the FloatLiteral class is less than or equal to another instance.\"\"\"\nreturn self._value32 &lt;= other\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.FloatLiteral.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Returns if one instance of the FloatLiteral class is less than another instance.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __lt__(self, other: Any) -&gt; bool:\n\"\"\"Returns if one instance of the FloatLiteral class is less than another instance.\"\"\"\nreturn self._value32 &lt; other\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.Literal","title":"<code>Literal</code>","text":"<p>         Bases: <code>Generic[L]</code>, <code>ABC</code></p> <p>Literal which has a value and can be converted between types.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>class Literal(Generic[L], ABC):\n\"\"\"Literal which has a value and can be converted between types.\"\"\"\n_value: L\ndef __init__(self, value: L, value_type: Type[L]):\nif value is None or not isinstance(value, value_type):\nraise TypeError(f\"Invalid literal value: {value!r} (not a {value_type})\")\nif isinstance(value, float) and isnan(value):\nraise ValueError(\"Cannot create expression literal from NaN.\")\nself._value = value\n@property\ndef value(self) -&gt; L:\nreturn self._value\n@singledispatchmethod\n@abstractmethod\ndef to(self, type_var: IcebergType) -&gt; Literal[L]:\n...  # pragma: no cover\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Literal class.\"\"\"\nreturn f\"{type(self).__name__}({self.value!r})\"\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the Literal class.\"\"\"\nreturn str(self.value)\ndef __hash__(self) -&gt; int:\n\"\"\"Returns a hashed representation of the Literal class.\"\"\"\nreturn hash(self.value)\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the Literal class.\"\"\"\nif not isinstance(other, Literal):\nreturn False\nreturn self.value == other.value\ndef __ne__(self, other: Any) -&gt; bool:\n\"\"\"Returns the inequality of two instances of the Literal class.\"\"\"\nreturn not self.__eq__(other)\ndef __lt__(self, other: Any) -&gt; bool:\n\"\"\"Returns if one instance of the Literal class is less than another instance.\"\"\"\nreturn self.value &lt; other.value\ndef __gt__(self, other: Any) -&gt; bool:\n\"\"\"Returns if one instance of the Literal class is greater than another instance.\"\"\"\nreturn self.value &gt; other.value\ndef __le__(self, other: Any) -&gt; bool:\n\"\"\"Returns if one instance of the Literal class is less than or equal to another instance.\"\"\"\nreturn self.value &lt;= other.value\ndef __ge__(self, other: Any) -&gt; bool:\n\"\"\"Returns if one instance of the Literal class is greater than or equal to another instance.\"\"\"\nreturn self.value &gt;= other.value\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.Literal.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the Literal class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the Literal class.\"\"\"\nif not isinstance(other, Literal):\nreturn False\nreturn self.value == other.value\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.Literal.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Returns if one instance of the Literal class is greater than or equal to another instance.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __ge__(self, other: Any) -&gt; bool:\n\"\"\"Returns if one instance of the Literal class is greater than or equal to another instance.\"\"\"\nreturn self.value &gt;= other.value\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.Literal.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Returns if one instance of the Literal class is greater than another instance.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __gt__(self, other: Any) -&gt; bool:\n\"\"\"Returns if one instance of the Literal class is greater than another instance.\"\"\"\nreturn self.value &gt; other.value\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.Literal.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns a hashed representation of the Literal class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __hash__(self) -&gt; int:\n\"\"\"Returns a hashed representation of the Literal class.\"\"\"\nreturn hash(self.value)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.Literal.__le__","title":"<code>__le__(other)</code>","text":"<p>Returns if one instance of the Literal class is less than or equal to another instance.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __le__(self, other: Any) -&gt; bool:\n\"\"\"Returns if one instance of the Literal class is less than or equal to another instance.\"\"\"\nreturn self.value &lt;= other.value\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.Literal.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Returns if one instance of the Literal class is less than another instance.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __lt__(self, other: Any) -&gt; bool:\n\"\"\"Returns if one instance of the Literal class is less than another instance.\"\"\"\nreturn self.value &lt; other.value\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.Literal.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Returns the inequality of two instances of the Literal class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __ne__(self, other: Any) -&gt; bool:\n\"\"\"Returns the inequality of two instances of the Literal class.\"\"\"\nreturn not self.__eq__(other)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.Literal.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the Literal class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Literal class.\"\"\"\nreturn f\"{type(self).__name__}({self.value!r})\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.Literal.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the Literal class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the Literal class.\"\"\"\nreturn str(self.value)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.StringLiteral","title":"<code>StringLiteral</code>","text":"<p>         Bases: <code>Literal[str]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>class StringLiteral(Literal[str]):\ndef __init__(self, value: str) -&gt; None:\nsuper().__init__(value, str)\n@singledispatchmethod\ndef to(self, type_var: IcebergType) -&gt; Literal:  # type: ignore\nraise TypeError(f\"Cannot convert StringLiteral into {type_var}\")\n@to.register(StringType)\ndef _(self, _: StringType) -&gt; Literal[str]:\nreturn self\n@to.register(IntegerType)\ndef _(self, type_var: IntegerType) -&gt; Literal[int]:\ntry:\nnumber = int(float(self.value))\nif IntegerType.max &lt; number:\nreturn IntAboveMax()\nelif IntegerType.min &gt; number:\nreturn IntBelowMin()\nreturn LongLiteral(number)\nexcept ValueError as e:\nraise ValueError(f\"Could not convert {self.value} into a {type_var}\") from e\n@to.register(LongType)\ndef _(self, type_var: LongType) -&gt; Literal[int]:\ntry:\nlong_value = int(float(self.value))\nif LongType.max &lt; long_value:\nreturn LongAboveMax()\nelif LongType.min &gt; long_value:\nreturn LongBelowMin()\nelse:\nreturn LongLiteral(long_value)\nexcept (TypeError, ValueError) as e:\nraise ValueError(f\"Could not convert {self.value} into a {type_var}\") from e\n@to.register(DateType)\ndef _(self, type_var: DateType) -&gt; Literal[int]:\ntry:\nreturn DateLiteral(date_str_to_days(self.value))\nexcept (TypeError, ValueError) as e:\nraise ValueError(f\"Could not convert {self.value} into a {type_var}\") from e\n@to.register(TimeType)\ndef _(self, type_var: TimeType) -&gt; Literal[int]:\ntry:\nreturn TimeLiteral(time_to_micros(self.value))\nexcept (TypeError, ValueError) as e:\nraise ValueError(f\"Could not convert {self.value} into a {type_var}\") from e\n@to.register(TimestampType)\ndef _(self, _: TimestampType) -&gt; Literal[int]:\nreturn TimestampLiteral(timestamp_to_micros(self.value))\n@to.register(TimestamptzType)\ndef _(self, _: TimestamptzType) -&gt; Literal[int]:\nreturn TimestampLiteral(timestamptz_to_micros(self.value))\n@to.register(UUIDType)\ndef _(self, _: UUIDType) -&gt; Literal[UUID]:\nreturn UUIDLiteral(UUID(self.value))\n@to.register(DecimalType)\ndef _(self, type_var: DecimalType) -&gt; Literal[Decimal]:\ndec = Decimal(self.value)\nscale = abs(int(dec.as_tuple().exponent))\nif type_var.scale == scale:\nreturn DecimalLiteral(dec)\nelse:\nraise ValueError(f\"Could not convert {self.value} into a {type_var}, scales differ {type_var.scale} &lt;&gt; {scale}\")\n@to.register(BooleanType)\ndef _(self, type_var: BooleanType) -&gt; Literal[bool]:\nvalue_upper = self.value.upper()\nif value_upper in [\"TRUE\", \"FALSE\"]:\nreturn BooleanLiteral(value_upper == \"TRUE\")\nelse:\nraise ValueError(f\"Could not convert {self.value} into a {type_var}\")\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the StringLiteral class.\"\"\"\nreturn f\"literal({repr(self.value)})\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.StringLiteral.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the StringLiteral class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the StringLiteral class.\"\"\"\nreturn f\"literal({repr(self.value)})\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/literals/#pyiceberg.expressions.literals.literal","title":"<code>literal(value)</code>","text":"<p>A generic Literal factory to construct an Iceberg Literal based on Python primitive data type.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Python primitive type</code> <p>the value to be associated with literal.</p> required Example <p>from pyiceberg.expressions.literals import literal.</p> <p>literal(123) LongLiteral(123)</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/literals.py</code> <pre><code>def literal(value: L) -&gt; Literal[L]:\n\"\"\"\n    A generic Literal factory to construct an Iceberg Literal based on Python primitive data type.\n    Args:\n        value (Python primitive type): the value to be associated with literal.\n    Example:\n        from pyiceberg.expressions.literals import literal.\n        &gt;&gt;&gt; literal(123)\n        LongLiteral(123)\n    \"\"\"\nif isinstance(value, float):\nreturn DoubleLiteral(value)  # type: ignore\nelif isinstance(value, bool):\nreturn BooleanLiteral(value)\nelif isinstance(value, int):\nreturn LongLiteral(value)\nelif isinstance(value, str):\nreturn StringLiteral(value)\nelif isinstance(value, UUID):\nreturn UUIDLiteral(value)\nelif isinstance(value, bytes):\nreturn BinaryLiteral(value)\nelif isinstance(value, Decimal):\nreturn DecimalLiteral(value)\nelse:\nraise TypeError(f\"Invalid literal value: {repr(value)}\")\n</code></pre>"},{"location":"reference/pyiceberg/expressions/parser/","title":"parser","text":""},{"location":"reference/pyiceberg/expressions/parser/#pyiceberg.expressions.parser.parse","title":"<code>parse(expr)</code>","text":"<p>Parses a boolean expression.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/parser.py</code> <pre><code>def parse(expr: str) -&gt; BooleanExpression:\n\"\"\"Parses a boolean expression.\"\"\"\nreturn boolean_expression.parse_string(expr)[0]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/","title":"visitors","text":""},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BindVisitor","title":"<code>BindVisitor</code>","text":"<p>         Bases: <code>BooleanExpressionVisitor[BooleanExpression]</code></p> <p>Rewrites a boolean expression by replacing unbound references with references to fields in a struct schema.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Schema</code> <p>A schema to use when binding the expression.</p> required <code>case_sensitive</code> <code>bool</code> <p>Whether to consider case when binding a reference to a field in a schema, defaults to True.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>In the case a predicate is already bound.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>class BindVisitor(BooleanExpressionVisitor[BooleanExpression]):\n\"\"\"Rewrites a boolean expression by replacing unbound references with references to fields in a struct schema.\n    Args:\n      schema (Schema): A schema to use when binding the expression.\n      case_sensitive (bool): Whether to consider case when binding a reference to a field in a schema, defaults to True.\n    Raises:\n        TypeError: In the case a predicate is already bound.\n    \"\"\"\nschema: Schema\ncase_sensitive: bool\ndef __init__(self, schema: Schema, case_sensitive: bool) -&gt; None:\nself.schema = schema\nself.case_sensitive = case_sensitive\ndef visit_true(self) -&gt; BooleanExpression:\nreturn AlwaysTrue()\ndef visit_false(self) -&gt; BooleanExpression:\nreturn AlwaysFalse()\ndef visit_not(self, child_result: BooleanExpression) -&gt; BooleanExpression:\nreturn Not(child=child_result)\ndef visit_and(self, left_result: BooleanExpression, right_result: BooleanExpression) -&gt; BooleanExpression:\nreturn And(left=left_result, right=right_result)\ndef visit_or(self, left_result: BooleanExpression, right_result: BooleanExpression) -&gt; BooleanExpression:\nreturn Or(left=left_result, right=right_result)\ndef visit_unbound_predicate(self, predicate: UnboundPredicate[L]) -&gt; BooleanExpression:\nreturn predicate.bind(self.schema, case_sensitive=self.case_sensitive)\ndef visit_bound_predicate(self, predicate: BoundPredicate[L]) -&gt; BooleanExpression:\nraise TypeError(f\"Found already bound predicate: {predicate}\")\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BooleanExpressionVisitor","title":"<code>BooleanExpressionVisitor</code>","text":"<p>         Bases: <code>Generic[T]</code>, <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>class BooleanExpressionVisitor(Generic[T], ABC):\n@abstractmethod\ndef visit_true(self) -&gt; T:\n\"\"\"Visit method for an AlwaysTrue boolean expression.\n        Note: This visit method has no arguments since AlwaysTrue instances have no context.\n        \"\"\"\n@abstractmethod\ndef visit_false(self) -&gt; T:\n\"\"\"Visit method for an AlwaysFalse boolean expression.\n        Note: This visit method has no arguments since AlwaysFalse instances have no context.\n        \"\"\"\n@abstractmethod\ndef visit_not(self, child_result: T) -&gt; T:\n\"\"\"Visit method for a Not boolean expression.\n        Args:\n            child_result (T): The result of visiting the child of the Not boolean expression.\n        \"\"\"\n@abstractmethod\ndef visit_and(self, left_result: T, right_result: T) -&gt; T:\n\"\"\"Visit method for an And boolean expression.\n        Args:\n            left_result (T): The result of visiting the left side of the expression.\n            right_result (T): The result of visiting the right side of the expression.\n        \"\"\"\n@abstractmethod\ndef visit_or(self, left_result: T, right_result: T) -&gt; T:\n\"\"\"Visit method for an Or boolean expression.\n        Args:\n            left_result (T): The result of visiting the left side of the expression.\n            right_result (T): The result of visiting the right side of the expression.\n        \"\"\"\n@abstractmethod\ndef visit_unbound_predicate(self, predicate: UnboundPredicate[L]) -&gt; T:\n\"\"\"Visit method for an unbound predicate in an expression tree.\n        Args:\n            predicate (UnboundPredicate[L): An instance of an UnboundPredicate.\n        \"\"\"\n@abstractmethod\ndef visit_bound_predicate(self, predicate: BoundPredicate[L]) -&gt; T:\n\"\"\"Visit method for a bound predicate in an expression tree.\n        Args:\n            predicate (BoundPredicate[L]): An instance of a BoundPredicate.\n        \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BooleanExpressionVisitor.visit_and","title":"<code>visit_and(left_result, right_result)</code>  <code>abstractmethod</code>","text":"<p>Visit method for an And boolean expression.</p> <p>Parameters:</p> Name Type Description Default <code>left_result</code> <code>T</code> <p>The result of visiting the left side of the expression.</p> required <code>right_result</code> <code>T</code> <p>The result of visiting the right side of the expression.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_and(self, left_result: T, right_result: T) -&gt; T:\n\"\"\"Visit method for an And boolean expression.\n    Args:\n        left_result (T): The result of visiting the left side of the expression.\n        right_result (T): The result of visiting the right side of the expression.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BooleanExpressionVisitor.visit_bound_predicate","title":"<code>visit_bound_predicate(predicate)</code>  <code>abstractmethod</code>","text":"<p>Visit method for a bound predicate in an expression tree.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>BoundPredicate[L]</code> <p>An instance of a BoundPredicate.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_bound_predicate(self, predicate: BoundPredicate[L]) -&gt; T:\n\"\"\"Visit method for a bound predicate in an expression tree.\n    Args:\n        predicate (BoundPredicate[L]): An instance of a BoundPredicate.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BooleanExpressionVisitor.visit_false","title":"<code>visit_false()</code>  <code>abstractmethod</code>","text":"<p>Visit method for an AlwaysFalse boolean expression.</p> <p>Note: This visit method has no arguments since AlwaysFalse instances have no context.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_false(self) -&gt; T:\n\"\"\"Visit method for an AlwaysFalse boolean expression.\n    Note: This visit method has no arguments since AlwaysFalse instances have no context.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BooleanExpressionVisitor.visit_not","title":"<code>visit_not(child_result)</code>  <code>abstractmethod</code>","text":"<p>Visit method for a Not boolean expression.</p> <p>Parameters:</p> Name Type Description Default <code>child_result</code> <code>T</code> <p>The result of visiting the child of the Not boolean expression.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_not(self, child_result: T) -&gt; T:\n\"\"\"Visit method for a Not boolean expression.\n    Args:\n        child_result (T): The result of visiting the child of the Not boolean expression.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BooleanExpressionVisitor.visit_or","title":"<code>visit_or(left_result, right_result)</code>  <code>abstractmethod</code>","text":"<p>Visit method for an Or boolean expression.</p> <p>Parameters:</p> Name Type Description Default <code>left_result</code> <code>T</code> <p>The result of visiting the left side of the expression.</p> required <code>right_result</code> <code>T</code> <p>The result of visiting the right side of the expression.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_or(self, left_result: T, right_result: T) -&gt; T:\n\"\"\"Visit method for an Or boolean expression.\n    Args:\n        left_result (T): The result of visiting the left side of the expression.\n        right_result (T): The result of visiting the right side of the expression.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BooleanExpressionVisitor.visit_true","title":"<code>visit_true()</code>  <code>abstractmethod</code>","text":"<p>Visit method for an AlwaysTrue boolean expression.</p> <p>Note: This visit method has no arguments since AlwaysTrue instances have no context.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_true(self) -&gt; T:\n\"\"\"Visit method for an AlwaysTrue boolean expression.\n    Note: This visit method has no arguments since AlwaysTrue instances have no context.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BooleanExpressionVisitor.visit_unbound_predicate","title":"<code>visit_unbound_predicate(predicate)</code>  <code>abstractmethod</code>","text":"<p>Visit method for an unbound predicate in an expression tree.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>UnboundPredicate[L</code> <p>An instance of an UnboundPredicate.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_unbound_predicate(self, predicate: UnboundPredicate[L]) -&gt; T:\n\"\"\"Visit method for an unbound predicate in an expression tree.\n    Args:\n        predicate (UnboundPredicate[L): An instance of an UnboundPredicate.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor","title":"<code>BoundBooleanExpressionVisitor</code>","text":"<p>         Bases: <code>BooleanExpressionVisitor[T]</code>, <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>class BoundBooleanExpressionVisitor(BooleanExpressionVisitor[T], ABC):\n@abstractmethod\ndef visit_in(self, term: BoundTerm[L], literals: Set[L]) -&gt; T:\n\"\"\"Visit a bound In predicate.\"\"\"\n@abstractmethod\ndef visit_not_in(self, term: BoundTerm[L], literals: Set[L]) -&gt; T:\n\"\"\"Visit a bound NotIn predicate.\"\"\"\n@abstractmethod\ndef visit_is_nan(self, term: BoundTerm[L]) -&gt; T:\n\"\"\"Visit a bound IsNan predicate.\"\"\"\n@abstractmethod\ndef visit_not_nan(self, term: BoundTerm[L]) -&gt; T:\n\"\"\"Visit a bound NotNan predicate.\"\"\"\n@abstractmethod\ndef visit_is_null(self, term: BoundTerm[L]) -&gt; T:\n\"\"\"Visit a bound IsNull predicate.\"\"\"\n@abstractmethod\ndef visit_not_null(self, term: BoundTerm[L]) -&gt; T:\n\"\"\"Visit a bound NotNull predicate.\"\"\"\n@abstractmethod\ndef visit_equal(self, term: BoundTerm[L], literal: Literal[L]) -&gt; T:\n\"\"\"Visit a bound Equal predicate.\"\"\"\n@abstractmethod\ndef visit_not_equal(self, term: BoundTerm[L], literal: Literal[L]) -&gt; T:\n\"\"\"Visit a bound NotEqual predicate.\"\"\"\n@abstractmethod\ndef visit_greater_than_or_equal(self, term: BoundTerm[L], literal: Literal[L]) -&gt; T:\n\"\"\"Visit a bound GreaterThanOrEqual predicate.\"\"\"\n@abstractmethod\ndef visit_greater_than(self, term: BoundTerm[L], literal: Literal[L]) -&gt; T:\n\"\"\"Visit a bound GreaterThan predicate.\"\"\"\n@abstractmethod\ndef visit_less_than(self, term: BoundTerm[L], literal: Literal[L]) -&gt; T:\n\"\"\"Visit a bound LessThan predicate.\"\"\"\n@abstractmethod\ndef visit_less_than_or_equal(self, term: BoundTerm[L], literal: Literal[L]) -&gt; T:\n\"\"\"Visit a bound LessThanOrEqual predicate.\"\"\"\n@abstractmethod\ndef visit_true(self) -&gt; T:\n\"\"\"Visit a bound True predicate.\"\"\"\n@abstractmethod\ndef visit_false(self) -&gt; T:\n\"\"\"Visit a bound False predicate.\"\"\"\n@abstractmethod\ndef visit_not(self, child_result: T) -&gt; T:\n\"\"\"Visit a bound Not predicate.\"\"\"\n@abstractmethod\ndef visit_and(self, left_result: T, right_result: T) -&gt; T:\n\"\"\"Visit a bound And predicate.\"\"\"\n@abstractmethod\ndef visit_or(self, left_result: T, right_result: T) -&gt; T:\n\"\"\"Visit a bound Or predicate.\"\"\"\n@abstractmethod\ndef visit_starts_with(self, term: BoundTerm[L], literal: Literal[L]) -&gt; T:\n\"\"\"Visit bound StartsWith predicate.\"\"\"\n@abstractmethod\ndef visit_not_starts_with(self, term: BoundTerm[L], literal: Literal[L]) -&gt; T:\n\"\"\"Visit bound NotStartsWith predicate.\"\"\"\ndef visit_unbound_predicate(self, predicate: UnboundPredicate[L]) -&gt; T:\n\"\"\"Visit an unbound predicate.\n        Args:\n            predicate (UnboundPredicate[L]): An unbound predicate.\n        Raises:\n            TypeError: This always raises since an unbound predicate is not expected in a bound boolean expression.\n        \"\"\"\nraise TypeError(f\"Not a bound predicate: {predicate}\")\ndef visit_bound_predicate(self, predicate: BoundPredicate[L]) -&gt; T:\n\"\"\"Visit a bound predicate.\n        Args:\n            predicate (BoundPredicate[L]): A bound predicate.\n        \"\"\"\nreturn visit_bound_predicate(predicate, self)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_and","title":"<code>visit_and(left_result, right_result)</code>  <code>abstractmethod</code>","text":"<p>Visit a bound And predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_and(self, left_result: T, right_result: T) -&gt; T:\n\"\"\"Visit a bound And predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_bound_predicate","title":"<code>visit_bound_predicate(predicate)</code>","text":"<p>Visit a bound predicate.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>BoundPredicate[L]</code> <p>A bound predicate.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>def visit_bound_predicate(self, predicate: BoundPredicate[L]) -&gt; T:\n\"\"\"Visit a bound predicate.\n    Args:\n        predicate (BoundPredicate[L]): A bound predicate.\n    \"\"\"\nreturn visit_bound_predicate(predicate, self)\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_equal","title":"<code>visit_equal(term, literal)</code>  <code>abstractmethod</code>","text":"<p>Visit a bound Equal predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_equal(self, term: BoundTerm[L], literal: Literal[L]) -&gt; T:\n\"\"\"Visit a bound Equal predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_false","title":"<code>visit_false()</code>  <code>abstractmethod</code>","text":"<p>Visit a bound False predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_false(self) -&gt; T:\n\"\"\"Visit a bound False predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_greater_than","title":"<code>visit_greater_than(term, literal)</code>  <code>abstractmethod</code>","text":"<p>Visit a bound GreaterThan predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_greater_than(self, term: BoundTerm[L], literal: Literal[L]) -&gt; T:\n\"\"\"Visit a bound GreaterThan predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_greater_than_or_equal","title":"<code>visit_greater_than_or_equal(term, literal)</code>  <code>abstractmethod</code>","text":"<p>Visit a bound GreaterThanOrEqual predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_greater_than_or_equal(self, term: BoundTerm[L], literal: Literal[L]) -&gt; T:\n\"\"\"Visit a bound GreaterThanOrEqual predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_in","title":"<code>visit_in(term, literals)</code>  <code>abstractmethod</code>","text":"<p>Visit a bound In predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_in(self, term: BoundTerm[L], literals: Set[L]) -&gt; T:\n\"\"\"Visit a bound In predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_is_nan","title":"<code>visit_is_nan(term)</code>  <code>abstractmethod</code>","text":"<p>Visit a bound IsNan predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_is_nan(self, term: BoundTerm[L]) -&gt; T:\n\"\"\"Visit a bound IsNan predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_is_null","title":"<code>visit_is_null(term)</code>  <code>abstractmethod</code>","text":"<p>Visit a bound IsNull predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_is_null(self, term: BoundTerm[L]) -&gt; T:\n\"\"\"Visit a bound IsNull predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_less_than","title":"<code>visit_less_than(term, literal)</code>  <code>abstractmethod</code>","text":"<p>Visit a bound LessThan predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_less_than(self, term: BoundTerm[L], literal: Literal[L]) -&gt; T:\n\"\"\"Visit a bound LessThan predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_less_than_or_equal","title":"<code>visit_less_than_or_equal(term, literal)</code>  <code>abstractmethod</code>","text":"<p>Visit a bound LessThanOrEqual predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_less_than_or_equal(self, term: BoundTerm[L], literal: Literal[L]) -&gt; T:\n\"\"\"Visit a bound LessThanOrEqual predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_not","title":"<code>visit_not(child_result)</code>  <code>abstractmethod</code>","text":"<p>Visit a bound Not predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_not(self, child_result: T) -&gt; T:\n\"\"\"Visit a bound Not predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_not_equal","title":"<code>visit_not_equal(term, literal)</code>  <code>abstractmethod</code>","text":"<p>Visit a bound NotEqual predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_not_equal(self, term: BoundTerm[L], literal: Literal[L]) -&gt; T:\n\"\"\"Visit a bound NotEqual predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_not_in","title":"<code>visit_not_in(term, literals)</code>  <code>abstractmethod</code>","text":"<p>Visit a bound NotIn predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_not_in(self, term: BoundTerm[L], literals: Set[L]) -&gt; T:\n\"\"\"Visit a bound NotIn predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_not_nan","title":"<code>visit_not_nan(term)</code>  <code>abstractmethod</code>","text":"<p>Visit a bound NotNan predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_not_nan(self, term: BoundTerm[L]) -&gt; T:\n\"\"\"Visit a bound NotNan predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_not_null","title":"<code>visit_not_null(term)</code>  <code>abstractmethod</code>","text":"<p>Visit a bound NotNull predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_not_null(self, term: BoundTerm[L]) -&gt; T:\n\"\"\"Visit a bound NotNull predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_not_starts_with","title":"<code>visit_not_starts_with(term, literal)</code>  <code>abstractmethod</code>","text":"<p>Visit bound NotStartsWith predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_not_starts_with(self, term: BoundTerm[L], literal: Literal[L]) -&gt; T:\n\"\"\"Visit bound NotStartsWith predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_or","title":"<code>visit_or(left_result, right_result)</code>  <code>abstractmethod</code>","text":"<p>Visit a bound Or predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_or(self, left_result: T, right_result: T) -&gt; T:\n\"\"\"Visit a bound Or predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_starts_with","title":"<code>visit_starts_with(term, literal)</code>  <code>abstractmethod</code>","text":"<p>Visit bound StartsWith predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_starts_with(self, term: BoundTerm[L], literal: Literal[L]) -&gt; T:\n\"\"\"Visit bound StartsWith predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_true","title":"<code>visit_true()</code>  <code>abstractmethod</code>","text":"<p>Visit a bound True predicate.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@abstractmethod\ndef visit_true(self) -&gt; T:\n\"\"\"Visit a bound True predicate.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.BoundBooleanExpressionVisitor.visit_unbound_predicate","title":"<code>visit_unbound_predicate(predicate)</code>","text":"<p>Visit an unbound predicate.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>UnboundPredicate[L]</code> <p>An unbound predicate.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>This always raises since an unbound predicate is not expected in a bound boolean expression.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>def visit_unbound_predicate(self, predicate: UnboundPredicate[L]) -&gt; T:\n\"\"\"Visit an unbound predicate.\n    Args:\n        predicate (UnboundPredicate[L]): An unbound predicate.\n    Raises:\n        TypeError: This always raises since an unbound predicate is not expected in a bound boolean expression.\n    \"\"\"\nraise TypeError(f\"Not a bound predicate: {predicate}\")\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.bind","title":"<code>bind(schema, expression, case_sensitive)</code>","text":"<p>Travers over an expression to bind the predicates to the schema.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Schema</code> <p>A schema to use when binding the expression.</p> required <code>expression</code> <code>BooleanExpression</code> <p>An expression containing UnboundPredicates that can be bound.</p> required <code>case_sensitive</code> <code>bool</code> <p>Whether to consider case when binding a reference to a field in a schema, defaults to True.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>In the case a predicate is already bound.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>def bind(schema: Schema, expression: BooleanExpression, case_sensitive: bool) -&gt; BooleanExpression:\n\"\"\"Travers over an expression to bind the predicates to the schema.\n    Args:\n      schema (Schema): A schema to use when binding the expression.\n      expression (BooleanExpression): An expression containing UnboundPredicates that can be bound.\n      case_sensitive (bool): Whether to consider case when binding a reference to a field in a schema, defaults to True.\n    Raises:\n        TypeError: In the case a predicate is already bound.\n    \"\"\"\nreturn visit(expression, BindVisitor(schema, case_sensitive))\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.expression_to_plain_format","title":"<code>expression_to_plain_format(expressions, cast_int_to_datetime=False)</code>","text":"<p>Formats a Disjunctive Normal Form expression.</p> <p>These are the formats that the expression can be fed into:</p> <ul> <li>https://arrow.apache.org/docs/python/generated/pyarrow.parquet.read_table.html</li> <li>https://docs.dask.org/en/stable/generated/dask.dataframe.read_parquet.html</li> </ul> <p>Contrary to normal DNF that may contain Not expressions, but here they should have been rewritten. This can be done using <code>rewrite_not(...)</code>.</p> <p>Keep in mind that this is only used for page skipping, and still needs to filter on a row level.</p> <p>Parameters:</p> Name Type Description Default <code>expressions</code> <code>Tuple[BooleanExpression, ...]</code> <p>Expression in Disjunctive Normal Form.</p> required <p>Returns:</p> Type Description <code>List[List[Tuple[str, str, Any]]]</code> <p>Formatter filter compatible with Dask and PyArrow.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>def expression_to_plain_format(\nexpressions: Tuple[BooleanExpression, ...], cast_int_to_datetime: bool = False\n) -&gt; List[List[Tuple[str, str, Any]]]:\n\"\"\"Formats a Disjunctive Normal Form expression.\n    These are the formats that the expression can be fed into:\n    - https://arrow.apache.org/docs/python/generated/pyarrow.parquet.read_table.html\n    - https://docs.dask.org/en/stable/generated/dask.dataframe.read_parquet.html\n    Contrary to normal DNF that may contain Not expressions, but here they should have\n    been rewritten. This can be done using ``rewrite_not(...)``.\n    Keep in mind that this is only used for page skipping, and still needs to filter\n    on a row level.\n    Args:\n        expressions: Expression in Disjunctive Normal Form.\n    Returns:\n        Formatter filter compatible with Dask and PyArrow.\n    \"\"\"\n# In the form of expr1 \u2228 expr2 \u2228 ... \u2228 exprN\nvisitor = ExpressionToPlainFormat(cast_int_to_datetime)\nreturn [visit(expression, visitor) for expression in expressions]\n</code></pre>"},{"location":"reference/pyiceberg/expressions/visitors/#pyiceberg.expressions.visitors.visit","title":"<code>visit(obj, visitor)</code>","text":"<p>A generic function for applying a boolean expression visitor to any point within an expression.</p> <p>The function traverses the expression in post-order fashion.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>BooleanExpression</code> <p>An instance of a BooleanExpression.</p> required <code>visitor</code> <code>BooleanExpressionVisitor[T]</code> <p>An instance of an implementation of the generic BooleanExpressionVisitor base class.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If attempting to visit an unsupported expression.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/expressions/visitors.py</code> <pre><code>@singledispatch\ndef visit(obj: BooleanExpression, visitor: BooleanExpressionVisitor[T]) -&gt; T:\n\"\"\"A generic function for applying a boolean expression visitor to any point within an expression.\n    The function traverses the expression in post-order fashion.\n    Args:\n        obj (BooleanExpression): An instance of a BooleanExpression.\n        visitor (BooleanExpressionVisitor[T]): An instance of an implementation of the generic BooleanExpressionVisitor base class.\n    Raises:\n        NotImplementedError: If attempting to visit an unsupported expression.\n    \"\"\"\nraise NotImplementedError(f\"Cannot visit unsupported expression: {obj}\")\n</code></pre>"},{"location":"reference/pyiceberg/io/","title":"io","text":"<p>Base FileIO classes for implementing reading and writing table files.</p> <p>The FileIO abstraction includes a subset of full filesystem implementations. Specifically, Iceberg needs to read or write a file at a given location (as a seekable stream), as well as check if a file exists. An implementation of the FileIO abstract base class is responsible for returning an InputFile instance, an OutputFile instance, and deleting a file given its location.</p>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.FileIO","title":"<code>FileIO</code>","text":"<p>         Bases: <code>ABC</code></p> <p>A base class for FileIO implementations.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>class FileIO(ABC):\n\"\"\"A base class for FileIO implementations.\"\"\"\nproperties: Properties\ndef __init__(self, properties: Properties = EMPTY_DICT):\nself.properties = properties\n@abstractmethod\ndef new_input(self, location: str) -&gt; InputFile:\n\"\"\"Get an InputFile instance to read bytes from the file at the given location.\n        Args:\n            location (str): A URI or a path to a local file.\n        \"\"\"\n@abstractmethod\ndef new_output(self, location: str) -&gt; OutputFile:\n\"\"\"Get an OutputFile instance to write bytes to the file at the given location.\n        Args:\n            location (str): A URI or a path to a local file.\n        \"\"\"\n@abstractmethod\ndef delete(self, location: Union[str, InputFile, OutputFile]) -&gt; None:\n\"\"\"Delete the file at the given path.\n        Args:\n            location (Union[str, InputFile, OutputFile]): A URI or a path to a local file--if an InputFile instance or\n                an OutputFile instance is provided, the location attribute for that instance is used as the URI to delete.\n        Raises:\n            PermissionError: If the file at location cannot be accessed due to a permission error.\n            FileNotFoundError: When the file at the provided location does not exist.\n        \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.FileIO.delete","title":"<code>delete(location)</code>  <code>abstractmethod</code>","text":"<p>Delete the file at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Union[str, InputFile, OutputFile]</code> <p>A URI or a path to a local file--if an InputFile instance or an OutputFile instance is provided, the location attribute for that instance is used as the URI to delete.</p> required <p>Raises:</p> Type Description <code>PermissionError</code> <p>If the file at location cannot be accessed due to a permission error.</p> <code>FileNotFoundError</code> <p>When the file at the provided location does not exist.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>@abstractmethod\ndef delete(self, location: Union[str, InputFile, OutputFile]) -&gt; None:\n\"\"\"Delete the file at the given path.\n    Args:\n        location (Union[str, InputFile, OutputFile]): A URI or a path to a local file--if an InputFile instance or\n            an OutputFile instance is provided, the location attribute for that instance is used as the URI to delete.\n    Raises:\n        PermissionError: If the file at location cannot be accessed due to a permission error.\n        FileNotFoundError: When the file at the provided location does not exist.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.FileIO.new_input","title":"<code>new_input(location)</code>  <code>abstractmethod</code>","text":"<p>Get an InputFile instance to read bytes from the file at the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>A URI or a path to a local file.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>@abstractmethod\ndef new_input(self, location: str) -&gt; InputFile:\n\"\"\"Get an InputFile instance to read bytes from the file at the given location.\n    Args:\n        location (str): A URI or a path to a local file.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.FileIO.new_output","title":"<code>new_output(location)</code>  <code>abstractmethod</code>","text":"<p>Get an OutputFile instance to write bytes to the file at the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>A URI or a path to a local file.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>@abstractmethod\ndef new_output(self, location: str) -&gt; OutputFile:\n\"\"\"Get an OutputFile instance to write bytes to the file at the given location.\n    Args:\n        location (str): A URI or a path to a local file.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.InputFile","title":"<code>InputFile</code>","text":"<p>         Bases: <code>ABC</code></p> <p>A base class for InputFile implementations.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>A URI or a path to a local file.</p> required <p>Attributes:</p> Name Type Description <code>location</code> <code>str</code> <p>The URI or path to a local file for an InputFile instance.</p> <code>exists</code> <code>bool</code> <p>Whether the file exists or not.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>class InputFile(ABC):\n\"\"\"A base class for InputFile implementations.\n    Args:\n        location (str): A URI or a path to a local file.\n    Attributes:\n        location (str): The URI or path to a local file for an InputFile instance.\n        exists (bool): Whether the file exists or not.\n    \"\"\"\ndef __init__(self, location: str):\nself._location = location\n@abstractmethod\ndef __len__(self) -&gt; int:\n\"\"\"Returns the total length of the file, in bytes.\"\"\"\n@property\ndef location(self) -&gt; str:\n\"\"\"The fully-qualified location of the input file.\"\"\"\nreturn self._location\n@abstractmethod\ndef exists(self) -&gt; bool:\n\"\"\"Checks whether the location exists.\n        Raises:\n            PermissionError: If the file at self.location cannot be accessed due to a permission error.\n        \"\"\"\n@abstractmethod\ndef open(self, seekable: bool = True) -&gt; InputStream:\n\"\"\"This method should return an object that matches the InputStream protocol.\n        Args:\n            seekable: If the stream should support seek, or if it is consumed sequential.\n        Returns:\n            InputStream: An object that matches the InputStream protocol.\n        Raises:\n            PermissionError: If the file at self.location cannot be accessed due to a permission error.\n            FileNotFoundError: If the file at self.location does not exist.\n        \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.InputFile.location","title":"<code>location: str</code>  <code>property</code>","text":"<p>The fully-qualified location of the input file.</p>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.InputFile.__len__","title":"<code>__len__()</code>  <code>abstractmethod</code>","text":"<p>Returns the total length of the file, in bytes.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>@abstractmethod\ndef __len__(self) -&gt; int:\n\"\"\"Returns the total length of the file, in bytes.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.InputFile.exists","title":"<code>exists()</code>  <code>abstractmethod</code>","text":"<p>Checks whether the location exists.</p> <p>Raises:</p> Type Description <code>PermissionError</code> <p>If the file at self.location cannot be accessed due to a permission error.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>@abstractmethod\ndef exists(self) -&gt; bool:\n\"\"\"Checks whether the location exists.\n    Raises:\n        PermissionError: If the file at self.location cannot be accessed due to a permission error.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.InputFile.open","title":"<code>open(seekable=True)</code>  <code>abstractmethod</code>","text":"<p>This method should return an object that matches the InputStream protocol.</p> <p>Parameters:</p> Name Type Description Default <code>seekable</code> <code>bool</code> <p>If the stream should support seek, or if it is consumed sequential.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>InputStream</code> <code>InputStream</code> <p>An object that matches the InputStream protocol.</p> <p>Raises:</p> Type Description <code>PermissionError</code> <p>If the file at self.location cannot be accessed due to a permission error.</p> <code>FileNotFoundError</code> <p>If the file at self.location does not exist.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>@abstractmethod\ndef open(self, seekable: bool = True) -&gt; InputStream:\n\"\"\"This method should return an object that matches the InputStream protocol.\n    Args:\n        seekable: If the stream should support seek, or if it is consumed sequential.\n    Returns:\n        InputStream: An object that matches the InputStream protocol.\n    Raises:\n        PermissionError: If the file at self.location cannot be accessed due to a permission error.\n        FileNotFoundError: If the file at self.location does not exist.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.InputStream","title":"<code>InputStream</code>","text":"<p>         Bases: <code>Protocol</code></p> <p>A protocol for the file-like object returned by InputFile.open(...).</p> <p>This outlines the minimally required methods for a seekable input stream returned from an InputFile implementation's <code>open(...)</code> method. These methods are a subset of IOBase/RawIOBase.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>@runtime_checkable\nclass InputStream(Protocol):\n\"\"\"A protocol for the file-like object returned by InputFile.open(...).\n    This outlines the minimally required methods for a seekable input stream returned from an InputFile\n    implementation's `open(...)` method. These methods are a subset of IOBase/RawIOBase.\n    \"\"\"\n@abstractmethod\ndef read(self, size: int = 0) -&gt; bytes:\n...\n@abstractmethod\ndef seek(self, offset: int, whence: int = SEEK_SET) -&gt; int:\n...\n@abstractmethod\ndef tell(self) -&gt; int:\n...\n@abstractmethod\ndef close(self) -&gt; None:\n...\ndef __enter__(self) -&gt; InputStream:\n\"\"\"Provides setup when opening an InputStream using a 'with' statement.\"\"\"\n@abstractmethod\ndef __exit__(\nself, exctype: Optional[Type[BaseException]], excinst: Optional[BaseException], exctb: Optional[TracebackType]\n) -&gt; None:\n\"\"\"Performs cleanup when exiting the scope of a 'with' statement.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.InputStream.__enter__","title":"<code>__enter__()</code>","text":"<p>Provides setup when opening an InputStream using a 'with' statement.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>def __enter__(self) -&gt; InputStream:\n\"\"\"Provides setup when opening an InputStream using a 'with' statement.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.InputStream.__exit__","title":"<code>__exit__(exctype, excinst, exctb)</code>  <code>abstractmethod</code>","text":"<p>Performs cleanup when exiting the scope of a 'with' statement.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>@abstractmethod\ndef __exit__(\nself, exctype: Optional[Type[BaseException]], excinst: Optional[BaseException], exctb: Optional[TracebackType]\n) -&gt; None:\n\"\"\"Performs cleanup when exiting the scope of a 'with' statement.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.OutputFile","title":"<code>OutputFile</code>","text":"<p>         Bases: <code>ABC</code></p> <p>A base class for OutputFile implementations.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>A URI or a path to a local file.</p> required <p>Attributes:</p> Name Type Description <code>location</code> <code>str</code> <p>The URI or path to a local file for an OutputFile instance.</p> <code>exists</code> <code>bool</code> <p>Whether the file exists or not.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>class OutputFile(ABC):\n\"\"\"A base class for OutputFile implementations.\n    Args:\n        location (str): A URI or a path to a local file.\n    Attributes:\n        location (str): The URI or path to a local file for an OutputFile instance.\n        exists (bool): Whether the file exists or not.\n    \"\"\"\ndef __init__(self, location: str):\nself._location = location\n@abstractmethod\ndef __len__(self) -&gt; int:\n\"\"\"Returns the total length of the file, in bytes.\"\"\"\n@property\ndef location(self) -&gt; str:\n\"\"\"The fully-qualified location of the output file.\"\"\"\nreturn self._location\n@abstractmethod\ndef exists(self) -&gt; bool:\n\"\"\"Checks whether the location exists.\n        Raises:\n            PermissionError: If the file at self.location cannot be accessed due to a permission error.\n        \"\"\"\n@abstractmethod\ndef to_input_file(self) -&gt; InputFile:\n\"\"\"Returns an InputFile for the location of this output file.\"\"\"\n@abstractmethod\ndef create(self, overwrite: bool = False) -&gt; OutputStream:\n\"\"\"This method should return an object that matches the OutputStream protocol.\n        Args:\n            overwrite (bool): If the file already exists at `self.location`\n                and `overwrite` is False a FileExistsError should be raised.\n        Returns:\n            OutputStream: An object that matches the OutputStream protocol.\n        Raises:\n            PermissionError: If the file at self.location cannot be accessed due to a permission error.\n            FileExistsError: If the file at self.location already exists and `overwrite=False`.\n        \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.OutputFile.location","title":"<code>location: str</code>  <code>property</code>","text":"<p>The fully-qualified location of the output file.</p>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.OutputFile.__len__","title":"<code>__len__()</code>  <code>abstractmethod</code>","text":"<p>Returns the total length of the file, in bytes.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>@abstractmethod\ndef __len__(self) -&gt; int:\n\"\"\"Returns the total length of the file, in bytes.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.OutputFile.create","title":"<code>create(overwrite=False)</code>  <code>abstractmethod</code>","text":"<p>This method should return an object that matches the OutputStream protocol.</p> <p>Parameters:</p> Name Type Description Default <code>overwrite</code> <code>bool</code> <p>If the file already exists at <code>self.location</code> and <code>overwrite</code> is False a FileExistsError should be raised.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>OutputStream</code> <code>OutputStream</code> <p>An object that matches the OutputStream protocol.</p> <p>Raises:</p> Type Description <code>PermissionError</code> <p>If the file at self.location cannot be accessed due to a permission error.</p> <code>FileExistsError</code> <p>If the file at self.location already exists and <code>overwrite=False</code>.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>@abstractmethod\ndef create(self, overwrite: bool = False) -&gt; OutputStream:\n\"\"\"This method should return an object that matches the OutputStream protocol.\n    Args:\n        overwrite (bool): If the file already exists at `self.location`\n            and `overwrite` is False a FileExistsError should be raised.\n    Returns:\n        OutputStream: An object that matches the OutputStream protocol.\n    Raises:\n        PermissionError: If the file at self.location cannot be accessed due to a permission error.\n        FileExistsError: If the file at self.location already exists and `overwrite=False`.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.OutputFile.exists","title":"<code>exists()</code>  <code>abstractmethod</code>","text":"<p>Checks whether the location exists.</p> <p>Raises:</p> Type Description <code>PermissionError</code> <p>If the file at self.location cannot be accessed due to a permission error.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>@abstractmethod\ndef exists(self) -&gt; bool:\n\"\"\"Checks whether the location exists.\n    Raises:\n        PermissionError: If the file at self.location cannot be accessed due to a permission error.\n    \"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.OutputFile.to_input_file","title":"<code>to_input_file()</code>  <code>abstractmethod</code>","text":"<p>Returns an InputFile for the location of this output file.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>@abstractmethod\ndef to_input_file(self) -&gt; InputFile:\n\"\"\"Returns an InputFile for the location of this output file.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.OutputStream","title":"<code>OutputStream</code>","text":"<p>         Bases: <code>Protocol</code></p> <p>A protocol for the file-like object returned by OutputFile.create(...).</p> <p>This outlines the minimally required methods for a writable output stream returned from an OutputFile implementation's <code>create(...)</code> method. These methods are a subset of IOBase/RawIOBase.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>@runtime_checkable\nclass OutputStream(Protocol):  # pragma: no cover\n\"\"\"A protocol for the file-like object returned by OutputFile.create(...).\n    This outlines the minimally required methods for a writable output stream returned from an OutputFile\n    implementation's `create(...)` method. These methods are a subset of IOBase/RawIOBase.\n    \"\"\"\n@abstractmethod\ndef write(self, b: bytes) -&gt; int:\n...\n@abstractmethod\ndef close(self) -&gt; None:\n...\n@abstractmethod\ndef __enter__(self) -&gt; OutputStream:\n\"\"\"Provides setup when opening an OutputStream using a 'with' statement.\"\"\"\n@abstractmethod\ndef __exit__(\nself, exctype: Optional[Type[BaseException]], excinst: Optional[BaseException], exctb: Optional[TracebackType]\n) -&gt; None:\n\"\"\"Performs cleanup when exiting the scope of a 'with' statement.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.OutputStream.__enter__","title":"<code>__enter__()</code>  <code>abstractmethod</code>","text":"<p>Provides setup when opening an OutputStream using a 'with' statement.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>@abstractmethod\ndef __enter__(self) -&gt; OutputStream:\n\"\"\"Provides setup when opening an OutputStream using a 'with' statement.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/#pyiceberg.io.OutputStream.__exit__","title":"<code>__exit__(exctype, excinst, exctb)</code>  <code>abstractmethod</code>","text":"<p>Performs cleanup when exiting the scope of a 'with' statement.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/__init__.py</code> <pre><code>@abstractmethod\ndef __exit__(\nself, exctype: Optional[Type[BaseException]], excinst: Optional[BaseException], exctb: Optional[TracebackType]\n) -&gt; None:\n\"\"\"Performs cleanup when exiting the scope of a 'with' statement.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/fsspec/","title":"fsspec","text":"<p>FileIO implementation for reading and writing table files that uses fsspec compatible filesystems.</p>"},{"location":"reference/pyiceberg/io/fsspec/#pyiceberg.io.fsspec.FsspecFileIO","title":"<code>FsspecFileIO</code>","text":"<p>         Bases: <code>FileIO</code></p> <p>A FileIO implementation that uses fsspec.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/fsspec.py</code> <pre><code>class FsspecFileIO(FileIO):\n\"\"\"A FileIO implementation that uses fsspec.\"\"\"\ndef __init__(self, properties: Properties):\nself._scheme_to_fs = {}\nself._scheme_to_fs.update(SCHEME_TO_FS)\nself.get_fs: Callable[[str], AbstractFileSystem] = lru_cache(self._get_fs)\nsuper().__init__(properties=properties)\ndef new_input(self, location: str) -&gt; FsspecInputFile:\n\"\"\"Get an FsspecInputFile instance to read bytes from the file at the given location.\n        Args:\n            location (str): A URI or a path to a local file.\n        Returns:\n            FsspecInputFile: An FsspecInputFile instance for the given location.\n        \"\"\"\nuri = urlparse(location)\nfs = self.get_fs(uri.scheme)\nreturn FsspecInputFile(location=location, fs=fs)\ndef new_output(self, location: str) -&gt; FsspecOutputFile:\n\"\"\"Get an FsspecOutputFile instance to write bytes to the file at the given location.\n        Args:\n            location (str): A URI or a path to a local file.\n        Returns:\n            FsspecOutputFile: An FsspecOutputFile instance for the given location.\n        \"\"\"\nuri = urlparse(location)\nfs = self.get_fs(uri.scheme)\nreturn FsspecOutputFile(location=location, fs=fs)\ndef delete(self, location: Union[str, InputFile, OutputFile]) -&gt; None:\n\"\"\"Delete the file at the given location.\n        Args:\n            location (Union[str, InputFile, OutputFile]): The URI to the file--if an InputFile instance or an\n                OutputFile instance is provided, the location attribute for that instance is used as the location\n                to delete.\n        \"\"\"\nif isinstance(location, (InputFile, OutputFile)):\nstr_location = location.location  # Use InputFile or OutputFile location\nelse:\nstr_location = location\nuri = urlparse(str_location)\nfs = self.get_fs(uri.scheme)\nfs.rm(str_location)\ndef _get_fs(self, scheme: str) -&gt; AbstractFileSystem:\n\"\"\"Get a filesystem for a specific scheme.\"\"\"\nif scheme not in self._scheme_to_fs:\nraise ValueError(f\"No registered filesystem for scheme: {scheme}\")\nreturn self._scheme_to_fs[scheme](self.properties)\n</code></pre>"},{"location":"reference/pyiceberg/io/fsspec/#pyiceberg.io.fsspec.FsspecFileIO.delete","title":"<code>delete(location)</code>","text":"<p>Delete the file at the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Union[str, InputFile, OutputFile]</code> <p>The URI to the file--if an InputFile instance or an OutputFile instance is provided, the location attribute for that instance is used as the location to delete.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/fsspec.py</code> <pre><code>def delete(self, location: Union[str, InputFile, OutputFile]) -&gt; None:\n\"\"\"Delete the file at the given location.\n    Args:\n        location (Union[str, InputFile, OutputFile]): The URI to the file--if an InputFile instance or an\n            OutputFile instance is provided, the location attribute for that instance is used as the location\n            to delete.\n    \"\"\"\nif isinstance(location, (InputFile, OutputFile)):\nstr_location = location.location  # Use InputFile or OutputFile location\nelse:\nstr_location = location\nuri = urlparse(str_location)\nfs = self.get_fs(uri.scheme)\nfs.rm(str_location)\n</code></pre>"},{"location":"reference/pyiceberg/io/fsspec/#pyiceberg.io.fsspec.FsspecFileIO.new_input","title":"<code>new_input(location)</code>","text":"<p>Get an FsspecInputFile instance to read bytes from the file at the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>A URI or a path to a local file.</p> required <p>Returns:</p> Name Type Description <code>FsspecInputFile</code> <code>FsspecInputFile</code> <p>An FsspecInputFile instance for the given location.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/fsspec.py</code> <pre><code>def new_input(self, location: str) -&gt; FsspecInputFile:\n\"\"\"Get an FsspecInputFile instance to read bytes from the file at the given location.\n    Args:\n        location (str): A URI or a path to a local file.\n    Returns:\n        FsspecInputFile: An FsspecInputFile instance for the given location.\n    \"\"\"\nuri = urlparse(location)\nfs = self.get_fs(uri.scheme)\nreturn FsspecInputFile(location=location, fs=fs)\n</code></pre>"},{"location":"reference/pyiceberg/io/fsspec/#pyiceberg.io.fsspec.FsspecFileIO.new_output","title":"<code>new_output(location)</code>","text":"<p>Get an FsspecOutputFile instance to write bytes to the file at the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>A URI or a path to a local file.</p> required <p>Returns:</p> Name Type Description <code>FsspecOutputFile</code> <code>FsspecOutputFile</code> <p>An FsspecOutputFile instance for the given location.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/fsspec.py</code> <pre><code>def new_output(self, location: str) -&gt; FsspecOutputFile:\n\"\"\"Get an FsspecOutputFile instance to write bytes to the file at the given location.\n    Args:\n        location (str): A URI or a path to a local file.\n    Returns:\n        FsspecOutputFile: An FsspecOutputFile instance for the given location.\n    \"\"\"\nuri = urlparse(location)\nfs = self.get_fs(uri.scheme)\nreturn FsspecOutputFile(location=location, fs=fs)\n</code></pre>"},{"location":"reference/pyiceberg/io/fsspec/#pyiceberg.io.fsspec.FsspecInputFile","title":"<code>FsspecInputFile</code>","text":"<p>         Bases: <code>InputFile</code></p> <p>An input file implementation for the FsspecFileIO.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>A URI to a file location.</p> required <code>fs</code> <code>AbstractFileSystem</code> <p>An fsspec filesystem instance.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/fsspec.py</code> <pre><code>class FsspecInputFile(InputFile):\n\"\"\"An input file implementation for the FsspecFileIO.\n    Args:\n        location (str): A URI to a file location.\n        fs (AbstractFileSystem): An fsspec filesystem instance.\n    \"\"\"\ndef __init__(self, location: str, fs: AbstractFileSystem):\nself._fs = fs\nsuper().__init__(location=location)\ndef __len__(self) -&gt; int:\n\"\"\"Returns the total length of the file, in bytes.\"\"\"\nobject_info = self._fs.info(self.location)\nif size := object_info.get(\"Size\"):\nreturn size\nelif size := object_info.get(\"size\"):\nreturn size\nraise RuntimeError(f\"Cannot retrieve object info: {self.location}\")\ndef exists(self) -&gt; bool:\n\"\"\"Checks whether the location exists.\"\"\"\nreturn self._fs.lexists(self.location)\ndef open(self, seekable: bool = True) -&gt; InputStream:\n\"\"\"Create an input stream for reading the contents of the file.\n        Args:\n            seekable: If the stream should support seek, or if it is consumed sequential.\n        Returns:\n            OpenFile: An fsspec compliant file-like object.\n        Raises:\n            FileNotFoundError: If the file does not exist.\n        \"\"\"\ntry:\nreturn self._fs.open(self.location, \"rb\")\nexcept FileNotFoundError as e:\n# To have a consistent error handling experience, make sure exception contains missing file location.\nraise e if e.filename else FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), self.location) from e\n</code></pre>"},{"location":"reference/pyiceberg/io/fsspec/#pyiceberg.io.fsspec.FsspecInputFile.__len__","title":"<code>__len__()</code>","text":"<p>Returns the total length of the file, in bytes.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/fsspec.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Returns the total length of the file, in bytes.\"\"\"\nobject_info = self._fs.info(self.location)\nif size := object_info.get(\"Size\"):\nreturn size\nelif size := object_info.get(\"size\"):\nreturn size\nraise RuntimeError(f\"Cannot retrieve object info: {self.location}\")\n</code></pre>"},{"location":"reference/pyiceberg/io/fsspec/#pyiceberg.io.fsspec.FsspecInputFile.exists","title":"<code>exists()</code>","text":"<p>Checks whether the location exists.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/fsspec.py</code> <pre><code>def exists(self) -&gt; bool:\n\"\"\"Checks whether the location exists.\"\"\"\nreturn self._fs.lexists(self.location)\n</code></pre>"},{"location":"reference/pyiceberg/io/fsspec/#pyiceberg.io.fsspec.FsspecInputFile.open","title":"<code>open(seekable=True)</code>","text":"<p>Create an input stream for reading the contents of the file.</p> <p>Parameters:</p> Name Type Description Default <code>seekable</code> <code>bool</code> <p>If the stream should support seek, or if it is consumed sequential.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>OpenFile</code> <code>InputStream</code> <p>An fsspec compliant file-like object.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/fsspec.py</code> <pre><code>def open(self, seekable: bool = True) -&gt; InputStream:\n\"\"\"Create an input stream for reading the contents of the file.\n    Args:\n        seekable: If the stream should support seek, or if it is consumed sequential.\n    Returns:\n        OpenFile: An fsspec compliant file-like object.\n    Raises:\n        FileNotFoundError: If the file does not exist.\n    \"\"\"\ntry:\nreturn self._fs.open(self.location, \"rb\")\nexcept FileNotFoundError as e:\n# To have a consistent error handling experience, make sure exception contains missing file location.\nraise e if e.filename else FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), self.location) from e\n</code></pre>"},{"location":"reference/pyiceberg/io/fsspec/#pyiceberg.io.fsspec.FsspecOutputFile","title":"<code>FsspecOutputFile</code>","text":"<p>         Bases: <code>OutputFile</code></p> <p>An output file implementation for the FsspecFileIO.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>A URI to a file location.</p> required <code>fs</code> <code>AbstractFileSystem</code> <p>An fsspec filesystem instance.</p> required Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/fsspec.py</code> <pre><code>class FsspecOutputFile(OutputFile):\n\"\"\"An output file implementation for the FsspecFileIO.\n    Args:\n        location (str): A URI to a file location.\n        fs (AbstractFileSystem): An fsspec filesystem instance.\n    \"\"\"\ndef __init__(self, location: str, fs: AbstractFileSystem):\nself._fs = fs\nsuper().__init__(location=location)\ndef __len__(self) -&gt; int:\n\"\"\"Returns the total length of the file, in bytes.\"\"\"\nobject_info = self._fs.info(self.location)\nif size := object_info.get(\"Size\"):\nreturn size\nelif size := object_info.get(\"size\"):\nreturn size\nraise RuntimeError(f\"Cannot retrieve object info: {self.location}\")\ndef exists(self) -&gt; bool:\n\"\"\"Checks whether the location exists.\"\"\"\nreturn self._fs.lexists(self.location)\ndef create(self, overwrite: bool = False) -&gt; OutputStream:\n\"\"\"Create an output stream for reading the contents of the file.\n        Args:\n            overwrite (bool): Whether to overwrite the file if it already exists.\n        Returns:\n            OpenFile: An fsspec compliant file-like object.\n        Raises:\n            FileExistsError: If the file already exists at the location and overwrite is set to False.\n        Note:\n            If overwrite is set to False, a check is first performed to verify that the file does not exist.\n            This is not thread-safe and a possibility does exist that the file can be created by a concurrent\n            process after the existence check yet before the output stream is created. In such a case, the default\n            behavior will truncate the contents of the existing file when opening the output stream.\n        \"\"\"\nif not overwrite and self.exists():\nraise FileExistsError(f\"Cannot create file, file already exists: {self.location}\")\nreturn self._fs.open(self.location, \"wb\")\ndef to_input_file(self) -&gt; FsspecInputFile:\n\"\"\"Returns a new FsspecInputFile for the location at `self.location`.\"\"\"\nreturn FsspecInputFile(location=self.location, fs=self._fs)\n</code></pre>"},{"location":"reference/pyiceberg/io/fsspec/#pyiceberg.io.fsspec.FsspecOutputFile.__len__","title":"<code>__len__()</code>","text":"<p>Returns the total length of the file, in bytes.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/fsspec.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Returns the total length of the file, in bytes.\"\"\"\nobject_info = self._fs.info(self.location)\nif size := object_info.get(\"Size\"):\nreturn size\nelif size := object_info.get(\"size\"):\nreturn size\nraise RuntimeError(f\"Cannot retrieve object info: {self.location}\")\n</code></pre>"},{"location":"reference/pyiceberg/io/fsspec/#pyiceberg.io.fsspec.FsspecOutputFile.create","title":"<code>create(overwrite=False)</code>","text":"<p>Create an output stream for reading the contents of the file.</p> <p>Parameters:</p> Name Type Description Default <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the file if it already exists.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>OpenFile</code> <code>OutputStream</code> <p>An fsspec compliant file-like object.</p> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If the file already exists at the location and overwrite is set to False.</p> Note <p>If overwrite is set to False, a check is first performed to verify that the file does not exist. This is not thread-safe and a possibility does exist that the file can be created by a concurrent process after the existence check yet before the output stream is created. In such a case, the default behavior will truncate the contents of the existing file when opening the output stream.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/fsspec.py</code> <pre><code>def create(self, overwrite: bool = False) -&gt; OutputStream:\n\"\"\"Create an output stream for reading the contents of the file.\n    Args:\n        overwrite (bool): Whether to overwrite the file if it already exists.\n    Returns:\n        OpenFile: An fsspec compliant file-like object.\n    Raises:\n        FileExistsError: If the file already exists at the location and overwrite is set to False.\n    Note:\n        If overwrite is set to False, a check is first performed to verify that the file does not exist.\n        This is not thread-safe and a possibility does exist that the file can be created by a concurrent\n        process after the existence check yet before the output stream is created. In such a case, the default\n        behavior will truncate the contents of the existing file when opening the output stream.\n    \"\"\"\nif not overwrite and self.exists():\nraise FileExistsError(f\"Cannot create file, file already exists: {self.location}\")\nreturn self._fs.open(self.location, \"wb\")\n</code></pre>"},{"location":"reference/pyiceberg/io/fsspec/#pyiceberg.io.fsspec.FsspecOutputFile.exists","title":"<code>exists()</code>","text":"<p>Checks whether the location exists.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/fsspec.py</code> <pre><code>def exists(self) -&gt; bool:\n\"\"\"Checks whether the location exists.\"\"\"\nreturn self._fs.lexists(self.location)\n</code></pre>"},{"location":"reference/pyiceberg/io/fsspec/#pyiceberg.io.fsspec.FsspecOutputFile.to_input_file","title":"<code>to_input_file()</code>","text":"<p>Returns a new FsspecInputFile for the location at <code>self.location</code>.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/fsspec.py</code> <pre><code>def to_input_file(self) -&gt; FsspecInputFile:\n\"\"\"Returns a new FsspecInputFile for the location at `self.location`.\"\"\"\nreturn FsspecInputFile(location=self.location, fs=self._fs)\n</code></pre>"},{"location":"reference/pyiceberg/io/memory/","title":"memory","text":""},{"location":"reference/pyiceberg/io/memory/#pyiceberg.io.memory.MemoryInputStream","title":"<code>MemoryInputStream</code>","text":"<p>         Bases: <code>InputStream</code></p> <p>Simple in memory stream that we use to store decompressed blocks.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; stream = MemoryInputStream(b'22memory1925')\n&gt;&gt;&gt; stream.tell()\n0\n&gt;&gt;&gt; stream.read(2)\nb'22'\n&gt;&gt;&gt; stream.tell()\n2\n&gt;&gt;&gt; stream.seek(8)\n&gt;&gt;&gt; stream.read(4)\nb'1925'\n&gt;&gt;&gt; stream.close()\n</code></pre> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/memory.py</code> <pre><code>class MemoryInputStream(InputStream):\n\"\"\"\n    Simple in memory stream that we use to store decompressed blocks.\n    Examples:\n        &gt;&gt;&gt; stream = MemoryInputStream(b'22memory1925')\n        &gt;&gt;&gt; stream.tell()\n        0\n        &gt;&gt;&gt; stream.read(2)\n        b'22'\n        &gt;&gt;&gt; stream.tell()\n        2\n        &gt;&gt;&gt; stream.seek(8)\n        &gt;&gt;&gt; stream.read(4)\n        b'1925'\n        &gt;&gt;&gt; stream.close()\n    \"\"\"\nbuffer: bytes\nlen: int\npos: int\ndef __init__(self, buffer: bytes):\nself.buffer = buffer\nself.len = len(buffer)\nself.pos = 0\ndef read(self, size: int = 0) -&gt; bytes:\nb = self.buffer[self.pos : self.pos + size]\nself.pos += size\nreturn b\ndef seek(self, offset: int, whence: int = SEEK_SET) -&gt; int:\nif whence == SEEK_SET:\nself.pos = offset\nelif whence == SEEK_CUR:\nself.pos += offset\nelif whence == SEEK_END:\nself.pos = self.len + offset\nelse:\nraise ValueError(f\"Unknown whence {offset}\")\nreturn self.pos\ndef tell(self) -&gt; int:\nreturn self.pos\ndef close(self) -&gt; None:\ndel self.buffer\nself.pos = 0\ndef __enter__(self) -&gt; MemoryInputStream:\n\"\"\"Provides setup when opening a MemoryInputStream using a 'with' statement.\"\"\"\nreturn self\ndef __exit__(\nself, exctype: Optional[Type[BaseException]], excinst: Optional[BaseException], exctb: Optional[TracebackType]\n) -&gt; None:\n\"\"\"Performs cleanup when exiting the scope of a 'with' statement.\"\"\"\nself.close()\n</code></pre>"},{"location":"reference/pyiceberg/io/memory/#pyiceberg.io.memory.MemoryInputStream.__enter__","title":"<code>__enter__()</code>","text":"<p>Provides setup when opening a MemoryInputStream using a 'with' statement.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/memory.py</code> <pre><code>def __enter__(self) -&gt; MemoryInputStream:\n\"\"\"Provides setup when opening a MemoryInputStream using a 'with' statement.\"\"\"\nreturn self\n</code></pre>"},{"location":"reference/pyiceberg/io/memory/#pyiceberg.io.memory.MemoryInputStream.__exit__","title":"<code>__exit__(exctype, excinst, exctb)</code>","text":"<p>Performs cleanup when exiting the scope of a 'with' statement.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/memory.py</code> <pre><code>def __exit__(\nself, exctype: Optional[Type[BaseException]], excinst: Optional[BaseException], exctb: Optional[TracebackType]\n) -&gt; None:\n\"\"\"Performs cleanup when exiting the scope of a 'with' statement.\"\"\"\nself.close()\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/","title":"pyarrow","text":"<p>FileIO implementation for reading and writing table files that uses pyarrow.fs.</p> <p>This file contains a FileIO implementation that relies on the filesystem interface provided by PyArrow. It relies on PyArrow's <code>from_uri</code> method that infers the correct filesystem type to use. Theoretically, this allows the supported storage types to grow naturally with the pyarrow library.</p>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowFile","title":"<code>PyArrowFile</code>","text":"<p>         Bases: <code>InputFile</code>, <code>OutputFile</code></p> <p>A combined InputFile and OutputFile implementation that uses a pyarrow filesystem to generate pyarrow.lib.NativeFile instances.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>A URI or a path to a local file.</p> required <p>Attributes:</p> Name Type Description <code>location(str)</code> <p>The URI or path to a local file for a PyArrowFile instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyiceberg.io.pyarrow import PyArrowFile\n&gt;&gt;&gt; # input_file = PyArrowFile(\"s3://foo/bar.txt\")\n&gt;&gt;&gt; # Read the contents of the PyArrowFile instance\n&gt;&gt;&gt; # Make sure that you have permissions to read/write\n&gt;&gt;&gt; # file_content = input_file.open().read()\n</code></pre> <pre><code>&gt;&gt;&gt; # output_file = PyArrowFile(\"s3://baz/qux.txt\")\n&gt;&gt;&gt; # Write bytes to a file\n&gt;&gt;&gt; # Make sure that you have permissions to read/write\n&gt;&gt;&gt; # output_file.create().write(b'foobytes')\n</code></pre> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>class PyArrowFile(InputFile, OutputFile):\n\"\"\"A combined InputFile and OutputFile implementation that uses a pyarrow filesystem to generate pyarrow.lib.NativeFile instances.\n    Args:\n        location (str): A URI or a path to a local file.\n    Attributes:\n        location(str): The URI or path to a local file for a PyArrowFile instance.\n    Examples:\n        &gt;&gt;&gt; from pyiceberg.io.pyarrow import PyArrowFile\n        &gt;&gt;&gt; # input_file = PyArrowFile(\"s3://foo/bar.txt\")\n        &gt;&gt;&gt; # Read the contents of the PyArrowFile instance\n        &gt;&gt;&gt; # Make sure that you have permissions to read/write\n        &gt;&gt;&gt; # file_content = input_file.open().read()\n        &gt;&gt;&gt; # output_file = PyArrowFile(\"s3://baz/qux.txt\")\n        &gt;&gt;&gt; # Write bytes to a file\n        &gt;&gt;&gt; # Make sure that you have permissions to read/write\n        &gt;&gt;&gt; # output_file.create().write(b'foobytes')\n    \"\"\"\n_fs: FileSystem\n_path: str\n_buffer_size: int\ndef __init__(self, location: str, path: str, fs: FileSystem, buffer_size: int = ONE_MEGABYTE):\nself._filesystem = fs\nself._path = path\nself._buffer_size = buffer_size\nsuper().__init__(location=location)\ndef _file_info(self) -&gt; FileInfo:\n\"\"\"Retrieves a pyarrow.fs.FileInfo object for the location.\n        Raises:\n            PermissionError: If the file at self.location cannot be accessed due to a permission error such as\n                an AWS error code 15.\n        \"\"\"\ntry:\nfile_info = self._filesystem.get_file_info(self._path)\nexcept OSError as e:\nif e.errno == 13 or \"AWS Error [code 15]\" in str(e):\nraise PermissionError(f\"Cannot get file info, access denied: {self.location}\") from e\nraise  # pragma: no cover - If some other kind of OSError, raise the raw error\nif file_info.type == FileType.NotFound:\nraise FileNotFoundError(f\"Cannot get file info, file not found: {self.location}\")\nreturn file_info\ndef __len__(self) -&gt; int:\n\"\"\"Returns the total length of the file, in bytes.\"\"\"\nfile_info = self._file_info()\nreturn file_info.size\ndef exists(self) -&gt; bool:\n\"\"\"Checks whether the location exists.\"\"\"\ntry:\nself._file_info()  # raises FileNotFoundError if it does not exist\nreturn True\nexcept FileNotFoundError:\nreturn False\ndef open(self, seekable: bool = True) -&gt; InputStream:\n\"\"\"Opens the location using a PyArrow FileSystem inferred from the location.\n        Args:\n            seekable: If the stream should support seek, or if it is consumed sequential.\n        Returns:\n            pyarrow.lib.NativeFile: A NativeFile instance for the file located at `self.location`.\n        Raises:\n            FileNotFoundError: If the file at self.location does not exist.\n            PermissionError: If the file at self.location cannot be accessed due to a permission error such as\n                an AWS error code 15.\n        \"\"\"\ntry:\nif seekable:\ninput_file = self._filesystem.open_input_file(self._path)\nelse:\ninput_file = self._filesystem.open_input_stream(self._path, buffer_size=self._buffer_size)\nexcept FileNotFoundError:\nraise\nexcept PermissionError:\nraise\nexcept OSError as e:\nif e.errno == 2 or \"Path does not exist\" in str(e):\nraise FileNotFoundError(f\"Cannot open file, does not exist: {self.location}\") from e\nelif e.errno == 13 or \"AWS Error [code 15]\" in str(e):\nraise PermissionError(f\"Cannot open file, access denied: {self.location}\") from e\nraise  # pragma: no cover - If some other kind of OSError, raise the raw error\nreturn input_file\ndef create(self, overwrite: bool = False) -&gt; OutputStream:\n\"\"\"Creates a writable pyarrow.lib.NativeFile for this PyArrowFile's location.\n        Args:\n            overwrite (bool): Whether to overwrite the file if it already exists.\n        Returns:\n            pyarrow.lib.NativeFile: A NativeFile instance for the file located at self.location.\n        Raises:\n            FileExistsError: If the file already exists at `self.location` and `overwrite` is False.\n        Note:\n            This retrieves a pyarrow NativeFile by opening an output stream. If overwrite is set to False,\n            a check is first performed to verify that the file does not exist. This is not thread-safe and\n            a possibility does exist that the file can be created by a concurrent process after the existence\n            check yet before the output stream is created. In such a case, the default pyarrow behavior will\n            truncate the contents of the existing file when opening the output stream.\n        \"\"\"\ntry:\nif not overwrite and self.exists() is True:\nraise FileExistsError(f\"Cannot create file, already exists: {self.location}\")\noutput_file = self._filesystem.open_output_stream(self._path, buffer_size=self._buffer_size)\nexcept PermissionError:\nraise\nexcept OSError as e:\nif e.errno == 13 or \"AWS Error [code 15]\" in str(e):\nraise PermissionError(f\"Cannot create file, access denied: {self.location}\") from e\nraise  # pragma: no cover - If some other kind of OSError, raise the raw error\nreturn output_file\ndef to_input_file(self) -&gt; PyArrowFile:\n\"\"\"Returns a new PyArrowFile for the location of an existing PyArrowFile instance.\n        This method is included to abide by the OutputFile abstract base class. Since this implementation uses a single\n        PyArrowFile class (as opposed to separate InputFile and OutputFile implementations), this method effectively returns\n        a copy of the same instance.\n        \"\"\"\nreturn self\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowFile.__len__","title":"<code>__len__()</code>","text":"<p>Returns the total length of the file, in bytes.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Returns the total length of the file, in bytes.\"\"\"\nfile_info = self._file_info()\nreturn file_info.size\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowFile.create","title":"<code>create(overwrite=False)</code>","text":"<p>Creates a writable pyarrow.lib.NativeFile for this PyArrowFile's location.</p> <p>Parameters:</p> Name Type Description Default <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the file if it already exists.</p> <code>False</code> <p>Returns:</p> Type Description <code>OutputStream</code> <p>pyarrow.lib.NativeFile: A NativeFile instance for the file located at self.location.</p> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If the file already exists at <code>self.location</code> and <code>overwrite</code> is False.</p> Note <p>This retrieves a pyarrow NativeFile by opening an output stream. If overwrite is set to False, a check is first performed to verify that the file does not exist. This is not thread-safe and a possibility does exist that the file can be created by a concurrent process after the existence check yet before the output stream is created. In such a case, the default pyarrow behavior will truncate the contents of the existing file when opening the output stream.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>def create(self, overwrite: bool = False) -&gt; OutputStream:\n\"\"\"Creates a writable pyarrow.lib.NativeFile for this PyArrowFile's location.\n    Args:\n        overwrite (bool): Whether to overwrite the file if it already exists.\n    Returns:\n        pyarrow.lib.NativeFile: A NativeFile instance for the file located at self.location.\n    Raises:\n        FileExistsError: If the file already exists at `self.location` and `overwrite` is False.\n    Note:\n        This retrieves a pyarrow NativeFile by opening an output stream. If overwrite is set to False,\n        a check is first performed to verify that the file does not exist. This is not thread-safe and\n        a possibility does exist that the file can be created by a concurrent process after the existence\n        check yet before the output stream is created. In such a case, the default pyarrow behavior will\n        truncate the contents of the existing file when opening the output stream.\n    \"\"\"\ntry:\nif not overwrite and self.exists() is True:\nraise FileExistsError(f\"Cannot create file, already exists: {self.location}\")\noutput_file = self._filesystem.open_output_stream(self._path, buffer_size=self._buffer_size)\nexcept PermissionError:\nraise\nexcept OSError as e:\nif e.errno == 13 or \"AWS Error [code 15]\" in str(e):\nraise PermissionError(f\"Cannot create file, access denied: {self.location}\") from e\nraise  # pragma: no cover - If some other kind of OSError, raise the raw error\nreturn output_file\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowFile.exists","title":"<code>exists()</code>","text":"<p>Checks whether the location exists.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>def exists(self) -&gt; bool:\n\"\"\"Checks whether the location exists.\"\"\"\ntry:\nself._file_info()  # raises FileNotFoundError if it does not exist\nreturn True\nexcept FileNotFoundError:\nreturn False\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowFile.open","title":"<code>open(seekable=True)</code>","text":"<p>Opens the location using a PyArrow FileSystem inferred from the location.</p> <p>Parameters:</p> Name Type Description Default <code>seekable</code> <code>bool</code> <p>If the stream should support seek, or if it is consumed sequential.</p> <code>True</code> <p>Returns:</p> Type Description <code>InputStream</code> <p>pyarrow.lib.NativeFile: A NativeFile instance for the file located at <code>self.location</code>.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file at self.location does not exist.</p> <code>PermissionError</code> <p>If the file at self.location cannot be accessed due to a permission error such as an AWS error code 15.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>def open(self, seekable: bool = True) -&gt; InputStream:\n\"\"\"Opens the location using a PyArrow FileSystem inferred from the location.\n    Args:\n        seekable: If the stream should support seek, or if it is consumed sequential.\n    Returns:\n        pyarrow.lib.NativeFile: A NativeFile instance for the file located at `self.location`.\n    Raises:\n        FileNotFoundError: If the file at self.location does not exist.\n        PermissionError: If the file at self.location cannot be accessed due to a permission error such as\n            an AWS error code 15.\n    \"\"\"\ntry:\nif seekable:\ninput_file = self._filesystem.open_input_file(self._path)\nelse:\ninput_file = self._filesystem.open_input_stream(self._path, buffer_size=self._buffer_size)\nexcept FileNotFoundError:\nraise\nexcept PermissionError:\nraise\nexcept OSError as e:\nif e.errno == 2 or \"Path does not exist\" in str(e):\nraise FileNotFoundError(f\"Cannot open file, does not exist: {self.location}\") from e\nelif e.errno == 13 or \"AWS Error [code 15]\" in str(e):\nraise PermissionError(f\"Cannot open file, access denied: {self.location}\") from e\nraise  # pragma: no cover - If some other kind of OSError, raise the raw error\nreturn input_file\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowFile.to_input_file","title":"<code>to_input_file()</code>","text":"<p>Returns a new PyArrowFile for the location of an existing PyArrowFile instance.</p> <p>This method is included to abide by the OutputFile abstract base class. Since this implementation uses a single PyArrowFile class (as opposed to separate InputFile and OutputFile implementations), this method effectively returns a copy of the same instance.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>def to_input_file(self) -&gt; PyArrowFile:\n\"\"\"Returns a new PyArrowFile for the location of an existing PyArrowFile instance.\n    This method is included to abide by the OutputFile abstract base class. Since this implementation uses a single\n    PyArrowFile class (as opposed to separate InputFile and OutputFile implementations), this method effectively returns\n    a copy of the same instance.\n    \"\"\"\nreturn self\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowFileIO","title":"<code>PyArrowFileIO</code>","text":"<p>         Bases: <code>FileIO</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>class PyArrowFileIO(FileIO):\ndef __init__(self, properties: Properties = EMPTY_DICT):\nself.get_fs: Callable[[str], FileSystem] = lru_cache(self._get_fs)\nsuper().__init__(properties=properties)\n@staticmethod\ndef parse_location(location: str) -&gt; Tuple[str, str]:\n\"\"\"Returns the path without the scheme.\"\"\"\nuri = urlparse(location)\nreturn uri.scheme or \"file\", os.path.abspath(location) if not uri.scheme else f\"{uri.netloc}{uri.path}\"\ndef _get_fs(self, scheme: str) -&gt; FileSystem:\nif scheme in {\"s3\", \"s3a\", \"s3n\"}:\nclient_kwargs = {\n\"endpoint_override\": self.properties.get(S3_ENDPOINT),\n\"access_key\": self.properties.get(S3_ACCESS_KEY_ID),\n\"secret_key\": self.properties.get(S3_SECRET_ACCESS_KEY),\n\"session_token\": self.properties.get(S3_SESSION_TOKEN),\n\"region\": self.properties.get(S3_REGION),\n}\nreturn S3FileSystem(**client_kwargs)\nelif scheme == \"file\":\nreturn LocalFileSystem()\nelse:\nraise ValueError(f\"Unrecognized filesystem type in URI: {scheme}\")\ndef new_input(self, location: str) -&gt; PyArrowFile:\n\"\"\"Get a PyArrowFile instance to read bytes from the file at the given location.\n        Args:\n            location (str): A URI or a path to a local file.\n        Returns:\n            PyArrowFile: A PyArrowFile instance for the given location.\n        \"\"\"\nscheme, path = self.parse_location(location)\nfs = self._get_fs(scheme)\nreturn PyArrowFile(fs=fs, location=location, path=path, buffer_size=int(self.properties.get(BUFFER_SIZE, ONE_MEGABYTE)))\ndef new_output(self, location: str) -&gt; PyArrowFile:\n\"\"\"Get a PyArrowFile instance to write bytes to the file at the given location.\n        Args:\n            location (str): A URI or a path to a local file.\n        Returns:\n            PyArrowFile: A PyArrowFile instance for the given location.\n        \"\"\"\nscheme, path = self.parse_location(location)\nfs = self._get_fs(scheme)\nreturn PyArrowFile(fs=fs, location=location, path=path, buffer_size=int(self.properties.get(BUFFER_SIZE, ONE_MEGABYTE)))\ndef delete(self, location: Union[str, InputFile, OutputFile]) -&gt; None:\n\"\"\"Delete the file at the given location.\n        Args:\n            location (Union[str, InputFile, OutputFile]): The URI to the file--if an InputFile instance or an OutputFile instance is provided,\n                the location attribute for that instance is used as the location to delete.\n        Raises:\n            FileNotFoundError: When the file at the provided location does not exist.\n            PermissionError: If the file at the provided location cannot be accessed due to a permission error such as\n                an AWS error code 15.\n        \"\"\"\nstr_location = location.location if isinstance(location, (InputFile, OutputFile)) else location\nscheme, path = self.parse_location(str_location)\nfs = self._get_fs(scheme)\ntry:\nfs.delete_file(path)\nexcept FileNotFoundError:\nraise\nexcept PermissionError:\nraise\nexcept OSError as e:\nif e.errno == 2 or \"Path does not exist\" in str(e):\nraise FileNotFoundError(f\"Cannot delete file, does not exist: {location}\") from e\nelif e.errno == 13 or \"AWS Error [code 15]\" in str(e):\nraise PermissionError(f\"Cannot delete file, access denied: {location}\") from e\nraise  # pragma: no cover - If some other kind of OSError, raise the raw error\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowFileIO.delete","title":"<code>delete(location)</code>","text":"<p>Delete the file at the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Union[str, InputFile, OutputFile]</code> <p>The URI to the file--if an InputFile instance or an OutputFile instance is provided, the location attribute for that instance is used as the location to delete.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>When the file at the provided location does not exist.</p> <code>PermissionError</code> <p>If the file at the provided location cannot be accessed due to a permission error such as an AWS error code 15.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>def delete(self, location: Union[str, InputFile, OutputFile]) -&gt; None:\n\"\"\"Delete the file at the given location.\n    Args:\n        location (Union[str, InputFile, OutputFile]): The URI to the file--if an InputFile instance or an OutputFile instance is provided,\n            the location attribute for that instance is used as the location to delete.\n    Raises:\n        FileNotFoundError: When the file at the provided location does not exist.\n        PermissionError: If the file at the provided location cannot be accessed due to a permission error such as\n            an AWS error code 15.\n    \"\"\"\nstr_location = location.location if isinstance(location, (InputFile, OutputFile)) else location\nscheme, path = self.parse_location(str_location)\nfs = self._get_fs(scheme)\ntry:\nfs.delete_file(path)\nexcept FileNotFoundError:\nraise\nexcept PermissionError:\nraise\nexcept OSError as e:\nif e.errno == 2 or \"Path does not exist\" in str(e):\nraise FileNotFoundError(f\"Cannot delete file, does not exist: {location}\") from e\nelif e.errno == 13 or \"AWS Error [code 15]\" in str(e):\nraise PermissionError(f\"Cannot delete file, access denied: {location}\") from e\nraise  # pragma: no cover - If some other kind of OSError, raise the raw error\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowFileIO.new_input","title":"<code>new_input(location)</code>","text":"<p>Get a PyArrowFile instance to read bytes from the file at the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>A URI or a path to a local file.</p> required <p>Returns:</p> Name Type Description <code>PyArrowFile</code> <code>PyArrowFile</code> <p>A PyArrowFile instance for the given location.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>def new_input(self, location: str) -&gt; PyArrowFile:\n\"\"\"Get a PyArrowFile instance to read bytes from the file at the given location.\n    Args:\n        location (str): A URI or a path to a local file.\n    Returns:\n        PyArrowFile: A PyArrowFile instance for the given location.\n    \"\"\"\nscheme, path = self.parse_location(location)\nfs = self._get_fs(scheme)\nreturn PyArrowFile(fs=fs, location=location, path=path, buffer_size=int(self.properties.get(BUFFER_SIZE, ONE_MEGABYTE)))\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowFileIO.new_output","title":"<code>new_output(location)</code>","text":"<p>Get a PyArrowFile instance to write bytes to the file at the given location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>A URI or a path to a local file.</p> required <p>Returns:</p> Name Type Description <code>PyArrowFile</code> <code>PyArrowFile</code> <p>A PyArrowFile instance for the given location.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>def new_output(self, location: str) -&gt; PyArrowFile:\n\"\"\"Get a PyArrowFile instance to write bytes to the file at the given location.\n    Args:\n        location (str): A URI or a path to a local file.\n    Returns:\n        PyArrowFile: A PyArrowFile instance for the given location.\n    \"\"\"\nscheme, path = self.parse_location(location)\nfs = self._get_fs(scheme)\nreturn PyArrowFile(fs=fs, location=location, path=path, buffer_size=int(self.properties.get(BUFFER_SIZE, ONE_MEGABYTE)))\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowFileIO.parse_location","title":"<code>parse_location(location)</code>  <code>staticmethod</code>","text":"<p>Returns the path without the scheme.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>@staticmethod\ndef parse_location(location: str) -&gt; Tuple[str, str]:\n\"\"\"Returns the path without the scheme.\"\"\"\nuri = urlparse(location)\nreturn uri.scheme or \"file\", os.path.abspath(location) if not uri.scheme else f\"{uri.netloc}{uri.path}\"\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowSchemaVisitor","title":"<code>PyArrowSchemaVisitor</code>","text":"<p>         Bases: <code>Generic[T]</code>, <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>class PyArrowSchemaVisitor(Generic[T], ABC):\ndef before_field(self, field: pa.Field) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting a field.\"\"\"\ndef after_field(self, field: pa.Field) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting a field.\"\"\"\n@abstractmethod\ndef schema(self, schema: pa.Schema, field_results: List[Optional[T]]) -&gt; Optional[T]:\n\"\"\"Visit a schema.\"\"\"\n@abstractmethod\ndef struct(self, struct: pa.StructType, field_results: List[Optional[T]]) -&gt; Optional[T]:\n\"\"\"Visit a struct.\"\"\"\n@abstractmethod\ndef list(self, list_type: pa.ListType, element_result: Optional[T]) -&gt; Optional[T]:\n\"\"\"Visit a list.\"\"\"\n@abstractmethod\ndef map(self, map_type: pa.MapType, key_result: Optional[T], value_result: Optional[T]) -&gt; Optional[T]:\n\"\"\"Visit a map.\"\"\"\n@abstractmethod\ndef primitive(self, primitive: pa.DataType) -&gt; Optional[T]:\n\"\"\"Visit a primitive type.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowSchemaVisitor.after_field","title":"<code>after_field(field)</code>","text":"<p>Override this method to perform an action immediately after visiting a field.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>def after_field(self, field: pa.Field) -&gt; None:\n\"\"\"Override this method to perform an action immediately after visiting a field.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowSchemaVisitor.before_field","title":"<code>before_field(field)</code>","text":"<p>Override this method to perform an action immediately before visiting a field.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>def before_field(self, field: pa.Field) -&gt; None:\n\"\"\"Override this method to perform an action immediately before visiting a field.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowSchemaVisitor.list","title":"<code>list(list_type, element_result)</code>  <code>abstractmethod</code>","text":"<p>Visit a list.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>@abstractmethod\ndef list(self, list_type: pa.ListType, element_result: Optional[T]) -&gt; Optional[T]:\n\"\"\"Visit a list.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowSchemaVisitor.map","title":"<code>map(map_type, key_result, value_result)</code>  <code>abstractmethod</code>","text":"<p>Visit a map.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>@abstractmethod\ndef map(self, map_type: pa.MapType, key_result: Optional[T], value_result: Optional[T]) -&gt; Optional[T]:\n\"\"\"Visit a map.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowSchemaVisitor.primitive","title":"<code>primitive(primitive)</code>  <code>abstractmethod</code>","text":"<p>Visit a primitive type.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>@abstractmethod\ndef primitive(self, primitive: pa.DataType) -&gt; Optional[T]:\n\"\"\"Visit a primitive type.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowSchemaVisitor.schema","title":"<code>schema(schema, field_results)</code>  <code>abstractmethod</code>","text":"<p>Visit a schema.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>@abstractmethod\ndef schema(self, schema: pa.Schema, field_results: List[Optional[T]]) -&gt; Optional[T]:\n\"\"\"Visit a schema.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.PyArrowSchemaVisitor.struct","title":"<code>struct(struct, field_results)</code>  <code>abstractmethod</code>","text":"<p>Visit a struct.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>@abstractmethod\ndef struct(self, struct: pa.StructType, field_results: List[Optional[T]]) -&gt; Optional[T]:\n\"\"\"Visit a struct.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.project_table","title":"<code>project_table(tasks, table, row_filter, projected_schema, case_sensitive=True, limit=None)</code>","text":"<p>Resolves the right columns based on the identifier.</p> <p>Parameters:</p> Name Type Description Default <code>tasks</code> <code>Iterable[FileScanTask]</code> <p>A URI or a path to a local file.</p> required <code>table</code> <code>Table</code> <p>The table that's being queried.</p> required <code>row_filter</code> <code>BooleanExpression</code> <p>The expression for filtering rows.</p> required <code>projected_schema</code> <code>Schema</code> <p>The output schema.</p> required <code>case_sensitive</code> <code>bool</code> <p>Case sensitivity when looking up column names.</p> <code>True</code> <code>limit</code> <code>Optional[int]</code> <p>Limit the number of records.</p> <code>None</code> <p>Raises:</p> Type Description <code>ResolveError</code> <p>When an incompatible query is done.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>def project_table(\ntasks: Iterable[FileScanTask],\ntable: Table,\nrow_filter: BooleanExpression,\nprojected_schema: Schema,\ncase_sensitive: bool = True,\nlimit: Optional[int] = None,\n) -&gt; pa.Table:\n\"\"\"Resolves the right columns based on the identifier.\n    Args:\n        tasks (Iterable[FileScanTask]): A URI or a path to a local file.\n        table (Table): The table that's being queried.\n        row_filter (BooleanExpression): The expression for filtering rows.\n        projected_schema (Schema): The output schema.\n        case_sensitive (bool): Case sensitivity when looking up column names.\n        limit (Optional[int]): Limit the number of records.\n    Raises:\n        ResolveError: When an incompatible query is done.\n    \"\"\"\nscheme, _ = PyArrowFileIO.parse_location(table.location())\nif isinstance(table.io, PyArrowFileIO):\nfs = table.io.get_fs(scheme)\nelse:\ntry:\nfrom pyiceberg.io.fsspec import FsspecFileIO\nif isinstance(table.io, FsspecFileIO):\nfs = PyFileSystem(FSSpecHandler(table.io.get_fs(scheme)))\nelse:\nraise ValueError(f\"Expected PyArrowFileIO or FsspecFileIO, got: {table.io}\")\nexcept ModuleNotFoundError as e:\n# When FsSpec is not installed\nraise ValueError(f\"Expected PyArrowFileIO or FsspecFileIO, got: {table.io}\") from e\nbound_row_filter = bind(table.schema(), row_filter, case_sensitive=case_sensitive)\nprojected_field_ids = {\nid for id in projected_schema.field_ids if not isinstance(projected_schema.find_type(id), (MapType, ListType))\n}.union(extract_field_ids(bound_row_filter))\nrows_counter = multiprocessing.Value(\"i\", 0)\nwith ThreadPool() as pool:\ndeletes_per_file = _read_all_delete_files(fs, pool, tasks)\ntables = [\ntable\nfor table in pool.starmap(\nfunc=_task_to_table,\niterable=[\n(\nfs,\ntask,\nbound_row_filter,\nprojected_schema,\nprojected_field_ids,\ndeletes_per_file.get(task.file.file_path),\ncase_sensitive,\nrows_counter,\nlimit,\n)\nfor task in tasks\n],\n)\nif table is not None\n]\nif len(tables) &gt; 1:\nfinal_table = pa.concat_tables(tables)\nelif len(tables) == 1:\nfinal_table = tables[0]\nelse:\nfinal_table = pa.Table.from_batches([], schema=schema_to_pyarrow(projected_schema))\nreturn final_table.slice(0, limit)\n</code></pre>"},{"location":"reference/pyiceberg/io/pyarrow/#pyiceberg.io.pyarrow.visit_pyarrow","title":"<code>visit_pyarrow(obj, visitor)</code>","text":"<p>A generic function for applying a pyarrow schema visitor to any point within a schema.</p> <p>The function traverses the schema in post-order fashion.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[pa.DataType, pa.Schema]</code> <p>An instance of a Schema or an IcebergType.</p> required <code>visitor</code> <code>PyArrowSchemaVisitor[T]</code> <p>An instance of an implementation of the generic PyarrowSchemaVisitor base class.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If attempting to visit an unrecognized object type.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/io/pyarrow.py</code> <pre><code>@singledispatch\ndef visit_pyarrow(obj: Union[pa.DataType, pa.Schema], visitor: PyArrowSchemaVisitor[T]) -&gt; T:\n\"\"\"A generic function for applying a pyarrow schema visitor to any point within a schema.\n    The function traverses the schema in post-order fashion.\n    Args:\n        obj (Union[pa.DataType, pa.Schema]): An instance of a Schema or an IcebergType.\n        visitor (PyArrowSchemaVisitor[T]): An instance of an implementation of the generic PyarrowSchemaVisitor base class.\n    Raises:\n        NotImplementedError: If attempting to visit an unrecognized object type.\n    \"\"\"\nraise NotImplementedError(\"Cannot visit non-type: %s\" % obj)\n</code></pre>"},{"location":"reference/pyiceberg/table/","title":"table","text":""},{"location":"reference/pyiceberg/table/#pyiceberg.table.AssertCreate","title":"<code>AssertCreate</code>","text":"<p>         Bases: <code>TableRequirement</code></p> <p>The table must not already exist; used for create transactions.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>class AssertCreate(TableRequirement):\n\"\"\"The table must not already exist; used for create transactions.\"\"\"\ntype: Literal[\"assert-create\"]\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.AssertCurrentSchemaId","title":"<code>AssertCurrentSchemaId</code>","text":"<p>         Bases: <code>TableRequirement</code></p> <p>The table's current schema id must match the requirement's <code>current-schema-id</code>.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>class AssertCurrentSchemaId(TableRequirement):\n\"\"\"The table's current schema id must match the requirement's `current-schema-id`.\"\"\"\ntype: Literal[\"assert-current-schema-id\"]\ncurrent_schema_id: int = Field(..., alias=\"current-schema-id\")\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.AssertDefaultSortOrderId","title":"<code>AssertDefaultSortOrderId</code>","text":"<p>         Bases: <code>TableRequirement</code></p> <p>The table's default sort order id must match the requirement's <code>default-sort-order-id</code>.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>class AssertDefaultSortOrderId(TableRequirement):\n\"\"\"The table's default sort order id must match the requirement's `default-sort-order-id`.\"\"\"\ntype: Literal[\"assert-default-sort-order-id\"]\ndefault_sort_order_id: int = Field(..., alias=\"default-sort-order-id\")\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.AssertDefaultSpecId","title":"<code>AssertDefaultSpecId</code>","text":"<p>         Bases: <code>TableRequirement</code></p> <p>The table's default spec id must match the requirement's <code>default-spec-id</code>.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>class AssertDefaultSpecId(TableRequirement):\n\"\"\"The table's default spec id must match the requirement's `default-spec-id`.\"\"\"\ntype: Literal[\"assert-default-spec-id\"]\ndefault_spec_id: int = Field(..., alias=\"default-spec-id\")\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.AssertLastAssignedFieldId","title":"<code>AssertLastAssignedFieldId</code>","text":"<p>         Bases: <code>TableRequirement</code></p> <p>The table's last assigned column id must match the requirement's <code>last-assigned-field-id</code>.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>class AssertLastAssignedFieldId(TableRequirement):\n\"\"\"The table's last assigned column id must match the requirement's `last-assigned-field-id`.\"\"\"\ntype: Literal[\"assert-last-assigned-field-id\"]\nlast_assigned_field_id: int = Field(..., alias=\"last-assigned-field-id\")\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.AssertLastAssignedPartitionId","title":"<code>AssertLastAssignedPartitionId</code>","text":"<p>         Bases: <code>TableRequirement</code></p> <p>The table's last assigned partition id must match the requirement's <code>last-assigned-partition-id</code>.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>class AssertLastAssignedPartitionId(TableRequirement):\n\"\"\"The table's last assigned partition id must match the requirement's `last-assigned-partition-id`.\"\"\"\ntype: Literal[\"assert-last-assigned-partition-id\"]\nlast_assigned_partition_id: int = Field(..., alias=\"last-assigned-partition-id\")\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.AssertRefSnapshotId","title":"<code>AssertRefSnapshotId</code>","text":"<p>         Bases: <code>TableRequirement</code></p> <p>The table branch or tag identified by the requirement's <code>ref</code> must reference the requirement's <code>snapshot-id</code>.</p> <p>if <code>snapshot-id</code> is <code>null</code> or missing, the ref must not already exist.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>class AssertRefSnapshotId(TableRequirement):\n\"\"\"The table branch or tag identified by the requirement's `ref` must reference the requirement's `snapshot-id`.\n    if `snapshot-id` is `null` or missing, the ref must not already exist.\n    \"\"\"\ntype: Literal[\"assert-ref-snapshot-id\"]\nref: str\nsnapshot_id: int = Field(..., alias=\"snapshot-id\")\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.AssertTableUUID","title":"<code>AssertTableUUID</code>","text":"<p>         Bases: <code>TableRequirement</code></p> <p>The table UUID must match the requirement's <code>uuid</code>.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>class AssertTableUUID(TableRequirement):\n\"\"\"The table UUID must match the requirement's `uuid`.\"\"\"\ntype: Literal[\"assert-table-uuid\"]\nuuid: str\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.DataScan","title":"<code>DataScan</code>","text":"<p>         Bases: <code>TableScan</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>class DataScan(TableScan):\ndef __init__(\nself,\ntable: Table,\nrow_filter: Union[str, BooleanExpression] = ALWAYS_TRUE,\nselected_fields: Tuple[str, ...] = (\"*\",),\ncase_sensitive: bool = True,\nsnapshot_id: Optional[int] = None,\noptions: Properties = EMPTY_DICT,\nlimit: Optional[int] = None,\n):\nsuper().__init__(table, row_filter, selected_fields, case_sensitive, snapshot_id, options, limit)\ndef _build_partition_projection(self, spec_id: int) -&gt; BooleanExpression:\nproject = inclusive_projection(self.table.schema(), self.table.specs()[spec_id])\nreturn project(self.row_filter)\n@cached_property\ndef partition_filters(self) -&gt; KeyDefaultDict[int, BooleanExpression]:\nreturn KeyDefaultDict(self._build_partition_projection)\ndef _build_manifest_evaluator(self, spec_id: int) -&gt; Callable[[ManifestFile], bool]:\nspec = self.table.specs()[spec_id]\nreturn visitors.manifest_evaluator(spec, self.table.schema(), self.partition_filters[spec_id], self.case_sensitive)\ndef _build_partition_evaluator(self, spec_id: int) -&gt; Callable[[DataFile], bool]:\nspec = self.table.specs()[spec_id]\npartition_type = spec.partition_type(self.table.schema())\npartition_schema = Schema(*partition_type.fields)\npartition_expr = self.partition_filters[spec_id]\nevaluator = visitors.expression_evaluator(partition_schema, partition_expr, self.case_sensitive)\nreturn lambda data_file: evaluator(data_file.partition)\ndef _check_sequence_number(self, min_data_sequence_number: int, manifest: ManifestFile) -&gt; bool:\n\"\"\"A helper function to make sure that no manifests are loaded that contain deletes that are older than the data.\n        Args:\n            min_data_sequence_number (int): The minimal sequence number.\n            manifest (ManifestFile): A ManifestFile that can be either data or deletes.\n        Returns:\n            Boolean indicating if it is either a data file, or a relevant delete file.\n        \"\"\"\nreturn manifest.content == ManifestContent.DATA or (\n# Not interested in deletes that are older than the data\nmanifest.content == ManifestContent.DELETES\nand (manifest.sequence_number or INITIAL_SEQUENCE_NUMBER) &gt;= min_data_sequence_number\n)\ndef plan_files(self) -&gt; Iterable[FileScanTask]:\n\"\"\"Plans the relevant files by filtering on the PartitionSpecs.\n        Returns:\n            List of FileScanTasks that contain both data and delete files.\n        \"\"\"\nsnapshot = self.snapshot()\nif not snapshot:\nreturn iter([])\nio = self.table.io\n# step 1: filter manifests using partition summaries\n# the filter depends on the partition spec used to write the manifest file, so create a cache of filters for each spec id\nmanifest_evaluators: Dict[int, Callable[[ManifestFile], bool]] = KeyDefaultDict(self._build_manifest_evaluator)\nmanifests = [\nmanifest_file\nfor manifest_file in snapshot.manifests(io)\nif manifest_evaluators[manifest_file.partition_spec_id](manifest_file)\n]\n# step 2: filter the data files in each manifest\n# this filter depends on the partition spec used to write the manifest file\npartition_evaluators: Dict[int, Callable[[DataFile], bool]] = KeyDefaultDict(self._build_partition_evaluator)\nmetrics_evaluator = _InclusiveMetricsEvaluator(self.table.schema(), self.row_filter, self.case_sensitive).eval\nmin_data_sequence_number = _min_data_file_sequence_number(manifests)\ndata_entries: List[ManifestEntry] = []\npositional_delete_entries = SortedList(key=lambda entry: entry.data_sequence_number or INITIAL_SEQUENCE_NUMBER)\nwith ThreadPool() as pool:\nfor manifest_entry in chain(\n*pool.starmap(\nfunc=_open_manifest,\niterable=[\n(\nio,\nmanifest,\npartition_evaluators[manifest.partition_spec_id],\nmetrics_evaluator,\n)\nfor manifest in manifests\nif self._check_sequence_number(min_data_sequence_number, manifest)\n],\n)\n):\ndata_file = manifest_entry.data_file\nif data_file.content == DataFileContent.DATA:\ndata_entries.append(manifest_entry)\nelif data_file.content == DataFileContent.POSITION_DELETES:\npositional_delete_entries.add(manifest_entry)\nelif data_file.content == DataFileContent.EQUALITY_DELETES:\nraise ValueError(\n\"PyIceberg does not yet support equality deletes: https://github.com/apache/iceberg/issues/6568\"\n)\nelse:\nraise ValueError(f\"Unknown DataFileContent ({data_file.content}): {manifest_entry}\")\nreturn [\nFileScanTask(\ndata_entry.data_file,\ndelete_files=_match_deletes_to_datafile(\ndata_entry,\npositional_delete_entries,\n),\n)\nfor data_entry in data_entries\n]\ndef to_arrow(self) -&gt; pa.Table:\nfrom pyiceberg.io.pyarrow import project_table\nreturn project_table(\nself.plan_files(),\nself.table,\nself.row_filter,\nself.projection(),\ncase_sensitive=self.case_sensitive,\nlimit=self.limit,\n)\ndef to_pandas(self, **kwargs: Any) -&gt; pd.DataFrame:\nreturn self.to_arrow().to_pandas(**kwargs)\ndef to_duckdb(self, table_name: str, connection: Optional[DuckDBPyConnection] = None) -&gt; DuckDBPyConnection:\nimport duckdb\ncon = connection or duckdb.connect(database=\":memory:\")\ncon.register(table_name, self.to_arrow())\nreturn con\ndef to_ray(self) -&gt; ray.data.dataset.Dataset:\nimport ray\nreturn ray.data.from_arrow(self.to_arrow())\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.DataScan.plan_files","title":"<code>plan_files()</code>","text":"<p>Plans the relevant files by filtering on the PartitionSpecs.</p> <p>Returns:</p> Type Description <code>Iterable[FileScanTask]</code> <p>List of FileScanTasks that contain both data and delete files.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def plan_files(self) -&gt; Iterable[FileScanTask]:\n\"\"\"Plans the relevant files by filtering on the PartitionSpecs.\n    Returns:\n        List of FileScanTasks that contain both data and delete files.\n    \"\"\"\nsnapshot = self.snapshot()\nif not snapshot:\nreturn iter([])\nio = self.table.io\n# step 1: filter manifests using partition summaries\n# the filter depends on the partition spec used to write the manifest file, so create a cache of filters for each spec id\nmanifest_evaluators: Dict[int, Callable[[ManifestFile], bool]] = KeyDefaultDict(self._build_manifest_evaluator)\nmanifests = [\nmanifest_file\nfor manifest_file in snapshot.manifests(io)\nif manifest_evaluators[manifest_file.partition_spec_id](manifest_file)\n]\n# step 2: filter the data files in each manifest\n# this filter depends on the partition spec used to write the manifest file\npartition_evaluators: Dict[int, Callable[[DataFile], bool]] = KeyDefaultDict(self._build_partition_evaluator)\nmetrics_evaluator = _InclusiveMetricsEvaluator(self.table.schema(), self.row_filter, self.case_sensitive).eval\nmin_data_sequence_number = _min_data_file_sequence_number(manifests)\ndata_entries: List[ManifestEntry] = []\npositional_delete_entries = SortedList(key=lambda entry: entry.data_sequence_number or INITIAL_SEQUENCE_NUMBER)\nwith ThreadPool() as pool:\nfor manifest_entry in chain(\n*pool.starmap(\nfunc=_open_manifest,\niterable=[\n(\nio,\nmanifest,\npartition_evaluators[manifest.partition_spec_id],\nmetrics_evaluator,\n)\nfor manifest in manifests\nif self._check_sequence_number(min_data_sequence_number, manifest)\n],\n)\n):\ndata_file = manifest_entry.data_file\nif data_file.content == DataFileContent.DATA:\ndata_entries.append(manifest_entry)\nelif data_file.content == DataFileContent.POSITION_DELETES:\npositional_delete_entries.add(manifest_entry)\nelif data_file.content == DataFileContent.EQUALITY_DELETES:\nraise ValueError(\n\"PyIceberg does not yet support equality deletes: https://github.com/apache/iceberg/issues/6568\"\n)\nelse:\nraise ValueError(f\"Unknown DataFileContent ({data_file.content}): {manifest_entry}\")\nreturn [\nFileScanTask(\ndata_entry.data_file,\ndelete_files=_match_deletes_to_datafile(\ndata_entry,\npositional_delete_entries,\n),\n)\nfor data_entry in data_entries\n]\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.StaticTable","title":"<code>StaticTable</code>","text":"<p>         Bases: <code>Table</code></p> <p>Load a table directly from a metadata file (i.e., without using a catalog).</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>class StaticTable(Table):\n\"\"\"Load a table directly from a metadata file (i.e., without using a catalog).\"\"\"\ndef refresh(self) -&gt; Table:\n\"\"\"Refresh the current table metadata.\"\"\"\nraise NotImplementedError(\"To be implemented\")\n@classmethod\ndef from_metadata(cls, metadata_location: str, properties: Properties = EMPTY_DICT) -&gt; StaticTable:\nio = load_file_io(properties=properties, location=metadata_location)\nfile = io.new_input(metadata_location)\nfrom pyiceberg.serializers import FromInputFile\nmetadata = FromInputFile.table_metadata(file)\nfrom pyiceberg.catalog.noop import NoopCatalog\nreturn cls(\nidentifier=(\"static-table\", metadata_location),\nmetadata_location=metadata_location,\nmetadata=metadata,\nio=load_file_io({**properties, **metadata.properties}),\ncatalog=NoopCatalog(\"static-table\"),\n)\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.StaticTable.refresh","title":"<code>refresh()</code>","text":"<p>Refresh the current table metadata.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def refresh(self) -&gt; Table:\n\"\"\"Refresh the current table metadata.\"\"\"\nraise NotImplementedError(\"To be implemented\")\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Table","title":"<code>Table</code>","text":"Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>class Table:\nidentifier: Identifier = Field()\nmetadata: TableMetadata = Field()\nmetadata_location: str = Field()\nio: FileIO\ncatalog: Catalog\ndef __init__(\nself, identifier: Identifier, metadata: TableMetadata, metadata_location: str, io: FileIO, catalog: Catalog\n) -&gt; None:\nself.identifier = identifier\nself.metadata = metadata\nself.metadata_location = metadata_location\nself.io = io\nself.catalog = catalog\ndef transaction(self) -&gt; Transaction:\nreturn Transaction(self)\ndef refresh(self) -&gt; Table:\n\"\"\"Refresh the current table metadata.\"\"\"\nfresh = self.catalog.load_table(self.identifier[1:])\nself.metadata = fresh.metadata\nself.io = fresh.io\nself.metadata_location = fresh.metadata_location\nreturn self\ndef name(self) -&gt; Identifier:\n\"\"\"Return the identifier of this table.\"\"\"\nreturn self.identifier\ndef scan(\nself,\nrow_filter: Union[str, BooleanExpression] = ALWAYS_TRUE,\nselected_fields: Tuple[str, ...] = (\"*\",),\ncase_sensitive: bool = True,\nsnapshot_id: Optional[int] = None,\noptions: Properties = EMPTY_DICT,\nlimit: Optional[int] = None,\n) -&gt; DataScan:\nreturn DataScan(\ntable=self,\nrow_filter=row_filter,\nselected_fields=selected_fields,\ncase_sensitive=case_sensitive,\nsnapshot_id=snapshot_id,\noptions=options,\nlimit=limit,\n)\ndef schema(self) -&gt; Schema:\n\"\"\"Return the schema for this table.\"\"\"\nreturn next(schema for schema in self.metadata.schemas if schema.schema_id == self.metadata.current_schema_id)\ndef schemas(self) -&gt; Dict[int, Schema]:\n\"\"\"Return a dict of the schema of this table.\"\"\"\nreturn {schema.schema_id: schema for schema in self.metadata.schemas}\ndef spec(self) -&gt; PartitionSpec:\n\"\"\"Return the partition spec of this table.\"\"\"\nreturn next(spec for spec in self.metadata.partition_specs if spec.spec_id == self.metadata.default_spec_id)\ndef specs(self) -&gt; Dict[int, PartitionSpec]:\n\"\"\"Return a dict the partition specs this table.\"\"\"\nreturn {spec.spec_id: spec for spec in self.metadata.partition_specs}\ndef sort_order(self) -&gt; SortOrder:\n\"\"\"Return the sort order of this table.\"\"\"\nreturn next(\nsort_order for sort_order in self.metadata.sort_orders if sort_order.order_id == self.metadata.default_sort_order_id\n)\ndef sort_orders(self) -&gt; Dict[int, SortOrder]:\n\"\"\"Return a dict of the sort orders of this table.\"\"\"\nreturn {sort_order.order_id: sort_order for sort_order in self.metadata.sort_orders}\n@property\ndef properties(self) -&gt; Dict[str, str]:\n\"\"\"Properties of the table.\"\"\"\nreturn self.metadata.properties\ndef location(self) -&gt; str:\n\"\"\"Return the table's base location.\"\"\"\nreturn self.metadata.location\ndef current_snapshot(self) -&gt; Optional[Snapshot]:\n\"\"\"Get the current snapshot for this table, or None if there is no current snapshot.\"\"\"\nif snapshot_id := self.metadata.current_snapshot_id:\nreturn self.snapshot_by_id(snapshot_id)\nreturn None\ndef snapshot_by_id(self, snapshot_id: int) -&gt; Optional[Snapshot]:\n\"\"\"Get the snapshot of this table with the given id, or None if there is no matching snapshot.\"\"\"\ntry:\nreturn next(snapshot for snapshot in self.metadata.snapshots if snapshot.snapshot_id == snapshot_id)\nexcept StopIteration:\nreturn None\ndef snapshot_by_name(self, name: str) -&gt; Optional[Snapshot]:\n\"\"\"Returns the snapshot referenced by the given name or null if no such reference exists.\"\"\"\nif ref := self.metadata.refs.get(name):\nreturn self.snapshot_by_id(ref.snapshot_id)\nreturn None\ndef history(self) -&gt; List[SnapshotLogEntry]:\n\"\"\"Get the snapshot history of this table.\"\"\"\nreturn self.metadata.snapshot_log\ndef __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the Table class.\"\"\"\nreturn (\nself.identifier == other.identifier\nand self.metadata == other.metadata\nand self.metadata_location == other.metadata_location\nif isinstance(other, Table)\nelse False\n)\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Table.properties","title":"<code>properties: Dict[str, str]</code>  <code>property</code>","text":"<p>Properties of the table.</p>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Table.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Returns the equality of two instances of the Table class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n\"\"\"Returns the equality of two instances of the Table class.\"\"\"\nreturn (\nself.identifier == other.identifier\nand self.metadata == other.metadata\nand self.metadata_location == other.metadata_location\nif isinstance(other, Table)\nelse False\n)\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Table.current_snapshot","title":"<code>current_snapshot()</code>","text":"<p>Get the current snapshot for this table, or None if there is no current snapshot.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def current_snapshot(self) -&gt; Optional[Snapshot]:\n\"\"\"Get the current snapshot for this table, or None if there is no current snapshot.\"\"\"\nif snapshot_id := self.metadata.current_snapshot_id:\nreturn self.snapshot_by_id(snapshot_id)\nreturn None\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Table.history","title":"<code>history()</code>","text":"<p>Get the snapshot history of this table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def history(self) -&gt; List[SnapshotLogEntry]:\n\"\"\"Get the snapshot history of this table.\"\"\"\nreturn self.metadata.snapshot_log\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Table.location","title":"<code>location()</code>","text":"<p>Return the table's base location.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def location(self) -&gt; str:\n\"\"\"Return the table's base location.\"\"\"\nreturn self.metadata.location\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Table.name","title":"<code>name()</code>","text":"<p>Return the identifier of this table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def name(self) -&gt; Identifier:\n\"\"\"Return the identifier of this table.\"\"\"\nreturn self.identifier\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Table.refresh","title":"<code>refresh()</code>","text":"<p>Refresh the current table metadata.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def refresh(self) -&gt; Table:\n\"\"\"Refresh the current table metadata.\"\"\"\nfresh = self.catalog.load_table(self.identifier[1:])\nself.metadata = fresh.metadata\nself.io = fresh.io\nself.metadata_location = fresh.metadata_location\nreturn self\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Table.schema","title":"<code>schema()</code>","text":"<p>Return the schema for this table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def schema(self) -&gt; Schema:\n\"\"\"Return the schema for this table.\"\"\"\nreturn next(schema for schema in self.metadata.schemas if schema.schema_id == self.metadata.current_schema_id)\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Table.schemas","title":"<code>schemas()</code>","text":"<p>Return a dict of the schema of this table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def schemas(self) -&gt; Dict[int, Schema]:\n\"\"\"Return a dict of the schema of this table.\"\"\"\nreturn {schema.schema_id: schema for schema in self.metadata.schemas}\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Table.snapshot_by_id","title":"<code>snapshot_by_id(snapshot_id)</code>","text":"<p>Get the snapshot of this table with the given id, or None if there is no matching snapshot.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def snapshot_by_id(self, snapshot_id: int) -&gt; Optional[Snapshot]:\n\"\"\"Get the snapshot of this table with the given id, or None if there is no matching snapshot.\"\"\"\ntry:\nreturn next(snapshot for snapshot in self.metadata.snapshots if snapshot.snapshot_id == snapshot_id)\nexcept StopIteration:\nreturn None\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Table.snapshot_by_name","title":"<code>snapshot_by_name(name)</code>","text":"<p>Returns the snapshot referenced by the given name or null if no such reference exists.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def snapshot_by_name(self, name: str) -&gt; Optional[Snapshot]:\n\"\"\"Returns the snapshot referenced by the given name or null if no such reference exists.\"\"\"\nif ref := self.metadata.refs.get(name):\nreturn self.snapshot_by_id(ref.snapshot_id)\nreturn None\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Table.sort_order","title":"<code>sort_order()</code>","text":"<p>Return the sort order of this table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def sort_order(self) -&gt; SortOrder:\n\"\"\"Return the sort order of this table.\"\"\"\nreturn next(\nsort_order for sort_order in self.metadata.sort_orders if sort_order.order_id == self.metadata.default_sort_order_id\n)\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Table.sort_orders","title":"<code>sort_orders()</code>","text":"<p>Return a dict of the sort orders of this table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def sort_orders(self) -&gt; Dict[int, SortOrder]:\n\"\"\"Return a dict of the sort orders of this table.\"\"\"\nreturn {sort_order.order_id: sort_order for sort_order in self.metadata.sort_orders}\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Table.spec","title":"<code>spec()</code>","text":"<p>Return the partition spec of this table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def spec(self) -&gt; PartitionSpec:\n\"\"\"Return the partition spec of this table.\"\"\"\nreturn next(spec for spec in self.metadata.partition_specs if spec.spec_id == self.metadata.default_spec_id)\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Table.specs","title":"<code>specs()</code>","text":"<p>Return a dict the partition specs this table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def specs(self) -&gt; Dict[int, PartitionSpec]:\n\"\"\"Return a dict the partition specs this table.\"\"\"\nreturn {spec.spec_id: spec for spec in self.metadata.partition_specs}\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.TableScan","title":"<code>TableScan</code>","text":"<p>         Bases: <code>ABC</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>class TableScan(ABC):\ntable: Table\nrow_filter: BooleanExpression\nselected_fields: Tuple[str, ...]\ncase_sensitive: bool\nsnapshot_id: Optional[int]\noptions: Properties\nlimit: Optional[int]\ndef __init__(\nself,\ntable: Table,\nrow_filter: Union[str, BooleanExpression] = ALWAYS_TRUE,\nselected_fields: Tuple[str, ...] = (\"*\",),\ncase_sensitive: bool = True,\nsnapshot_id: Optional[int] = None,\noptions: Properties = EMPTY_DICT,\nlimit: Optional[int] = None,\n):\nself.table = table\nself.row_filter = _parse_row_filter(row_filter)\nself.selected_fields = selected_fields\nself.case_sensitive = case_sensitive\nself.snapshot_id = snapshot_id\nself.options = options\nself.limit = limit\ndef snapshot(self) -&gt; Optional[Snapshot]:\nif self.snapshot_id:\nreturn self.table.snapshot_by_id(self.snapshot_id)\nreturn self.table.current_snapshot()\ndef projection(self) -&gt; Schema:\nsnapshot_schema = self.table.schema()\nif snapshot := self.snapshot():\nif snapshot_schema_id := snapshot.schema_id:\nsnapshot_schema = self.table.schemas()[snapshot_schema_id]\nif \"*\" in self.selected_fields:\nreturn snapshot_schema\nreturn snapshot_schema.select(*self.selected_fields, case_sensitive=self.case_sensitive)\n@abstractmethod\ndef plan_files(self) -&gt; Iterable[ScanTask]:\n...\n@abstractmethod\ndef to_arrow(self) -&gt; pa.Table:\n...\n@abstractmethod\ndef to_pandas(self, **kwargs: Any) -&gt; pd.DataFrame:\n...\ndef update(self: S, **overrides: Any) -&gt; S:\n\"\"\"Creates a copy of this table scan with updated fields.\"\"\"\nreturn type(self)(**{**self.__dict__, **overrides})\ndef use_ref(self: S, name: str) -&gt; S:\nif self.snapshot_id:\nraise ValueError(f\"Cannot override ref, already set snapshot id={self.snapshot_id}\")\nif snapshot := self.table.snapshot_by_name(name):\nreturn self.update(snapshot_id=snapshot.snapshot_id)\nraise ValueError(f\"Cannot scan unknown ref={name}\")\ndef select(self: S, *field_names: str) -&gt; S:\nif \"*\" in self.selected_fields:\nreturn self.update(selected_fields=field_names)\nreturn self.update(selected_fields=tuple(set(self.selected_fields).intersection(set(field_names))))\ndef filter(self: S, expr: Union[str, BooleanExpression]) -&gt; S:\nreturn self.update(row_filter=And(self.row_filter, _parse_row_filter(expr)))\ndef with_case_sensitive(self: S, case_sensitive: bool = True) -&gt; S:\nreturn self.update(case_sensitive=case_sensitive)\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.TableScan.update","title":"<code>update(**overrides)</code>","text":"<p>Creates a copy of this table scan with updated fields.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def update(self: S, **overrides: Any) -&gt; S:\n\"\"\"Creates a copy of this table scan with updated fields.\"\"\"\nreturn type(self)(**{**self.__dict__, **overrides})\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Transaction","title":"<code>Transaction</code>","text":"Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>class Transaction:\n_table: Table\n_updates: Tuple[TableUpdate, ...]\n_requirements: Tuple[TableRequirement, ...]\ndef __init__(\nself,\ntable: Table,\nactions: Optional[Tuple[TableUpdate, ...]] = None,\nrequirements: Optional[Tuple[TableRequirement, ...]] = None,\n):\nself._table = table\nself._updates = actions or ()\nself._requirements = requirements or ()\ndef __enter__(self) -&gt; Transaction:\n\"\"\"Starts a transaction to update the table.\"\"\"\nreturn self\ndef __exit__(self, _: Any, value: Any, traceback: Any) -&gt; None:\n\"\"\"Closes and commits the transaction.\"\"\"\nfresh_table = self.commit_transaction()\n# Update the new data in place\nself._table.metadata = fresh_table.metadata\nself._table.metadata_location = fresh_table.metadata_location\ndef _append_updates(self, *new_updates: TableUpdate) -&gt; Transaction:\n\"\"\"Appends updates to the set of staged updates.\n        Args:\n            *new_updates: Any new updates.\n        Raises:\n            ValueError: When the type of update is not unique.\n        Returns:\n            A new AlterTable object with the new updates appended.\n        \"\"\"\nfor new_update in new_updates:\ntype_new_update = type(new_update)\nif any(type(update) == type_new_update for update in self._updates):\nraise ValueError(f\"Updates in a single commit need to be unique, duplicate: {type_new_update}\")\nself._updates = self._updates + new_updates\nreturn self\ndef set_table_version(self, format_version: Literal[1, 2]) -&gt; Transaction:\n\"\"\"Sets the table to a certain version.\n        Args:\n            format_version: The newly set version.\n        Returns:\n            The alter table builder.\n        \"\"\"\nraise NotImplementedError(\"Not yet implemented\")\ndef set_properties(self, **updates: str) -&gt; Transaction:\n\"\"\"Set properties.\n        When a property is already set, it will be overwritten.\n        Args:\n            updates: The properties set on the table.\n        Returns:\n            The alter table builder.\n        \"\"\"\nreturn self._append_updates(SetPropertiesUpdate(updates=updates))\ndef remove_properties(self, *removals: str) -&gt; Transaction:\n\"\"\"Removes properties.\n        Args:\n            removals: Properties to be removed.\n        Returns:\n            The alter table builder.\n        \"\"\"\nreturn self._append_updates(RemovePropertiesUpdate(removals=removals))\ndef update_location(self, location: str) -&gt; Transaction:\n\"\"\"Sets the new table location.\n        Args:\n            location: The new location of the table.\n        Returns:\n            The alter table builder.\n        \"\"\"\nraise NotImplementedError(\"Not yet implemented\")\ndef commit_transaction(self) -&gt; Table:\n\"\"\"Commits the changes to the catalog.\n        Returns:\n            The table with the updates applied.\n        \"\"\"\n# Strip the catalog name\nif len(self._updates) &gt; 0:\nresponse = self._table.catalog._commit_table(  # pylint: disable=W0212\nCommitTableRequest(\nidentifier=self._table.identifier[1:],\nrequirements=self._requirements,\nupdates=self._updates,\n)\n)\n# Update the metadata with the new one\nself._table.metadata = response.metadata\nself._table.metadata_location = response.metadata_location\nreturn self._table\nelse:\nreturn self._table\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Transaction.__enter__","title":"<code>__enter__()</code>","text":"<p>Starts a transaction to update the table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def __enter__(self) -&gt; Transaction:\n\"\"\"Starts a transaction to update the table.\"\"\"\nreturn self\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Transaction.__exit__","title":"<code>__exit__(_, value, traceback)</code>","text":"<p>Closes and commits the transaction.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def __exit__(self, _: Any, value: Any, traceback: Any) -&gt; None:\n\"\"\"Closes and commits the transaction.\"\"\"\nfresh_table = self.commit_transaction()\n# Update the new data in place\nself._table.metadata = fresh_table.metadata\nself._table.metadata_location = fresh_table.metadata_location\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Transaction.commit_transaction","title":"<code>commit_transaction()</code>","text":"<p>Commits the changes to the catalog.</p> <p>Returns:</p> Type Description <code>Table</code> <p>The table with the updates applied.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def commit_transaction(self) -&gt; Table:\n\"\"\"Commits the changes to the catalog.\n    Returns:\n        The table with the updates applied.\n    \"\"\"\n# Strip the catalog name\nif len(self._updates) &gt; 0:\nresponse = self._table.catalog._commit_table(  # pylint: disable=W0212\nCommitTableRequest(\nidentifier=self._table.identifier[1:],\nrequirements=self._requirements,\nupdates=self._updates,\n)\n)\n# Update the metadata with the new one\nself._table.metadata = response.metadata\nself._table.metadata_location = response.metadata_location\nreturn self._table\nelse:\nreturn self._table\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Transaction.remove_properties","title":"<code>remove_properties(*removals)</code>","text":"<p>Removes properties.</p> <p>Parameters:</p> Name Type Description Default <code>removals</code> <code>str</code> <p>Properties to be removed.</p> <code>()</code> <p>Returns:</p> Type Description <code>Transaction</code> <p>The alter table builder.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def remove_properties(self, *removals: str) -&gt; Transaction:\n\"\"\"Removes properties.\n    Args:\n        removals: Properties to be removed.\n    Returns:\n        The alter table builder.\n    \"\"\"\nreturn self._append_updates(RemovePropertiesUpdate(removals=removals))\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Transaction.set_properties","title":"<code>set_properties(**updates)</code>","text":"<p>Set properties.</p> <p>When a property is already set, it will be overwritten.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>str</code> <p>The properties set on the table.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Transaction</code> <p>The alter table builder.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def set_properties(self, **updates: str) -&gt; Transaction:\n\"\"\"Set properties.\n    When a property is already set, it will be overwritten.\n    Args:\n        updates: The properties set on the table.\n    Returns:\n        The alter table builder.\n    \"\"\"\nreturn self._append_updates(SetPropertiesUpdate(updates=updates))\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Transaction.set_table_version","title":"<code>set_table_version(format_version)</code>","text":"<p>Sets the table to a certain version.</p> <p>Parameters:</p> Name Type Description Default <code>format_version</code> <code>Literal[1, 2]</code> <p>The newly set version.</p> required <p>Returns:</p> Type Description <code>Transaction</code> <p>The alter table builder.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def set_table_version(self, format_version: Literal[1, 2]) -&gt; Transaction:\n\"\"\"Sets the table to a certain version.\n    Args:\n        format_version: The newly set version.\n    Returns:\n        The alter table builder.\n    \"\"\"\nraise NotImplementedError(\"Not yet implemented\")\n</code></pre>"},{"location":"reference/pyiceberg/table/#pyiceberg.table.Transaction.update_location","title":"<code>update_location(location)</code>","text":"<p>Sets the new table location.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>str</code> <p>The new location of the table.</p> required <p>Returns:</p> Type Description <code>Transaction</code> <p>The alter table builder.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/__init__.py</code> <pre><code>def update_location(self, location: str) -&gt; Transaction:\n\"\"\"Sets the new table location.\n    Args:\n        location: The new location of the table.\n    Returns:\n        The alter table builder.\n    \"\"\"\nraise NotImplementedError(\"Not yet implemented\")\n</code></pre>"},{"location":"reference/pyiceberg/table/metadata/","title":"metadata","text":""},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields","title":"<code>TableMetadataCommonFields</code>","text":"<p>         Bases: <code>IcebergBaseModel</code></p> <p>Metadata for an Iceberg table as specified in the Apache Iceberg spec.</p> <p>https://iceberg.apache.org/spec/#iceberg-table-spec</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/metadata.py</code> <pre><code>class TableMetadataCommonFields(IcebergBaseModel):\n\"\"\"Metadata for an Iceberg table as specified in the Apache Iceberg spec.\n    https://iceberg.apache.org/spec/#iceberg-table-spec\n    \"\"\"\n@root_validator(skip_on_failure=True)\ndef cleanup_snapshot_id(cls, data: Dict[str, Any]) -&gt; Dict[str, Any]:\nif data[CURRENT_SNAPSHOT_ID] == -1:\n# We treat -1 and None the same, by cleaning this up\n# in a pre-validator, we can simplify the logic later on\ndata[CURRENT_SNAPSHOT_ID] = None\nreturn data\n@root_validator(skip_on_failure=True)\ndef construct_refs(cls, data: Dict[str, Any]) -&gt; Dict[str, Any]:\n# This is going to be much nicer as soon as refs is an actual pydantic object\nif current_snapshot_id := data.get(CURRENT_SNAPSHOT_ID):\nif MAIN_BRANCH not in data[REFS]:\ndata[REFS][MAIN_BRANCH] = SnapshotRef(snapshot_id=current_snapshot_id, snapshot_ref_type=SnapshotRefType.BRANCH)\nreturn data\nlocation: str = Field()\n\"\"\"The table\u2019s base location. This is used by writers to determine where\n    to store data files, manifest files, and table metadata files.\"\"\"\ntable_uuid: uuid.UUID = Field(alias=\"table-uuid\", default_factory=uuid.uuid4)\n\"\"\"A UUID that identifies the table, generated when the table is created.\n    Implementations must throw an exception if a table\u2019s UUID does not match\n    the expected UUID after refreshing metadata.\"\"\"\nlast_updated_ms: int = Field(alias=\"last-updated-ms\", default_factory=lambda: datetime_to_micros(datetime.datetime.now()))\n\"\"\"Timestamp in milliseconds from the unix epoch when the table\n    was last updated. Each table metadata file should update this\n    field just before writing.\"\"\"\nlast_column_id: int = Field(alias=\"last-column-id\")\n\"\"\"An integer; the highest assigned column ID for the table.\n    This is used to ensure fields are always assigned an unused ID\n    when evolving schemas.\"\"\"\nschemas: List[Schema] = Field(default_factory=list)\n\"\"\"A list of schemas, stored as objects with schema-id.\"\"\"\ncurrent_schema_id: int = Field(alias=\"current-schema-id\", default=DEFAULT_SCHEMA_ID)\n\"\"\"ID of the table\u2019s current schema.\"\"\"\npartition_specs: List[PartitionSpec] = Field(alias=\"partition-specs\", default_factory=list)\n\"\"\"A list of partition specs, stored as full partition spec objects.\"\"\"\ndefault_spec_id: int = Field(alias=\"default-spec-id\", default=INITIAL_SPEC_ID)\n\"\"\"ID of the \u201ccurrent\u201d spec that writers should use by default.\"\"\"\nlast_partition_id: Optional[int] = Field(alias=\"last-partition-id\")\n\"\"\"An integer; the highest assigned partition field ID across all\n    partition specs for the table. This is used to ensure partition fields\n    are always assigned an unused ID when evolving specs.\"\"\"\nproperties: Dict[str, str] = Field(default_factory=dict)\n\"\"\"A string to string map of table properties. This is used to\n    control settings that affect reading and writing and is not intended\n    to be used for arbitrary metadata. For example, commit.retry.num-retries\n    is used to control the number of commit retries.\"\"\"\ncurrent_snapshot_id: Optional[int] = Field(alias=\"current-snapshot-id\", default=None)\n\"\"\"ID of the current table snapshot.\"\"\"\nsnapshots: List[Snapshot] = Field(default_factory=list)\n\"\"\"A list of valid snapshots. Valid snapshots are snapshots for which\n    all data files exist in the file system. A data file must not be\n    deleted from the file system until the last snapshot in which it was\n    listed is garbage collected.\"\"\"\nsnapshot_log: List[SnapshotLogEntry] = Field(alias=\"snapshot-log\", default_factory=list)\n\"\"\"A list (optional) of timestamp and snapshot ID pairs that encodes\n    changes to the current snapshot for the table. Each time the\n    current-snapshot-id is changed, a new entry should be added with the\n    last-updated-ms and the new current-snapshot-id. When snapshots are\n    expired from the list of valid snapshots, all entries before a snapshot\n    that has expired should be removed.\"\"\"\nmetadata_log: List[MetadataLogEntry] = Field(alias=\"metadata-log\", default_factory=list)\n\"\"\"A list (optional) of timestamp and metadata file location pairs that\n    encodes changes to the previous metadata files for the table. Each time\n    a new metadata file is created, a new entry of the previous metadata\n    file location should be added to the list. Tables can be configured to\n    remove oldest metadata log entries and keep a fixed-size log of the most\n    recent entries after a commit.\"\"\"\nsort_orders: List[SortOrder] = Field(alias=\"sort-orders\", default_factory=list)\n\"\"\"A list of sort orders, stored as full sort order objects.\"\"\"\ndefault_sort_order_id: int = Field(alias=\"default-sort-order-id\", default=UNSORTED_SORT_ORDER_ID)\n\"\"\"Default sort order id of the table. Note that this could be used by\n    writers, but is not used when reading because reads use the specs stored\n     in manifest files.\"\"\"\nrefs: Dict[str, SnapshotRef] = Field(default_factory=dict)\n\"\"\"A map of snapshot references.\n    The map keys are the unique snapshot reference names in the table,\n    and the map values are snapshot reference objects.\n    There is always a main branch reference pointing to the\n    current-snapshot-id even if the refs map is null.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields.current_schema_id","title":"<code>current_schema_id: int = Field(alias='current-schema-id', default=DEFAULT_SCHEMA_ID)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ID of the table\u2019s current schema.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields.current_snapshot_id","title":"<code>current_snapshot_id: Optional[int] = Field(alias='current-snapshot-id', default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ID of the current table snapshot.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields.default_sort_order_id","title":"<code>default_sort_order_id: int = Field(alias='default-sort-order-id', default=UNSORTED_SORT_ORDER_ID)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default sort order id of the table. Note that this could be used by writers, but is not used when reading because reads use the specs stored  in manifest files.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields.default_spec_id","title":"<code>default_spec_id: int = Field(alias='default-spec-id', default=INITIAL_SPEC_ID)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ID of the \u201ccurrent\u201d spec that writers should use by default.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields.last_column_id","title":"<code>last_column_id: int = Field(alias='last-column-id')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An integer; the highest assigned column ID for the table. This is used to ensure fields are always assigned an unused ID when evolving schemas.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields.last_partition_id","title":"<code>last_partition_id: Optional[int] = Field(alias='last-partition-id')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An integer; the highest assigned partition field ID across all partition specs for the table. This is used to ensure partition fields are always assigned an unused ID when evolving specs.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields.last_updated_ms","title":"<code>last_updated_ms: int = Field(alias='last-updated-ms', default_factory=lambda : datetime_to_micros(datetime.datetime.now()))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Timestamp in milliseconds from the unix epoch when the table was last updated. Each table metadata file should update this field just before writing.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields.location","title":"<code>location: str = Field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The table\u2019s base location. This is used by writers to determine where to store data files, manifest files, and table metadata files.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields.metadata_log","title":"<code>metadata_log: List[MetadataLogEntry] = Field(alias='metadata-log', default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list (optional) of timestamp and metadata file location pairs that encodes changes to the previous metadata files for the table. Each time a new metadata file is created, a new entry of the previous metadata file location should be added to the list. Tables can be configured to remove oldest metadata log entries and keep a fixed-size log of the most recent entries after a commit.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields.partition_specs","title":"<code>partition_specs: List[PartitionSpec] = Field(alias='partition-specs', default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list of partition specs, stored as full partition spec objects.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields.properties","title":"<code>properties: Dict[str, str] = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A string to string map of table properties. This is used to control settings that affect reading and writing and is not intended to be used for arbitrary metadata. For example, commit.retry.num-retries is used to control the number of commit retries.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields.refs","title":"<code>refs: Dict[str, SnapshotRef] = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A map of snapshot references. The map keys are the unique snapshot reference names in the table, and the map values are snapshot reference objects. There is always a main branch reference pointing to the current-snapshot-id even if the refs map is null.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields.schemas","title":"<code>schemas: List[Schema] = Field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list of schemas, stored as objects with schema-id.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields.snapshot_log","title":"<code>snapshot_log: List[SnapshotLogEntry] = Field(alias='snapshot-log', default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list (optional) of timestamp and snapshot ID pairs that encodes changes to the current snapshot for the table. Each time the current-snapshot-id is changed, a new entry should be added with the last-updated-ms and the new current-snapshot-id. When snapshots are expired from the list of valid snapshots, all entries before a snapshot that has expired should be removed.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields.snapshots","title":"<code>snapshots: List[Snapshot] = Field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list of valid snapshots. Valid snapshots are snapshots for which all data files exist in the file system. A data file must not be deleted from the file system until the last snapshot in which it was listed is garbage collected.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields.sort_orders","title":"<code>sort_orders: List[SortOrder] = Field(alias='sort-orders', default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list of sort orders, stored as full sort order objects.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataCommonFields.table_uuid","title":"<code>table_uuid: uuid.UUID = Field(alias='table-uuid', default_factory=uuid.uuid4)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A UUID that identifies the table, generated when the table is created. Implementations must throw an exception if a table\u2019s UUID does not match the expected UUID after refreshing metadata.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataUtil","title":"<code>TableMetadataUtil</code>","text":"<p>Helper class for parsing TableMetadata.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/metadata.py</code> <pre><code>class TableMetadataUtil:\n\"\"\"Helper class for parsing TableMetadata.\"\"\"\n# Once this has been resolved, we can simplify this: https://github.com/samuelcolvin/pydantic/issues/3846\n# TableMetadata = Annotated[TableMetadata, Field(alias=\"format-version\", discriminator=\"format-version\")]\n@staticmethod\ndef parse_obj(data: Dict[str, Any]) -&gt; TableMetadata:\nif \"format-version\" not in data:\nraise ValidationError(f\"Missing format-version in TableMetadata: {data}\")\nformat_version = data[\"format-version\"]\nif format_version == 1:\nreturn TableMetadataV1(**data)\nelif format_version == 2:\nreturn TableMetadataV2(**data)\nelse:\nraise ValidationError(f\"Unknown format version: {format_version}\")\n</code></pre>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataV1","title":"<code>TableMetadataV1</code>","text":"<p>         Bases: <code>TableMetadataCommonFields</code>, <code>IcebergBaseModel</code></p> <p>Represents version 1 of the Table Metadata.</p> <p>More information about the specification: https://iceberg.apache.org/spec/#version-1-analytic-data-tables</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/metadata.py</code> <pre><code>class TableMetadataV1(TableMetadataCommonFields, IcebergBaseModel):\n\"\"\"Represents version 1 of the Table Metadata.\n    More information about the specification:\n    https://iceberg.apache.org/spec/#version-1-analytic-data-tables\n    \"\"\"\n# When we read a V1 format-version, we'll make sure to populate the fields\n# for V2 as well. This makes it easier downstream because we can just\n# assume that everything is a TableMetadataV2.\n# When writing, we should stick to the same version that it was,\n# because bumping the version should be an explicit operation that is up\n# to the owner of the table.\n@root_validator\ndef set_v2_compatible_defaults(cls, data: Dict[str, Any]) -&gt; Dict[str, Any]:\n\"\"\"Sets default values to be compatible with the format v2.\n        Args:\n            data: The raw arguments when initializing a V1 TableMetadata.\n        Returns:\n            The TableMetadata with the defaults applied.\n        \"\"\"\n# When the schema doesn't have an ID\nif data.get(\"schema\") and \"schema_id\" not in data[\"schema\"]:\ndata[\"schema\"][\"schema_id\"] = DEFAULT_SCHEMA_ID\nreturn data\n@root_validator(skip_on_failure=True)\ndef construct_schemas(cls, data: Dict[str, Any]) -&gt; Dict[str, Any]:\n\"\"\"Converts the schema into schemas.\n        For V1 schemas is optional, and if they aren't set, we'll set them\n        in this validator. This was we can always use the schemas when reading\n        table metadata, and we don't have to worry if it is a v1 or v2 format.\n        Args:\n            data: The raw data after validation, meaning that the aliases are applied.\n        Returns:\n            The TableMetadata with the schemas set, if not provided.\n        \"\"\"\nif not data.get(\"schemas\"):\nschema = data[\"schema_\"]\ndata[\"schemas\"] = [schema]\nelse:\ncheck_schemas(data)\nreturn data\n@root_validator(skip_on_failure=True)\ndef construct_partition_specs(cls, data: Dict[str, Any]) -&gt; Dict[str, Any]:\n\"\"\"Converts the partition_spec into partition_specs.\n        For V1 partition_specs is optional, and if they aren't set, we'll set them\n        in this validator. This was we can always use the partition_specs when reading\n        table metadata, and we don't have to worry if it is a v1 or v2 format.\n        Args:\n            data: The raw data after validation, meaning that the aliases are applied.\n        Returns:\n            The TableMetadata with the partition_specs set, if not provided.\n        \"\"\"\nif not data.get(PARTITION_SPECS):\nfields = data[PARTITION_SPEC]\nmigrated_spec = PartitionSpec(*fields)\ndata[PARTITION_SPECS] = [migrated_spec]\ndata[DEFAULT_SPEC_ID] = migrated_spec.spec_id\nelse:\ncheck_partition_specs(data)\nif \"last_partition_id\" not in data or data.get(\"last_partition_id\") is None:\nif partition_specs := data.get(PARTITION_SPECS):\ndata[\"last_partition_id\"] = max(spec.last_assigned_field_id for spec in partition_specs)\nreturn data\n@root_validator(skip_on_failure=True)\ndef set_sort_orders(cls, data: Dict[str, Any]) -&gt; Dict[str, Any]:\n\"\"\"Sets the sort_orders if not provided.\n        For V1 sort_orders is optional, and if they aren't set, we'll set them\n        in this validator.\n        Args:\n            data: The raw data after validation, meaning that the aliases are applied.\n        Returns:\n            The TableMetadata with the sort_orders set, if not provided.\n        \"\"\"\nif not data.get(SORT_ORDERS):\ndata[SORT_ORDERS] = [UNSORTED_SORT_ORDER]\nelse:\ncheck_sort_orders(data)\nreturn data\ndef to_v2(self) -&gt; \"TableMetadataV2\":\nmetadata = copy(self.dict())\nmetadata[\"format_version\"] = 2\nreturn TableMetadataV2(**metadata)\nformat_version: Literal[1] = Field(alias=\"format-version\")\n\"\"\"An integer version number for the format. Currently, this can be 1 or 2\n    based on the spec. Implementations must throw an exception if a table\u2019s\n    version is higher than the supported version.\"\"\"\nschema_: Schema = Field(alias=\"schema\")\n\"\"\"The table\u2019s current schema. (Deprecated: use schemas and\n    current-schema-id instead).\"\"\"\npartition_spec: List[Dict[str, Any]] = Field(alias=\"partition-spec\")\n\"\"\"The table\u2019s current partition spec, stored as only fields.\n    Note that this is used by writers to partition data, but is\n    not used when reading because reads use the specs stored in\n    manifest files. (Deprecated: use partition-specs and default-spec-id\n    instead).\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataV1.format_version","title":"<code>format_version: Literal[1] = Field(alias='format-version')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An integer version number for the format. Currently, this can be 1 or 2 based on the spec. Implementations must throw an exception if a table\u2019s version is higher than the supported version.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataV1.partition_spec","title":"<code>partition_spec: List[Dict[str, Any]] = Field(alias='partition-spec')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The table\u2019s current partition spec, stored as only fields. Note that this is used by writers to partition data, but is not used when reading because reads use the specs stored in manifest files. (Deprecated: use partition-specs and default-spec-id instead).</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataV1.schema_","title":"<code>schema_: Schema = Field(alias='schema')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The table\u2019s current schema. (Deprecated: use schemas and current-schema-id instead).</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataV1.construct_partition_specs","title":"<code>construct_partition_specs(data)</code>","text":"<p>Converts the partition_spec into partition_specs.</p> <p>For V1 partition_specs is optional, and if they aren't set, we'll set them in this validator. This was we can always use the partition_specs when reading table metadata, and we don't have to worry if it is a v1 or v2 format.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The raw data after validation, meaning that the aliases are applied.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The TableMetadata with the partition_specs set, if not provided.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/metadata.py</code> <pre><code>@root_validator(skip_on_failure=True)\ndef construct_partition_specs(cls, data: Dict[str, Any]) -&gt; Dict[str, Any]:\n\"\"\"Converts the partition_spec into partition_specs.\n    For V1 partition_specs is optional, and if they aren't set, we'll set them\n    in this validator. This was we can always use the partition_specs when reading\n    table metadata, and we don't have to worry if it is a v1 or v2 format.\n    Args:\n        data: The raw data after validation, meaning that the aliases are applied.\n    Returns:\n        The TableMetadata with the partition_specs set, if not provided.\n    \"\"\"\nif not data.get(PARTITION_SPECS):\nfields = data[PARTITION_SPEC]\nmigrated_spec = PartitionSpec(*fields)\ndata[PARTITION_SPECS] = [migrated_spec]\ndata[DEFAULT_SPEC_ID] = migrated_spec.spec_id\nelse:\ncheck_partition_specs(data)\nif \"last_partition_id\" not in data or data.get(\"last_partition_id\") is None:\nif partition_specs := data.get(PARTITION_SPECS):\ndata[\"last_partition_id\"] = max(spec.last_assigned_field_id for spec in partition_specs)\nreturn data\n</code></pre>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataV1.construct_schemas","title":"<code>construct_schemas(data)</code>","text":"<p>Converts the schema into schemas.</p> <p>For V1 schemas is optional, and if they aren't set, we'll set them in this validator. This was we can always use the schemas when reading table metadata, and we don't have to worry if it is a v1 or v2 format.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The raw data after validation, meaning that the aliases are applied.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The TableMetadata with the schemas set, if not provided.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/metadata.py</code> <pre><code>@root_validator(skip_on_failure=True)\ndef construct_schemas(cls, data: Dict[str, Any]) -&gt; Dict[str, Any]:\n\"\"\"Converts the schema into schemas.\n    For V1 schemas is optional, and if they aren't set, we'll set them\n    in this validator. This was we can always use the schemas when reading\n    table metadata, and we don't have to worry if it is a v1 or v2 format.\n    Args:\n        data: The raw data after validation, meaning that the aliases are applied.\n    Returns:\n        The TableMetadata with the schemas set, if not provided.\n    \"\"\"\nif not data.get(\"schemas\"):\nschema = data[\"schema_\"]\ndata[\"schemas\"] = [schema]\nelse:\ncheck_schemas(data)\nreturn data\n</code></pre>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataV1.set_sort_orders","title":"<code>set_sort_orders(data)</code>","text":"<p>Sets the sort_orders if not provided.</p> <p>For V1 sort_orders is optional, and if they aren't set, we'll set them in this validator.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The raw data after validation, meaning that the aliases are applied.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The TableMetadata with the sort_orders set, if not provided.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/metadata.py</code> <pre><code>@root_validator(skip_on_failure=True)\ndef set_sort_orders(cls, data: Dict[str, Any]) -&gt; Dict[str, Any]:\n\"\"\"Sets the sort_orders if not provided.\n    For V1 sort_orders is optional, and if they aren't set, we'll set them\n    in this validator.\n    Args:\n        data: The raw data after validation, meaning that the aliases are applied.\n    Returns:\n        The TableMetadata with the sort_orders set, if not provided.\n    \"\"\"\nif not data.get(SORT_ORDERS):\ndata[SORT_ORDERS] = [UNSORTED_SORT_ORDER]\nelse:\ncheck_sort_orders(data)\nreturn data\n</code></pre>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataV1.set_v2_compatible_defaults","title":"<code>set_v2_compatible_defaults(data)</code>","text":"<p>Sets default values to be compatible with the format v2.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>The raw arguments when initializing a V1 TableMetadata.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The TableMetadata with the defaults applied.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/metadata.py</code> <pre><code>@root_validator\ndef set_v2_compatible_defaults(cls, data: Dict[str, Any]) -&gt; Dict[str, Any]:\n\"\"\"Sets default values to be compatible with the format v2.\n    Args:\n        data: The raw arguments when initializing a V1 TableMetadata.\n    Returns:\n        The TableMetadata with the defaults applied.\n    \"\"\"\n# When the schema doesn't have an ID\nif data.get(\"schema\") and \"schema_id\" not in data[\"schema\"]:\ndata[\"schema\"][\"schema_id\"] = DEFAULT_SCHEMA_ID\nreturn data\n</code></pre>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataV2","title":"<code>TableMetadataV2</code>","text":"<p>         Bases: <code>TableMetadataCommonFields</code>, <code>IcebergBaseModel</code></p> <p>Represents version 2 of the Table Metadata.</p> <p>This extends Version 1 with row-level deletes, and adds some additional information to the schema, such as all the historical schemas, partition-specs, sort-orders.</p> <p>For more information: https://iceberg.apache.org/spec/#version-2-row-level-deletes</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/metadata.py</code> <pre><code>class TableMetadataV2(TableMetadataCommonFields, IcebergBaseModel):\n\"\"\"Represents version 2 of the Table Metadata.\n    This extends Version 1 with row-level deletes, and adds some additional\n    information to the schema, such as all the historical schemas, partition-specs,\n    sort-orders.\n    For more information:\n    https://iceberg.apache.org/spec/#version-2-row-level-deletes\n    \"\"\"\n@root_validator(skip_on_failure=True)\ndef check_schemas(cls, values: Dict[str, Any]) -&gt; Dict[str, Any]:\nreturn check_schemas(values)\n@root_validator\ndef check_partition_specs(cls, values: Dict[str, Any]) -&gt; Dict[str, Any]:\nreturn check_partition_specs(values)\n@root_validator(skip_on_failure=True)\ndef check_sort_orders(cls, values: Dict[str, Any]) -&gt; Dict[str, Any]:\nreturn check_sort_orders(values)\nformat_version: Literal[2] = Field(alias=\"format-version\", default=2)\n\"\"\"An integer version number for the format. Currently, this can be 1 or 2\n    based on the spec. Implementations must throw an exception if a table\u2019s\n    version is higher than the supported version.\"\"\"\nlast_sequence_number: int = Field(alias=\"last-sequence-number\", default=INITIAL_SEQUENCE_NUMBER)\n\"\"\"The table\u2019s highest assigned sequence number, a monotonically\n    increasing long that tracks the order of snapshots in a table.\"\"\"\n</code></pre>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataV2.format_version","title":"<code>format_version: Literal[2] = Field(alias='format-version', default=2)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>An integer version number for the format. Currently, this can be 1 or 2 based on the spec. Implementations must throw an exception if a table\u2019s version is higher than the supported version.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.TableMetadataV2.last_sequence_number","title":"<code>last_sequence_number: int = Field(alias='last-sequence-number', default=INITIAL_SEQUENCE_NUMBER)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The table\u2019s highest assigned sequence number, a monotonically increasing long that tracks the order of snapshots in a table.</p>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.check_partition_specs","title":"<code>check_partition_specs(values)</code>","text":"<p>Validator to check if the default-spec-id is present in partition-specs.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/metadata.py</code> <pre><code>def check_partition_specs(values: Dict[str, Any]) -&gt; Dict[str, Any]:\n\"\"\"Validator to check if the default-spec-id is present in partition-specs.\"\"\"\ndefault_spec_id = values[\"default_spec_id\"]\npartition_specs: List[PartitionSpec] = values[PARTITION_SPECS]\nfor spec in partition_specs:\nif spec.spec_id == default_spec_id:\nreturn values\nraise ValidationError(f\"default-spec-id {default_spec_id} can't be found\")\n</code></pre>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.check_schemas","title":"<code>check_schemas(values)</code>","text":"<p>Validator to check if the current-schema-id is actually present in schemas.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/metadata.py</code> <pre><code>def check_schemas(values: Dict[str, Any]) -&gt; Dict[str, Any]:\n\"\"\"Validator to check if the current-schema-id is actually present in schemas.\"\"\"\ncurrent_schema_id = values[CURRENT_SCHEMA_ID]\nfor schema in values[SCHEMAS]:\nif schema.schema_id == current_schema_id:\nreturn values\nraise ValidationError(f\"current-schema-id {current_schema_id} can't be found in the schemas\")\n</code></pre>"},{"location":"reference/pyiceberg/table/metadata/#pyiceberg.table.metadata.check_sort_orders","title":"<code>check_sort_orders(values)</code>","text":"<p>Validator to check if the default_sort_order_id is present in sort-orders.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/metadata.py</code> <pre><code>def check_sort_orders(values: Dict[str, Any]) -&gt; Dict[str, Any]:\n\"\"\"Validator to check if the default_sort_order_id is present in sort-orders.\"\"\"\ndefault_sort_order_id: int = values[\"default_sort_order_id\"]\nif default_sort_order_id != UNSORTED_SORT_ORDER_ID:\nsort_orders: List[SortOrder] = values[SORT_ORDERS]\nfor sort_order in sort_orders:\nif sort_order.order_id == default_sort_order_id:\nreturn values\nraise ValidationError(f\"default-sort-order-id {default_sort_order_id} can't be found in {sort_orders}\")\nreturn values\n</code></pre>"},{"location":"reference/pyiceberg/table/refs/","title":"refs","text":""},{"location":"reference/pyiceberg/table/refs/#pyiceberg.table.refs.SnapshotRefType","title":"<code>SnapshotRefType</code>","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/refs.py</code> <pre><code>class SnapshotRefType(str, Enum):\nBRANCH = \"branch\"\nTAG = \"tag\"\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the SnapshotRefType class.\"\"\"\nreturn f\"SnapshotRefType.{self.name}\"\n</code></pre>"},{"location":"reference/pyiceberg/table/refs/#pyiceberg.table.refs.SnapshotRefType.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the SnapshotRefType class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/refs.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the SnapshotRefType class.\"\"\"\nreturn f\"SnapshotRefType.{self.name}\"\n</code></pre>"},{"location":"reference/pyiceberg/table/snapshots/","title":"snapshots","text":""},{"location":"reference/pyiceberg/table/snapshots/#pyiceberg.table.snapshots.Operation","title":"<code>Operation</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Describes the operation.</p> Possible operation values are <ul> <li>append: Only data files were added and no files were removed.</li> <li>replace: Data and delete files were added and removed without changing table data; i.e., compaction, changing the data file format, or relocating data files.</li> <li>overwrite: Data and delete files were added and removed in a logical overwrite operation.</li> <li>delete: Data files were removed and their contents logically deleted and/or delete files were added to delete rows.</li> </ul> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/snapshots.py</code> <pre><code>class Operation(Enum):\n\"\"\"Describes the operation.\n    Possible operation values are:\n        - append: Only data files were added and no files were removed.\n        - replace: Data and delete files were added and removed without changing table data; i.e., compaction, changing the data file format, or relocating data files.\n        - overwrite: Data and delete files were added and removed in a logical overwrite operation.\n        - delete: Data files were removed and their contents logically deleted and/or delete files were added to delete rows.\n    \"\"\"\nAPPEND = \"append\"\nREPLACE = \"replace\"\nOVERWRITE = \"overwrite\"\nDELETE = \"delete\"\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Operation class.\"\"\"\nreturn f\"Operation.{self.name}\"\n</code></pre>"},{"location":"reference/pyiceberg/table/snapshots/#pyiceberg.table.snapshots.Operation.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the Operation class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/snapshots.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Operation class.\"\"\"\nreturn f\"Operation.{self.name}\"\n</code></pre>"},{"location":"reference/pyiceberg/table/snapshots/#pyiceberg.table.snapshots.Snapshot","title":"<code>Snapshot</code>","text":"<p>         Bases: <code>IcebergBaseModel</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/snapshots.py</code> <pre><code>class Snapshot(IcebergBaseModel):\nsnapshot_id: int = Field(alias=\"snapshot-id\")\nparent_snapshot_id: Optional[int] = Field(alias=\"parent-snapshot-id\")\nsequence_number: Optional[int] = Field(alias=\"sequence-number\", default=None)\ntimestamp_ms: int = Field(alias=\"timestamp-ms\")\nmanifest_list: Optional[str] = Field(alias=\"manifest-list\", description=\"Location of the snapshot's manifest list file\")\nsummary: Optional[Summary] = Field()\nschema_id: Optional[int] = Field(alias=\"schema-id\", default=None)\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the Snapshot class.\"\"\"\noperation = f\"{self.summary.operation}: \" if self.summary else \"\"\nparent_id = f\", parent_id={self.parent_snapshot_id}\" if self.parent_snapshot_id else \"\"\nschema_id = f\", schema_id={self.schema_id}\" if self.schema_id is not None else \"\"\nresult_str = f\"{operation}id={self.snapshot_id}{parent_id}{schema_id}\"\nreturn result_str\ndef manifests(self, io: FileIO) -&gt; List[ManifestFile]:\nif self.manifest_list is not None:\nfile = io.new_input(self.manifest_list)\nreturn list(read_manifest_list(file))\nreturn []\n</code></pre>"},{"location":"reference/pyiceberg/table/snapshots/#pyiceberg.table.snapshots.Snapshot.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the Snapshot class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/snapshots.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the Snapshot class.\"\"\"\noperation = f\"{self.summary.operation}: \" if self.summary else \"\"\nparent_id = f\", parent_id={self.parent_snapshot_id}\" if self.parent_snapshot_id else \"\"\nschema_id = f\", schema_id={self.schema_id}\" if self.schema_id is not None else \"\"\nresult_str = f\"{operation}id={self.snapshot_id}{parent_id}{schema_id}\"\nreturn result_str\n</code></pre>"},{"location":"reference/pyiceberg/table/snapshots/#pyiceberg.table.snapshots.Summary","title":"<code>Summary</code>","text":"<p>         Bases: <code>IcebergBaseModel</code></p> <p>A class that stores the summary information for a Snapshot.</p> <p>The snapshot summary\u2019s operation field is used by some operations, like snapshot expiration, to skip processing certain snapshots.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/snapshots.py</code> <pre><code>class Summary(IcebergBaseModel):\n\"\"\"A class that stores the summary information for a Snapshot.\n    The snapshot summary\u2019s operation field is used by some operations,\n    like snapshot expiration, to skip processing certain snapshots.\n    \"\"\"\n__root__: Dict[str, Union[str, Operation]]\n_additional_properties: Dict[str, str] = PrivateAttr()\n@root_validator\ndef check_operation(cls, values: Dict[str, Dict[str, Union[str, Operation]]]) -&gt; Dict[str, Dict[str, Union[str, Operation]]]:\nif operation := values[\"__root__\"].get(OPERATION):\nif isinstance(operation, str):\nvalues[\"__root__\"][OPERATION] = Operation(operation.lower())\nelse:\nraise ValueError(\"Operation not set\")\nreturn values\ndef __init__(\nself, operation: Optional[Operation] = None, __root__: Optional[Dict[str, Union[str, Operation]]] = None, **data: Any\n) -&gt; None:\nsuper().__init__(__root__={\"operation\": operation, **data} if not __root__ else __root__)\nself._additional_properties = {\nk: v for k, v in self.__root__.items() if k != OPERATION  # type: ignore # We know that they are all string, and we don't want to check\n}\n@property\ndef operation(self) -&gt; Operation:\noperation = self.__root__[OPERATION]\nif isinstance(operation, Operation):\nreturn operation\nelse:\n# Should never happen\nraise ValueError(f\"Unknown type of operation: {operation}\")\n@property\ndef additional_properties(self) -&gt; Dict[str, str]:\nreturn self._additional_properties\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Summary class.\"\"\"\nrepr_properties = f\", **{repr(self._additional_properties)}\" if self._additional_properties else \"\"\nreturn f\"Summary({repr(self.operation)}{repr_properties})\"\n</code></pre>"},{"location":"reference/pyiceberg/table/snapshots/#pyiceberg.table.snapshots.Summary.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the Summary class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/snapshots.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the Summary class.\"\"\"\nrepr_properties = f\", **{repr(self._additional_properties)}\" if self._additional_properties else \"\"\nreturn f\"Summary({repr(self.operation)}{repr_properties})\"\n</code></pre>"},{"location":"reference/pyiceberg/table/sorting/","title":"sorting","text":""},{"location":"reference/pyiceberg/table/sorting/#pyiceberg.table.sorting.NullOrder","title":"<code>NullOrder</code>","text":"<p>         Bases: <code>Enum</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/sorting.py</code> <pre><code>class NullOrder(Enum):\nNULLS_FIRST = \"nulls-first\"\nNULLS_LAST = \"nulls-last\"\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the NullOrder class.\"\"\"\nreturn self.name.replace(\"_\", \" \")\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the NullOrder class.\"\"\"\nreturn f\"NullOrder.{self.name}\"\n</code></pre>"},{"location":"reference/pyiceberg/table/sorting/#pyiceberg.table.sorting.NullOrder.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the NullOrder class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/sorting.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the NullOrder class.\"\"\"\nreturn f\"NullOrder.{self.name}\"\n</code></pre>"},{"location":"reference/pyiceberg/table/sorting/#pyiceberg.table.sorting.NullOrder.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the NullOrder class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/sorting.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the NullOrder class.\"\"\"\nreturn self.name.replace(\"_\", \" \")\n</code></pre>"},{"location":"reference/pyiceberg/table/sorting/#pyiceberg.table.sorting.SortDirection","title":"<code>SortDirection</code>","text":"<p>         Bases: <code>Enum</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/sorting.py</code> <pre><code>class SortDirection(Enum):\nASC = \"asc\"\nDESC = \"desc\"\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the SortDirection class.\"\"\"\nreturn self.name\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the SortDirection class.\"\"\"\nreturn f\"SortDirection.{self.name}\"\n</code></pre>"},{"location":"reference/pyiceberg/table/sorting/#pyiceberg.table.sorting.SortDirection.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the SortDirection class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/sorting.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the SortDirection class.\"\"\"\nreturn f\"SortDirection.{self.name}\"\n</code></pre>"},{"location":"reference/pyiceberg/table/sorting/#pyiceberg.table.sorting.SortDirection.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the SortDirection class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/sorting.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the SortDirection class.\"\"\"\nreturn self.name\n</code></pre>"},{"location":"reference/pyiceberg/table/sorting/#pyiceberg.table.sorting.SortField","title":"<code>SortField</code>","text":"<p>         Bases: <code>IcebergBaseModel</code></p> <p>Sort order field.</p> <p>Parameters:</p> Name Type Description Default <code>source_id</code> <code>int</code> <p>Source column id from the table\u2019s schema.</p> <code>None</code> <code>transform</code> <code>str</code> <p>Transform that is used to produce values to be sorted on from the source column.                This is the same transform as described in partition transforms.</p> <code>None</code> <code>direction</code> <code>SortDirection</code> <p>Sort direction, that can only be either asc or desc.</p> <code>None</code> <code>null_order</code> <code>NullOrder</code> <p>Null order that describes the order of null values when sorted. Can only be either nulls-first or nulls-last.</p> <code>None</code> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/sorting.py</code> <pre><code>class SortField(IcebergBaseModel):\n\"\"\"Sort order field.\n    Args:\n      source_id (int): Source column id from the table\u2019s schema.\n      transform (str): Transform that is used to produce values to be sorted on from the source column.\n                       This is the same transform as described in partition transforms.\n      direction (SortDirection): Sort direction, that can only be either asc or desc.\n      null_order (NullOrder): Null order that describes the order of null values when sorted. Can only be either nulls-first or nulls-last.\n    \"\"\"\ndef __init__(\nself,\nsource_id: Optional[int] = None,\ntransform: Optional[Union[Transform[Any, Any], Callable[[IcebergType], Transform[Any, Any]]]] = None,\ndirection: Optional[SortDirection] = None,\nnull_order: Optional[NullOrder] = None,\n**data: Any,\n):\nif source_id is not None:\ndata[\"source-id\"] = source_id\nif transform is not None:\ndata[\"transform\"] = transform\nif direction is not None:\ndata[\"direction\"] = direction\nif null_order is not None:\ndata[\"null-order\"] = null_order\nsuper().__init__(**data)\n@root_validator(pre=True)\ndef set_null_order(cls, values: Dict[str, Any]) -&gt; Dict[str, Any]:\nvalues[\"direction\"] = values[\"direction\"] if values.get(\"direction\") else SortDirection.ASC\nif not values.get(\"null-order\"):\nvalues[\"null-order\"] = NullOrder.NULLS_FIRST if values[\"direction\"] == SortDirection.ASC else NullOrder.NULLS_LAST\nreturn values\nsource_id: int = Field(alias=\"source-id\")\ntransform: Transform[Any, Any] = Field()\ndirection: SortDirection = Field()\nnull_order: NullOrder = Field(alias=\"null-order\")\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the SortField class.\"\"\"\nif type(self.transform) == IdentityTransform:\n# In the case of an identity transform, we can omit the transform\nreturn f\"{self.source_id} {self.direction} {self.null_order}\"\nelse:\nreturn f\"{self.transform}({self.source_id}) {self.direction} {self.null_order}\"\n</code></pre>"},{"location":"reference/pyiceberg/table/sorting/#pyiceberg.table.sorting.SortField.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the SortField class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/sorting.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the SortField class.\"\"\"\nif type(self.transform) == IdentityTransform:\n# In the case of an identity transform, we can omit the transform\nreturn f\"{self.source_id} {self.direction} {self.null_order}\"\nelse:\nreturn f\"{self.transform}({self.source_id}) {self.direction} {self.null_order}\"\n</code></pre>"},{"location":"reference/pyiceberg/table/sorting/#pyiceberg.table.sorting.SortOrder","title":"<code>SortOrder</code>","text":"<p>         Bases: <code>IcebergBaseModel</code></p> <p>Describes how the data is sorted within the table.</p> <p>Users can sort their data within partitions by columns to gain performance.</p> <p>The order of the sort fields within the list defines the order in which the sort is applied to the data.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>List[SortField]</code> <p>The fields how the table is sorted.</p> <code>()</code> <p>Other Parameters:</p> Name Type Description <code>order_id</code> <code>int</code> <p>An unique id of the sort-order of a table.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/sorting.py</code> <pre><code>class SortOrder(IcebergBaseModel):\n\"\"\"Describes how the data is sorted within the table.\n    Users can sort their data within partitions by columns to gain performance.\n    The order of the sort fields within the list defines the order in which the sort is applied to the data.\n    Args:\n      fields (List[SortField]): The fields how the table is sorted.\n    Keyword Args:\n      order_id (int): An unique id of the sort-order of a table.\n    \"\"\"\norder_id: int = Field(alias=\"order-id\", default=INITIAL_SORT_ORDER_ID)\nfields: List[SortField] = Field(default_factory=list)\ndef __init__(self, *fields: SortField, **data: Any):\nif fields:\ndata[\"fields\"] = fields\nsuper().__init__(**data)\n@property\ndef is_unsorted(self) -&gt; bool:\nreturn len(self.fields) == 0\ndef __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the SortOrder class.\"\"\"\nresult_str = \"[\"\nif self.fields:\nresult_str += \"\\n  \" + \"\\n  \".join([str(field) for field in self.fields]) + \"\\n\"\nresult_str += \"]\"\nreturn result_str\ndef __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the SortOrder class.\"\"\"\nfields = f\"{', '.join(repr(column) for column in self.fields)}, \" if self.fields else \"\"\nreturn f\"SortOrder({fields}order_id={self.order_id})\"\n</code></pre>"},{"location":"reference/pyiceberg/table/sorting/#pyiceberg.table.sorting.SortOrder.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the SortOrder class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/sorting.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Returns the string representation of the SortOrder class.\"\"\"\nfields = f\"{', '.join(repr(column) for column in self.fields)}, \" if self.fields else \"\"\nreturn f\"SortOrder({fields}order_id={self.order_id})\"\n</code></pre>"},{"location":"reference/pyiceberg/table/sorting/#pyiceberg.table.sorting.SortOrder.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the SortOrder class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/table/sorting.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns the string representation of the SortOrder class.\"\"\"\nresult_str = \"[\"\nif self.fields:\nresult_str += \"\\n  \" + \"\\n  \".join([str(field) for field in self.fields]) + \"\\n\"\nresult_str += \"]\"\nreturn result_str\n</code></pre>"},{"location":"reference/pyiceberg/utils/","title":"utils","text":""},{"location":"reference/pyiceberg/utils/bin_packing/","title":"bin_packing","text":""},{"location":"reference/pyiceberg/utils/bin_packing/#pyiceberg.utils.bin_packing.PackingIterator","title":"<code>PackingIterator</code>","text":"<p>         Bases: <code>Generic[T]</code></p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/bin_packing.py</code> <pre><code>class PackingIterator(Generic[T]):\nbins: List[Bin[T]]\ndef __init__(\nself,\nitems: Iterable[T],\ntarget_weight: int,\nlookback: int,\nweight_func: Callable[[T], int],\nlargest_bin_first: bool = False,\n) -&gt; None:\nself.items = iter(items)\nself.target_weight = target_weight\nself.lookback = lookback\nself.weight_func = weight_func\nself.largest_bin_first = largest_bin_first\nself.bins = []\ndef __iter__(self) -&gt; PackingIterator[T]:\n\"\"\"Returns an iterator for the PackingIterator class.\"\"\"\nreturn self\ndef __next__(self) -&gt; List[T]:\n\"\"\"Returns the next item when iterating over the PackingIterator class.\"\"\"\nwhile True:\ntry:\nitem = next(self.items)\nweight = self.weight_func(item)\nbin_ = self.find_bin(weight)\nif bin_ is not None:\nbin_.add(item, weight)\nelse:\nbin_ = Bin(self.target_weight)\nbin_.add(item, weight)\nself.bins.append(bin_)\nif len(self.bins) &gt; self.lookback:\nreturn self.remove_bin().items\nexcept StopIteration:\nbreak\nif len(self.bins) == 0:\nraise StopIteration()\nreturn self.remove_bin().items\ndef find_bin(self, weight: int) -&gt; Optional[Bin[T]]:\nfor bin_ in self.bins:\nif bin_.can_add(weight):\nreturn bin_\nreturn None\ndef remove_bin(self) -&gt; Bin[T]:\nif self.largest_bin_first:\nbin_ = max(self.bins, key=lambda b: b.weight())\nself.bins.remove(bin_)\nreturn bin_\nelse:\nreturn self.bins.pop(0)\n</code></pre>"},{"location":"reference/pyiceberg/utils/bin_packing/#pyiceberg.utils.bin_packing.PackingIterator.__iter__","title":"<code>__iter__()</code>","text":"<p>Returns an iterator for the PackingIterator class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/bin_packing.py</code> <pre><code>def __iter__(self) -&gt; PackingIterator[T]:\n\"\"\"Returns an iterator for the PackingIterator class.\"\"\"\nreturn self\n</code></pre>"},{"location":"reference/pyiceberg/utils/bin_packing/#pyiceberg.utils.bin_packing.PackingIterator.__next__","title":"<code>__next__()</code>","text":"<p>Returns the next item when iterating over the PackingIterator class.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/bin_packing.py</code> <pre><code>def __next__(self) -&gt; List[T]:\n\"\"\"Returns the next item when iterating over the PackingIterator class.\"\"\"\nwhile True:\ntry:\nitem = next(self.items)\nweight = self.weight_func(item)\nbin_ = self.find_bin(weight)\nif bin_ is not None:\nbin_.add(item, weight)\nelse:\nbin_ = Bin(self.target_weight)\nbin_.add(item, weight)\nself.bins.append(bin_)\nif len(self.bins) &gt; self.lookback:\nreturn self.remove_bin().items\nexcept StopIteration:\nbreak\nif len(self.bins) == 0:\nraise StopIteration()\nreturn self.remove_bin().items\n</code></pre>"},{"location":"reference/pyiceberg/utils/config/","title":"config","text":""},{"location":"reference/pyiceberg/utils/config/#pyiceberg.utils.config.Config","title":"<code>Config</code>","text":"Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/config.py</code> <pre><code>class Config:\nconfig: RecursiveDict\ndef __init__(self) -&gt; None:\nconfig = self._from_configuration_files() or {}\nconfig = merge_config(config, self._from_environment_variables(config))\nself.config = FrozenDict(**config)\n@staticmethod\ndef _from_configuration_files() -&gt; Optional[RecursiveDict]:\n\"\"\"Loads the first configuration file that its finds.\n        Will first look in the PYICEBERG_HOME env variable,\n        and then in the home directory.\n        \"\"\"\ndef _load_yaml(directory: Optional[str]) -&gt; Optional[RecursiveDict]:\nif directory:\npath = os.path.join(directory, PYICEBERG_YML)\nif os.path.isfile(path):\nwith open(path, encoding=\"utf-8\") as f:\nyml_str = f.read()\nfile_config = strictyaml.load(yml_str).data\nfile_config_lowercase = _lowercase_dictionary_keys(file_config)\nreturn file_config_lowercase\nreturn None\n# Give priority to the PYICEBERG_HOME directory\nif pyiceberg_home_config := _load_yaml(os.environ.get(PYICEBERG_HOME)):\nreturn pyiceberg_home_config\n# Look into the home directory\nif pyiceberg_home_config := _load_yaml(os.path.expanduser(\"~\")):\nreturn pyiceberg_home_config\n# Didn't find a config\nreturn None\n@staticmethod\ndef _from_environment_variables(config: RecursiveDict) -&gt; RecursiveDict:\n\"\"\"Reads the environment variables, to check if there are any prepended by PYICEBERG_.\n        Args:\n            config: Existing configuration that's being amended with configuration from environment variables.\n        Returns:\n            Amended configuration.\n        \"\"\"\ndef set_property(_config: RecursiveDict, path: List[str], config_value: str) -&gt; None:\nwhile len(path) &gt; 0:\nelement = path.pop(0)\nif len(path) == 0:\n# We're at the end\n_config[element] = config_value\nelse:\n# We have to go deeper\nif element not in _config:\n_config[element] = {}\nif isinstance(_config[element], dict):\n_config = _config[element]  # type: ignore\nelse:\nraise ValueError(\nf\"Incompatible configurations, merging dict with a value: {'.'.join(path)}, value: {config_value}\"\n)\nfor env_var, config_value in os.environ.items():\n# Make it lowercase to make it case-insensitive\nenv_var_lower = env_var.lower()\nif env_var_lower.startswith(PYICEBERG.lower()):\nkey = env_var_lower[len(PYICEBERG) :]\nparts = key.split(\"__\")\nparts_normalized = [part.replace(\"_\", \"-\") for part in parts]\nset_property(config, parts_normalized, config_value)\nreturn config\ndef get_default_catalog_name(self) -&gt; str:\n\"\"\"Returns the default catalog name.\n        Returns: The name of the default catalog in `default-catalog`.\n                 Returns `default` when the key cannot be found in the config file.\n        \"\"\"\nif default_catalog_name := self.config.get(DEFAULT_CATALOG):\nif not isinstance(default_catalog_name, str):\nraise ValueError(f\"Default catalog name should be a str: {default_catalog_name}\")\nreturn default_catalog_name\nreturn DEFAULT\ndef get_catalog_config(self, catalog_name: str) -&gt; Optional[RecursiveDict]:\nif CATALOG in self.config:\ncatalog_name_lower = catalog_name.lower()\ncatalogs = self.config[CATALOG]\nif not isinstance(catalogs, dict):\nraise ValueError(f\"Catalog configurations needs to be an object: {catalog_name}\")\nif catalog_name_lower in catalogs:\ncatalog_conf = catalogs[catalog_name_lower]\nassert isinstance(catalog_conf, dict), f\"Configuration path catalogs.{catalog_name_lower} needs to be an object\"\nreturn catalog_conf\nreturn None\n</code></pre>"},{"location":"reference/pyiceberg/utils/config/#pyiceberg.utils.config.Config.get_default_catalog_name","title":"<code>get_default_catalog_name()</code>","text":"<p>Returns the default catalog name.</p> <p>The name of the default catalog in `default-catalog`.</p> Type Description <code>str</code> <p>Returns <code>default</code> when the key cannot be found in the config file.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/config.py</code> <pre><code>def get_default_catalog_name(self) -&gt; str:\n\"\"\"Returns the default catalog name.\n    Returns: The name of the default catalog in `default-catalog`.\n             Returns `default` when the key cannot be found in the config file.\n    \"\"\"\nif default_catalog_name := self.config.get(DEFAULT_CATALOG):\nif not isinstance(default_catalog_name, str):\nraise ValueError(f\"Default catalog name should be a str: {default_catalog_name}\")\nreturn default_catalog_name\nreturn DEFAULT\n</code></pre>"},{"location":"reference/pyiceberg/utils/config/#pyiceberg.utils.config.merge_config","title":"<code>merge_config(lhs, rhs)</code>","text":"<p>Merges right-hand side into the left-hand side.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/config.py</code> <pre><code>def merge_config(lhs: RecursiveDict, rhs: RecursiveDict) -&gt; RecursiveDict:\n\"\"\"Merges right-hand side into the left-hand side.\"\"\"\nnew_config = lhs.copy()\nfor rhs_key, rhs_value in rhs.items():\nif rhs_key in new_config:\nlhs_value = new_config[rhs_key]\nif isinstance(lhs_value, dict) and isinstance(rhs_value, dict):\n# If they are both dicts, then we have to go deeper\nnew_config[rhs_key] = merge_config(lhs_value, rhs_value)\nelse:\n# Take the non-null value, with precedence on rhs\nnew_config[rhs_key] = lhs_value or rhs_value\nelse:\n# New key\nnew_config[rhs_key] = rhs_value\nreturn new_config\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/","title":"datetime","text":"<p>Helper methods for working with date/time representations.</p>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.date_str_to_days","title":"<code>date_str_to_days(date_str)</code>","text":"<p>Converts an ISO-8601 formatted date to days from 1970-01-01.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def date_str_to_days(date_str: str) -&gt; int:\n\"\"\"Converts an ISO-8601 formatted date to days from 1970-01-01.\"\"\"\nreturn (date.fromisoformat(date_str) - EPOCH_DATE).days\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.date_to_days","title":"<code>date_to_days(date_val)</code>","text":"<p>Converts a Python date object to days from 1970-01-01.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def date_to_days(date_val: date) -&gt; int:\n\"\"\"Converts a Python date object to days from 1970-01-01.\"\"\"\nreturn (date_val - EPOCH_DATE).days\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.datetime_to_micros","title":"<code>datetime_to_micros(dt)</code>","text":"<p>Converts a datetime to microseconds from 1970-01-01T00:00:00.000000.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def datetime_to_micros(dt: datetime) -&gt; int:\n\"\"\"Converts a datetime to microseconds from 1970-01-01T00:00:00.000000.\"\"\"\nif dt.tzinfo:\ndelta = dt - EPOCH_TIMESTAMPTZ\nelse:\ndelta = dt - EPOCH_TIMESTAMP\nreturn (delta.days * 86400 + delta.seconds) * 1_000_000 + delta.microseconds\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.days_to_date","title":"<code>days_to_date(days)</code>","text":"<p>Creates a date from the number of days from 1970-01-01.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def days_to_date(days: int) -&gt; date:\n\"\"\"Creates a date from the number of days from 1970-01-01.\"\"\"\nreturn EPOCH_DATE + timedelta(days)\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.micros_to_days","title":"<code>micros_to_days(timestamp)</code>","text":"<p>Converts a timestamp in microseconds to a date in days.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def micros_to_days(timestamp: int) -&gt; int:\n\"\"\"Converts a timestamp in microseconds to a date in days.\"\"\"\nreturn timedelta(microseconds=timestamp).days\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.micros_to_hours","title":"<code>micros_to_hours(micros)</code>","text":"<p>Converts a timestamp in microseconds to hours from 1970-01-01T00:00.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def micros_to_hours(micros: int) -&gt; int:\n\"\"\"Converts a timestamp in microseconds to hours from 1970-01-01T00:00.\"\"\"\nreturn micros // 3_600_000_000\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.micros_to_time","title":"<code>micros_to_time(micros)</code>","text":"<p>Converts a timestamp in microseconds to a time.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def micros_to_time(micros: int) -&gt; time:\n\"\"\"Converts a timestamp in microseconds to a time.\"\"\"\nmicros, microseconds = divmod(micros, 1000000)\nmicros, seconds = divmod(micros, 60)\nmicros, minutes = divmod(micros, 60)\nhours = micros\nreturn time(hour=hours, minute=minutes, second=seconds, microsecond=microseconds)\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.micros_to_timestamp","title":"<code>micros_to_timestamp(micros)</code>","text":"<p>Converts microseconds from epoch to a timestamp.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def micros_to_timestamp(micros: int) -&gt; datetime:\n\"\"\"Converts microseconds from epoch to a timestamp.\"\"\"\ndt = timedelta(microseconds=micros)\nreturn EPOCH_TIMESTAMP + dt\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.micros_to_timestamptz","title":"<code>micros_to_timestamptz(micros)</code>","text":"<p>Converts microseconds from epoch to an utc timestamp.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def micros_to_timestamptz(micros: int) -&gt; datetime:\n\"\"\"Converts microseconds from epoch to an utc timestamp.\"\"\"\ndt = timedelta(microseconds=micros)\nreturn EPOCH_TIMESTAMPTZ + dt\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.time_to_micros","title":"<code>time_to_micros(time_str)</code>","text":"<p>Converts an ISO-8601 formatted time to microseconds from midnight.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def time_to_micros(time_str: str) -&gt; int:\n\"\"\"Converts an ISO-8601 formatted time to microseconds from midnight.\"\"\"\nt = time.fromisoformat(time_str)\nreturn (((t.hour * 60 + t.minute) * 60) + t.second) * 1_000_000 + t.microsecond\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.timestamp_to_micros","title":"<code>timestamp_to_micros(timestamp_str)</code>","text":"<p>Converts an ISO-9601 formatted timestamp without zone to microseconds from 1970-01-01T00:00:00.000000.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def timestamp_to_micros(timestamp_str: str) -&gt; int:\n\"\"\"Converts an ISO-9601 formatted timestamp without zone to microseconds from 1970-01-01T00:00:00.000000.\"\"\"\nif ISO_TIMESTAMP.fullmatch(timestamp_str):\nreturn datetime_to_micros(datetime.fromisoformat(timestamp_str))\nif ISO_TIMESTAMPTZ.fullmatch(timestamp_str):\n# When we can match a timestamp without a zone, we can give a more specific error\nraise ValueError(f\"Zone offset provided, but not expected: {timestamp_str}\")\nraise ValueError(f\"Invalid timestamp without zone: {timestamp_str} (must be ISO-8601)\")\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.timestamptz_to_micros","title":"<code>timestamptz_to_micros(timestamptz_str)</code>","text":"<p>Converts an ISO-8601 formatted timestamp with zone to microseconds from 1970-01-01T00:00:00.000000+00:00.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def timestamptz_to_micros(timestamptz_str: str) -&gt; int:\n\"\"\"Converts an ISO-8601 formatted timestamp with zone to microseconds from 1970-01-01T00:00:00.000000+00:00.\"\"\"\nif ISO_TIMESTAMPTZ.fullmatch(timestamptz_str):\nreturn datetime_to_micros(datetime.fromisoformat(timestamptz_str))\nif ISO_TIMESTAMP.fullmatch(timestamptz_str):\n# When we can match a timestamp without a zone, we can give a more specific error\nraise ValueError(f\"Missing zone offset: {timestamptz_str} (must be ISO-8601)\")\nraise ValueError(f\"Invalid timestamp with zone: {timestamptz_str} (must be ISO-8601)\")\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.to_human_day","title":"<code>to_human_day(day_ordinal)</code>","text":"<p>Converts a DateType value to human string.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def to_human_day(day_ordinal: int) -&gt; str:\n\"\"\"Converts a DateType value to human string.\"\"\"\nreturn (EPOCH_DATE + timedelta(days=day_ordinal)).isoformat()\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.to_human_hour","title":"<code>to_human_hour(hour_ordinal)</code>","text":"<p>Converts a DateType value to human string.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def to_human_hour(hour_ordinal: int) -&gt; str:\n\"\"\"Converts a DateType value to human string.\"\"\"\nreturn (EPOCH_TIMESTAMP + timedelta(hours=hour_ordinal)).isoformat(\"-\", \"hours\")\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.to_human_month","title":"<code>to_human_month(month_ordinal)</code>","text":"<p>Converts a DateType value to human string.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def to_human_month(month_ordinal: int) -&gt; str:\n\"\"\"Converts a DateType value to human string.\"\"\"\nreturn f\"{EPOCH_TIMESTAMP.year + month_ordinal // 12:0=4d}-{1 + month_ordinal % 12:0=2d}\"\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.to_human_time","title":"<code>to_human_time(micros_from_midnight)</code>","text":"<p>Converts a TimeType value to human string.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def to_human_time(micros_from_midnight: int) -&gt; str:\n\"\"\"Converts a TimeType value to human string.\"\"\"\nreturn micros_to_time(micros_from_midnight).isoformat()\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.to_human_timestamp","title":"<code>to_human_timestamp(timestamp_micros)</code>","text":"<p>Converts a TimestampType value to human string.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def to_human_timestamp(timestamp_micros: int) -&gt; str:\n\"\"\"Converts a TimestampType value to human string.\"\"\"\nreturn (EPOCH_TIMESTAMP + timedelta(microseconds=timestamp_micros)).isoformat()\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.to_human_timestamptz","title":"<code>to_human_timestamptz(timestamp_micros)</code>","text":"<p>Converts a TimestamptzType value to human string.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def to_human_timestamptz(timestamp_micros: int) -&gt; str:\n\"\"\"Converts a TimestamptzType value to human string.\"\"\"\nreturn (EPOCH_TIMESTAMPTZ + timedelta(microseconds=timestamp_micros)).isoformat()\n</code></pre>"},{"location":"reference/pyiceberg/utils/datetime/#pyiceberg.utils.datetime.to_human_year","title":"<code>to_human_year(year_ordinal)</code>","text":"<p>Converts a DateType value to human string.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/datetime.py</code> <pre><code>def to_human_year(year_ordinal: int) -&gt; str:\n\"\"\"Converts a DateType value to human string.\"\"\"\nreturn f\"{EPOCH_TIMESTAMP.year + year_ordinal:0=4d}\"\n</code></pre>"},{"location":"reference/pyiceberg/utils/decimal/","title":"decimal","text":"<p>Helper methods for working with Python Decimals.</p>"},{"location":"reference/pyiceberg/utils/decimal/#pyiceberg.utils.decimal.bytes_required","title":"<code>bytes_required(value)</code>","text":"<p>Returns the minimum number of bytes needed to serialize a decimal or unscaled value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int | Decimal</code> <p>a Decimal value or unscaled int value.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the minimum number of bytes needed to serialize the value.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/decimal.py</code> <pre><code>def bytes_required(value: Union[int, Decimal]) -&gt; int:\n\"\"\"Returns the minimum number of bytes needed to serialize a decimal or unscaled value.\n    Args:\n        value (int | Decimal): a Decimal value or unscaled int value.\n    Returns:\n        int: the minimum number of bytes needed to serialize the value.\n    \"\"\"\nif isinstance(value, int):\nreturn (value.bit_length() + 7) // 8\nelif isinstance(value, Decimal):\nreturn (decimal_to_unscaled(value).bit_length() + 7) // 8\nraise ValueError(f\"Unsupported value: {value}\")\n</code></pre>"},{"location":"reference/pyiceberg/utils/decimal/#pyiceberg.utils.decimal.decimal_to_bytes","title":"<code>decimal_to_bytes(value)</code>","text":"<p>Returns a byte representation of a decimal.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Decimal</code> <p>a decimal value.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>the unscaled value of the Decimal as bytes.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/decimal.py</code> <pre><code>def decimal_to_bytes(value: Decimal) -&gt; bytes:\n\"\"\"Returns a byte representation of a decimal.\n    Args:\n        value (Decimal): a decimal value.\n    Returns:\n        bytes: the unscaled value of the Decimal as bytes.\n    \"\"\"\nunscaled_value = decimal_to_unscaled(value)\nreturn unscaled_value.to_bytes(bytes_required(unscaled_value), byteorder=\"big\", signed=True)\n</code></pre>"},{"location":"reference/pyiceberg/utils/decimal/#pyiceberg.utils.decimal.decimal_to_unscaled","title":"<code>decimal_to_unscaled(value)</code>","text":"<p>Get an unscaled value given a Decimal value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Decimal</code> <p>A Decimal instance.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The unscaled value.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/decimal.py</code> <pre><code>def decimal_to_unscaled(value: Decimal) -&gt; int:\n\"\"\"Get an unscaled value given a Decimal value.\n    Args:\n        value (Decimal): A Decimal instance.\n    Returns:\n        int: The unscaled value.\n    \"\"\"\nsign, digits, _ = value.as_tuple()\nreturn int(Decimal((sign, digits, 0)).to_integral_value())\n</code></pre>"},{"location":"reference/pyiceberg/utils/decimal/#pyiceberg.utils.decimal.truncate_decimal","title":"<code>truncate_decimal(value, width)</code>","text":"<p>Get a truncated Decimal value given a decimal value and a width.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Decimal</code> <p>a decimal value.</p> required <code>width</code> <code>int</code> <p>A width for the returned Decimal instance.</p> required <p>Returns:</p> Name Type Description <code>Decimal</code> <code>Decimal</code> <p>A truncated Decimal instance.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/decimal.py</code> <pre><code>def truncate_decimal(value: Decimal, width: int) -&gt; Decimal:\n\"\"\"Get a truncated Decimal value given a decimal value and a width.\n    Args:\n        value (Decimal): a decimal value.\n        width (int): A width for the returned Decimal instance.\n    Returns:\n        Decimal: A truncated Decimal instance.\n    \"\"\"\nunscaled_value = decimal_to_unscaled(value)\napplied_value = unscaled_value - (((unscaled_value % width) + width) % width)\nreturn unscaled_to_decimal(applied_value, abs(int(value.as_tuple().exponent)))\n</code></pre>"},{"location":"reference/pyiceberg/utils/decimal/#pyiceberg.utils.decimal.unscaled_to_decimal","title":"<code>unscaled_to_decimal(unscaled, scale)</code>","text":"<p>Get a scaled Decimal value given an unscaled value and a scale.</p> <p>Parameters:</p> Name Type Description Default <code>unscaled</code> <code>int</code> <p>An unscaled value.</p> required <code>scale</code> <code>int</code> <p>A scale to set for the returned Decimal instance.</p> required <p>Returns:</p> Name Type Description <code>Decimal</code> <code>Decimal</code> <p>A scaled Decimal instance.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/decimal.py</code> <pre><code>def unscaled_to_decimal(unscaled: int, scale: int) -&gt; Decimal:\n\"\"\"Get a scaled Decimal value given an unscaled value and a scale.\n    Args:\n        unscaled (int): An unscaled value.\n        scale (int): A scale to set for the returned Decimal instance.\n    Returns:\n        Decimal: A scaled Decimal instance.\n    \"\"\"\nsign, digits, _ = Decimal(unscaled).as_tuple()\nreturn Decimal((sign, digits, -scale))\n</code></pre>"},{"location":"reference/pyiceberg/utils/deprecated/","title":"deprecated","text":""},{"location":"reference/pyiceberg/utils/deprecated/#pyiceberg.utils.deprecated.deprecated","title":"<code>deprecated(deprecated_in, removed_in, help_message=None)</code>","text":"<p>A decorator which can be used to mark functions as deprecated.</p> <p>Adding this will result in a warning being emitted when the function is used.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/deprecated.py</code> <pre><code>def deprecated(deprecated_in: str, removed_in: str, help_message: Optional[str] = None) -&gt; Callable:  # type: ignore\n\"\"\"A decorator which can be used to mark functions as deprecated.\n    Adding this will result in a warning being emitted when the function is used.\n    \"\"\"\nif help_message is not None:\nhelp_message = f\" {help_message}.\"\ndef decorator(func: Callable):  # type: ignore\n@functools.wraps(func)\ndef new_func(*args: Any, **kwargs: Any) -&gt; Any:\nwarnings.simplefilter(\"always\", DeprecationWarning)  # turn off filter\nwarnings.warn(\nf\"Call to {func.__name__}, deprecated in {deprecated_in}, will be removed in {removed_in}.{help_message}\",\ncategory=DeprecationWarning,\nstacklevel=2,\n)\nwarnings.simplefilter(\"default\", DeprecationWarning)  # reset filter\nreturn func(*args, **kwargs)\nreturn new_func\nreturn decorator\n</code></pre>"},{"location":"reference/pyiceberg/utils/parsing/","title":"parsing","text":""},{"location":"reference/pyiceberg/utils/parsing/#pyiceberg.utils.parsing.ParseNumberFromBrackets","title":"<code>ParseNumberFromBrackets</code>","text":"<p>Extracts the size from a string in the form of prefix[22].</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/parsing.py</code> <pre><code>class ParseNumberFromBrackets:\n\"\"\"Extracts the size from a string in the form of prefix[22].\"\"\"\nregex: Pattern  # type: ignore\nprefix: str\ndef __init__(self, prefix: str):\nself.prefix = prefix\nself.regex = re.compile(rf\"{prefix}\\[(\\d+)\\]\")\ndef match(self, str_repr: str) -&gt; int:\nmatches = self.regex.search(str_repr)\nif matches:\nreturn int(matches.group(1))\nraise ValueError(f\"Could not match {str_repr}, expected format {self.prefix}[22]\")\n</code></pre>"},{"location":"reference/pyiceberg/utils/schema_conversion/","title":"schema_conversion","text":"<p>Utility class for converting between Avro and Iceberg schemas.</p>"},{"location":"reference/pyiceberg/utils/schema_conversion/#pyiceberg.utils.schema_conversion.AvroSchemaConversion","title":"<code>AvroSchemaConversion</code>","text":"Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/schema_conversion.py</code> <pre><code>class AvroSchemaConversion:\ndef avro_to_iceberg(self, avro_schema: Dict[str, Any]) -&gt; Schema:\n\"\"\"Converts an Apache Avro into an Apache Iceberg schema equivalent.\n        This expects to have field id's to be encoded in the Avro schema:\n            {\n                \"type\": \"record\",\n                \"name\": \"manifest_file\",\n                \"fields\": [\n                    {\"name\": \"manifest_path\", \"type\": \"string\", \"doc\": \"Location URI with FS scheme\", \"field-id\": 500},\n                    {\"name\": \"manifest_length\", \"type\": \"long\", \"doc\": \"Total file size in bytes\", \"field-id\": 501}\n                ]\n            }\n        Example:\n            This converts an Avro schema into an Iceberg schema:\n            &gt;&gt;&gt; avro_schema = AvroSchemaConversion().avro_to_iceberg({\n            ...     \"type\": \"record\",\n            ...     \"name\": \"manifest_file\",\n            ...     \"fields\": [\n            ...         {\"name\": \"manifest_path\", \"type\": \"string\", \"doc\": \"Location URI with FS scheme\", \"field-id\": 500},\n            ...         {\"name\": \"manifest_length\", \"type\": \"long\", \"doc\": \"Total file size in bytes\", \"field-id\": 501}\n            ...     ]\n            ... })\n            &gt;&gt;&gt; iceberg_schema = Schema(\n            ...     NestedField(\n            ...         field_id=500, name=\"manifest_path\", field_type=StringType(), required=False, doc=\"Location URI with FS scheme\"\n            ...     ),\n            ...     NestedField(\n            ...         field_id=501, name=\"manifest_length\", field_type=LongType(), required=False, doc=\"Total file size in bytes\"\n            ...     ),\n            ...     schema_id=1\n            ... )\n            &gt;&gt;&gt; avro_schema == iceberg_schema\n            True\n        Args:\n            avro_schema (Dict[str, Any]): The JSON decoded Avro schema.\n        Returns:\n            Equivalent Iceberg schema.\n        \"\"\"\nreturn Schema(*[self._convert_field(field) for field in avro_schema[\"fields\"]], schema_id=1)\ndef _resolve_union(\nself, type_union: Union[Dict[str, str], List[Union[str, Dict[str, str]]], str]\n) -&gt; Tuple[Union[str, Dict[str, Any]], bool]:\n\"\"\"\n        Converts Unions into their type and resolves if the field is required.\n        Examples:\n            &gt;&gt;&gt; AvroSchemaConversion()._resolve_union('str')\n            ('str', True)\n            &gt;&gt;&gt; AvroSchemaConversion()._resolve_union(['null', 'str'])\n            ('str', False)\n            &gt;&gt;&gt; AvroSchemaConversion()._resolve_union([{'type': 'str'}])\n            ({'type': 'str'}, True)\n            &gt;&gt;&gt; AvroSchemaConversion()._resolve_union(['null', {'type': 'str'}])\n            ({'type': 'str'}, False)\n        Args:\n            type_union: The field, can be a string 'str', list ['null', 'str'], or dict {\"type\": 'str'}.\n        Returns:\n            A tuple containing the type and if required.\n        Raises:\n            TypeError: In the case non-optional union types are encountered.\n        \"\"\"\navro_types: Union[Dict[str, str], List[Union[Dict[str, str], str]]]\nif isinstance(type_union, str):\n# It is a primitive and required\nreturn type_union, True\nelif isinstance(type_union, dict):\n# It is a context and required\nreturn type_union, True\nelse:\navro_types = type_union\nif len(avro_types) &gt; 2:\nraise TypeError(f\"Non-optional types aren't part of the Iceberg specification: {avro_types}\")\n# For the Iceberg spec it is required to set the default value to null\n# From https://iceberg.apache.org/spec/#avro\n# Optional fields must always set the Avro field default value to null.\n#\n# This means that null has to come first:\n# https://avro.apache.org/docs/current/spec.html\n# type of the default value must match the first element of the union.\nif \"null\" != avro_types[0]:\nraise TypeError(\"Only null-unions are supported\")\n# Filter the null value and return the type\nreturn list(filter(lambda t: t != \"null\", avro_types))[0], False\ndef _convert_schema(self, avro_type: Union[str, Dict[str, Any]]) -&gt; IcebergType:\n\"\"\"\n        Resolves the Avro type.\n        Args:\n            avro_type: The Avro type, can be simple or complex.\n        Returns:\n            The equivalent IcebergType.\n        Raises:\n            ValueError: When there are unknown types\n        \"\"\"\nif isinstance(avro_type, str) and avro_type in PRIMITIVE_FIELD_TYPE_MAPPING:\nreturn PRIMITIVE_FIELD_TYPE_MAPPING[avro_type]\nelif isinstance(avro_type, dict):\nif \"logicalType\" in avro_type:\nreturn self._convert_logical_type(avro_type)\nelse:\n# Resolve potential nested types\nwhile \"type\" in avro_type and isinstance(avro_type[\"type\"], dict):\navro_type = avro_type[\"type\"]\ntype_identifier = avro_type[\"type\"]\nif type_identifier == \"record\":\nreturn self._convert_record_type(avro_type)\nelif type_identifier == \"array\":\nreturn self._convert_array_type(avro_type)\nelif type_identifier == \"map\":\nreturn self._convert_map_type(avro_type)\nelif type_identifier == \"fixed\":\nreturn self._convert_fixed_type(avro_type)\nelif isinstance(type_identifier, str) and type_identifier in PRIMITIVE_FIELD_TYPE_MAPPING:\nreturn PRIMITIVE_FIELD_TYPE_MAPPING[type_identifier]\nelse:\nraise TypeError(f\"Unknown type: {avro_type}\")\nelse:\nraise TypeError(f\"Unknown type: {avro_type}\")\ndef _convert_field(self, field: Dict[str, Any]) -&gt; NestedField:\n\"\"\"Converts an Avro field into an Iceberg equivalent field.\n        Args:\n            field: The Avro field.\n        Returns:\n            The Iceberg equivalent field.\n        \"\"\"\nif \"field-id\" not in field:\nraise ValueError(f\"Cannot convert field, missing field-id: {field}\")\nplain_type, required = self._resolve_union(field[\"type\"])\nreturn NestedField(\nfield_id=field[\"field-id\"],\nname=field[\"name\"],\nfield_type=self._convert_schema(plain_type),\nrequired=required,\ndoc=field.get(\"doc\"),\n)\ndef _convert_record_type(self, record_type: Dict[str, Any]) -&gt; StructType:\n\"\"\"\n        Converts the fields from a record into an Iceberg struct.\n        Examples:\n            &gt;&gt;&gt; from pyiceberg.utils.schema_conversion import AvroSchemaConversion\n            &gt;&gt;&gt; record_type = {\n            ...     \"type\": \"record\",\n            ...     \"name\": \"r508\",\n            ...     \"fields\": [{\n            ...         \"name\": \"contains_null\",\n            ...         \"type\": \"boolean\",\n            ...         \"doc\": \"True if any file has a null partition value\",\n            ...         \"field-id\": 509,\n            ...      }, {\n            ...          \"name\": \"contains_nan\",\n            ...          \"type\": [\"null\", \"boolean\"],\n            ...          \"doc\": \"True if any file has a nan partition value\",\n            ...          \"default\": None,\n            ...          \"field-id\": 518,\n            ...      }],\n            ... }\n            &gt;&gt;&gt; actual = AvroSchemaConversion()._convert_record_type(record_type)\n            &gt;&gt;&gt; expected = StructType(\n            ...     fields=(\n            ...         NestedField(\n            ...             field_id=509,\n            ...             name=\"contains_null\",\n            ...             field_type=BooleanType(),\n            ...             required=False,\n            ...             doc=\"True if any file has a null partition value\",\n            ...         ),\n            ...         NestedField(\n            ...             field_id=518,\n            ...             name=\"contains_nan\",\n            ...             field_type=BooleanType(),\n            ...             required=True,\n            ...             doc=\"True if any file has a nan partition value\",\n            ...         ),\n            ...     )\n            ... )\n            &gt;&gt;&gt; expected == actual\n            True\n        Args:\n            record_type: The record type itself.\n        Returns: A StructType.\n        \"\"\"\nif record_type[\"type\"] != \"record\":\nraise ValueError(f\"Expected record type, got: {record_type}\")\nreturn StructType(*[self._convert_field(field) for field in record_type[\"fields\"]])\ndef _convert_array_type(self, array_type: Dict[str, Any]) -&gt; ListType:\nif \"element-id\" not in array_type:\nraise ValueError(f\"Cannot convert array-type, missing element-id: {array_type}\")\nplain_type, element_required = self._resolve_union(array_type[\"items\"])\nreturn ListType(\nelement_id=array_type[\"element-id\"],\nelement_type=self._convert_schema(plain_type),\nelement_required=element_required,\n)\ndef _convert_map_type(self, map_type: Dict[str, Any]) -&gt; MapType:\n\"\"\"Converts an avro map type into an Iceberg MapType.\n        Args:\n            map_type: The dict that describes the Avro map type.\n        Examples:\n            &gt;&gt;&gt; from pyiceberg.utils.schema_conversion import AvroSchemaConversion\n            &gt;&gt;&gt; avro_field = {\n            ...     \"type\": \"map\",\n            ...     \"values\": [\"null\", \"long\"],\n            ...     \"key-id\": 101,\n            ...     \"value-id\": 102,\n            ... }\n            &gt;&gt;&gt; actual = AvroSchemaConversion()._convert_map_type(avro_field)\n            &gt;&gt;&gt; expected = MapType(\n            ...     key_id=101,\n            ...     key_type=StringType(),\n            ...     value_id=102,\n            ...     value_type=LongType(),\n            ...     value_required=True\n            ... )\n            &gt;&gt;&gt; actual == expected\n            True\n        Returns: A MapType.\n        \"\"\"\nvalue_type, value_required = self._resolve_union(map_type[\"values\"])\nreturn MapType(\nkey_id=map_type[\"key-id\"],\n# Avro only supports string keys\nkey_type=StringType(),\nvalue_id=map_type[\"value-id\"],\nvalue_type=self._convert_schema(value_type),\nvalue_required=value_required,\n)\ndef _convert_logical_type(self, avro_logical_type: Dict[str, Any]) -&gt; IcebergType:\n\"\"\"Convert a schema with a logical type annotation into an IcebergType.\n        For the decimal and map we need to fetch more keys from the dict, and for\n        the simple ones we can just look it up in the mapping.\n        Examples:\n            &gt;&gt;&gt; from pyiceberg.utils.schema_conversion import AvroSchemaConversion\n            &gt;&gt;&gt; avro_logical_type = {\n            ...     \"type\": \"int\",\n            ...     \"logicalType\": \"date\"\n            ... }\n            &gt;&gt;&gt; actual = AvroSchemaConversion()._convert_logical_type(avro_logical_type)\n            &gt;&gt;&gt; actual == DateType()\n            True\n        Args:\n            avro_logical_type: The logical type.\n        Returns:\n            The converted logical type.\n        Raises:\n            ValueError: When the logical type is unknown.\n        \"\"\"\nlogical_type = avro_logical_type[\"logicalType\"]\nphysical_type = avro_logical_type[\"type\"]\nif logical_type == \"decimal\":\nreturn self._convert_logical_decimal_type(avro_logical_type)\nelif logical_type == \"map\":\nreturn self._convert_logical_map_type(avro_logical_type)\nelif (logical_type, physical_type) in LOGICAL_FIELD_TYPE_MAPPING:\nreturn LOGICAL_FIELD_TYPE_MAPPING[(logical_type, physical_type)]\nelse:\nraise ValueError(f\"Unknown logical/physical type combination: {avro_logical_type}\")\ndef _convert_logical_decimal_type(self, avro_type: Dict[str, Any]) -&gt; DecimalType:\n\"\"\"Converts an avro type to an Iceberg DecimalType.\n        Args:\n            avro_type: The Avro type.\n        Examples:\n            &gt;&gt;&gt; from pyiceberg.utils.schema_conversion import AvroSchemaConversion\n            &gt;&gt;&gt; avro_decimal_type = {\n            ...     \"type\": \"bytes\",\n            ...     \"logicalType\": \"decimal\",\n            ...     \"precision\": 19,\n            ...     \"scale\": 25\n            ... }\n            &gt;&gt;&gt; actual = AvroSchemaConversion()._convert_logical_decimal_type(avro_decimal_type)\n            &gt;&gt;&gt; expected = DecimalType(\n            ...     precision=19,\n            ...     scale=25\n            ... )\n            &gt;&gt;&gt; actual == expected\n            True\n        Returns:\n            A Iceberg DecimalType.\n        \"\"\"\nreturn DecimalType(precision=avro_type[\"precision\"], scale=avro_type[\"scale\"])\ndef _convert_logical_map_type(self, avro_type: Dict[str, Any]) -&gt; MapType:\n\"\"\"Converts an avro map type to an Iceberg MapType.\n        In the case where a map hasn't a key as a type you can use a logical map to still encode this in Avro.\n        Args:\n            avro_type: The Avro Type.\n        Examples:\n            &gt;&gt;&gt; from pyiceberg.utils.schema_conversion import AvroSchemaConversion\n            &gt;&gt;&gt; avro_type = {\n            ...     \"type\": \"array\",\n            ...     \"logicalType\": \"map\",\n            ...     \"items\": {\n            ...         \"type\": \"record\",\n            ...         \"name\": \"k101_v102\",\n            ...         \"fields\": [\n            ...             {\"name\": \"key\", \"type\": \"int\", \"field-id\": 101},\n            ...             {\"name\": \"value\", \"type\": \"string\", \"field-id\": 102},\n            ...         ],\n            ...     },\n            ... }\n            &gt;&gt;&gt; actual = AvroSchemaConversion()._convert_logical_map_type(avro_type)\n            &gt;&gt;&gt; expected = MapType(\n            ...         key_id=101,\n            ...         key_type=IntegerType(),\n            ...         value_id=102,\n            ...         value_type=StringType(),\n            ...         value_required=False\n            ... )\n            &gt;&gt;&gt; actual == expected\n            True\n        .. _Apache Iceberg specification:\n            https://iceberg.apache.org/spec/#appendix-a-format-specific-requirements\n        Returns:\n            The logical map.\n        \"\"\"\nfields = avro_type[\"items\"][\"fields\"]\nif len(fields) != 2:\nraise ValueError(f'Invalid key-value pair schema: {avro_type[\"items\"]}')\nkey = self._convert_field(list(filter(lambda f: f[\"name\"] == \"key\", fields))[0])\nvalue = self._convert_field(list(filter(lambda f: f[\"name\"] == \"value\", fields))[0])\nreturn MapType(\nkey_id=key.field_id,\nkey_type=key.field_type,\nvalue_id=value.field_id,\nvalue_type=value.field_type,\nvalue_required=value.required,\n)\ndef _convert_fixed_type(self, avro_type: Dict[str, Any]) -&gt; FixedType:\n\"\"\"\n        Converts Avro Type to the equivalent Iceberg fixed type.\n        - https://avro.apache.org/docs/current/spec.html#Fixed\n        Args:\n            avro_type: The Avro type.\n        Examples:\n            &gt;&gt;&gt; from pyiceberg.utils.schema_conversion import AvroSchemaConversion\n            &gt;&gt;&gt; avro_fixed_type = {\n            ...     \"name\": \"md5\",\n            ...     \"type\": \"fixed\",\n            ...     \"size\": 16\n            ... }\n            &gt;&gt;&gt; FixedType(length=16) == AvroSchemaConversion()._convert_fixed_type(avro_fixed_type)\n            True\n        Returns:\n            An Iceberg equivalent fixed type.\n        \"\"\"\nreturn FixedType(length=avro_type[\"size\"])\n</code></pre>"},{"location":"reference/pyiceberg/utils/schema_conversion/#pyiceberg.utils.schema_conversion.AvroSchemaConversion.avro_to_iceberg","title":"<code>avro_to_iceberg(avro_schema)</code>","text":"<p>Converts an Apache Avro into an Apache Iceberg schema equivalent.</p> <p>This expects to have field id's to be encoded in the Avro schema:</p> <pre><code>{\n    \"type\": \"record\",\n    \"name\": \"manifest_file\",\n    \"fields\": [\n        {\"name\": \"manifest_path\", \"type\": \"string\", \"doc\": \"Location URI with FS scheme\", \"field-id\": 500},\n        {\"name\": \"manifest_length\", \"type\": \"long\", \"doc\": \"Total file size in bytes\", \"field-id\": 501}\n    ]\n}\n</code></pre> Example <p>This converts an Avro schema into an Iceberg schema:</p> <p>avro_schema = AvroSchemaConversion().avro_to_iceberg({ ...     \"type\": \"record\", ...     \"name\": \"manifest_file\", ...     \"fields\": [ ...         {\"name\": \"manifest_path\", \"type\": \"string\", \"doc\": \"Location URI with FS scheme\", \"field-id\": 500}, ...         {\"name\": \"manifest_length\", \"type\": \"long\", \"doc\": \"Total file size in bytes\", \"field-id\": 501} ...     ] ... }) iceberg_schema = Schema( ...     NestedField( ...         field_id=500, name=\"manifest_path\", field_type=StringType(), required=False, doc=\"Location URI with FS scheme\" ...     ), ...     NestedField( ...         field_id=501, name=\"manifest_length\", field_type=LongType(), required=False, doc=\"Total file size in bytes\" ...     ), ...     schema_id=1 ... ) avro_schema == iceberg_schema True</p> <p>Parameters:</p> Name Type Description Default <code>avro_schema</code> <code>Dict[str, Any]</code> <p>The JSON decoded Avro schema.</p> required <p>Returns:</p> Type Description <code>Schema</code> <p>Equivalent Iceberg schema.</p> Source code in <code>/home/runner/work/iceberg/iceberg/python/pyiceberg/utils/schema_conversion.py</code> <pre><code>def avro_to_iceberg(self, avro_schema: Dict[str, Any]) -&gt; Schema:\n\"\"\"Converts an Apache Avro into an Apache Iceberg schema equivalent.\n    This expects to have field id's to be encoded in the Avro schema:\n        {\n            \"type\": \"record\",\n            \"name\": \"manifest_file\",\n            \"fields\": [\n                {\"name\": \"manifest_path\", \"type\": \"string\", \"doc\": \"Location URI with FS scheme\", \"field-id\": 500},\n                {\"name\": \"manifest_length\", \"type\": \"long\", \"doc\": \"Total file size in bytes\", \"field-id\": 501}\n            ]\n        }\n    Example:\n        This converts an Avro schema into an Iceberg schema:\n        &gt;&gt;&gt; avro_schema = AvroSchemaConversion().avro_to_iceberg({\n        ...     \"type\": \"record\",\n        ...     \"name\": \"manifest_file\",\n        ...     \"fields\": [\n        ...         {\"name\": \"manifest_path\", \"type\": \"string\", \"doc\": \"Location URI with FS scheme\", \"field-id\": 500},\n        ...         {\"name\": \"manifest_length\", \"type\": \"long\", \"doc\": \"Total file size in bytes\", \"field-id\": 501}\n        ...     ]\n        ... })\n        &gt;&gt;&gt; iceberg_schema = Schema(\n        ...     NestedField(\n        ...         field_id=500, name=\"manifest_path\", field_type=StringType(), required=False, doc=\"Location URI with FS scheme\"\n        ...     ),\n        ...     NestedField(\n        ...         field_id=501, name=\"manifest_length\", field_type=LongType(), required=False, doc=\"Total file size in bytes\"\n        ...     ),\n        ...     schema_id=1\n        ... )\n        &gt;&gt;&gt; avro_schema == iceberg_schema\n        True\n    Args:\n        avro_schema (Dict[str, Any]): The JSON decoded Avro schema.\n    Returns:\n        Equivalent Iceberg schema.\n    \"\"\"\nreturn Schema(*[self._convert_field(field) for field in avro_schema[\"fields\"]], schema_id=1)\n</code></pre>"},{"location":"reference/pyiceberg/utils/singleton/","title":"singleton","text":"<p>This is a singleton metaclass that can be used to cache and re-use existing objects.</p> <p>In the Iceberg codebase we have a lot of objects that are stateless (for example Types such as StringType, BooleanType etc). FixedTypes have arguments (eg. Fixed[22]) that we also make part of the key when caching the newly created object.</p> <p>The Singleton uses a metaclass which essentially defines a new type. When the Type gets created, it will first evaluate the <code>__call__</code> method with all the arguments. If we already initialized a class earlier, we'll just return it.</p> <p>More information on metaclasses: https://docs.python.org/3/reference/datamodel.html#metaclasses</p>"}]}